{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipay.png","path":"images/alipay.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/link.svg","path":"images/link.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.png","path":"images/wechatpay.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/mo.min.js","path":"js/mo.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Java并发 - ArrayList.md","hash":"3d3a51b927a22e026de1fcebf50f5d063c25464e","modified":1646220680843},{"_id":"source/_posts/Java并发 - AQS抽象队列同步器.md","hash":"b21b51d630e0f8283d3a2eaa30754876d7a4c068","modified":1646220425006},{"_id":"source/_posts/Java并发 - ForkJoin.md","hash":"ed8b80695275f315cabeb9a8dc4b1a25e44b0898","modified":1646042887552},{"_id":"source/_posts/Java并发 - Callable.md","hash":"3955cd15a071b1db1d5a94cc87182c8491251486","modified":1646045966090},{"_id":"source/_posts/Java并发 - ReetrantLock、读写锁.md","hash":"65d5bcb3605707e4b9dfd0893134a1976c72033d","modified":1646220496185},{"_id":"source/_posts/Java并发 - JUC 单例模式.md","hash":"b3a3d84cf18ee7b2f7ea22664b4c3d1f39f17f13","modified":1646045746153},{"_id":"source/_posts/Java并发 - JMM 内存模型.md","hash":"96f11ef38a1aa558857b3e12bee933f87f5918c1","modified":1646220475502},{"_id":"source/_posts/Java并发 - synchronized.md","hash":"db1a47dd4eb6e94b6f513a357b58d774acfcf6a4","modified":1646220525252},{"_id":"source/tags/index.md","hash":"8bc24d7d070886904aea7094248a087707e5059b","modified":1645953639488},{"_id":"source/_posts/Java并发 - Queue.md","hash":"148524dfbcfba4eda280ec3efe9343966fff34c5","modified":1646045419795},{"_id":"source/_posts/Java并发 - interrupt+isInterrupted.md","hash":"b7a0d0d9526241c52921208aba092db27f3c7bf6","modified":1646045700713},{"_id":"source/_posts/Java并发 - Semaphore信号量.md","hash":"45707f270c00ef321fe5963de9e0099b612635c1","modified":1646045801123},{"_id":"source/friends/index.md","hash":"6da8ac7c38dc063877d926bdfd95964d6d487297","modified":1646201008081},{"_id":"source/_posts/images/Aware - 类关系图.png","hash":"280869274c59012eebf7f6f2c177792be27f5fbc","modified":1621434630177},{"_id":"source/_posts/images/CAP - 示例2.png","hash":"951f5c62d65bae2789be97db59ffbab1dd4ab212","modified":1622164914131},{"_id":"source/_posts/images/CAP - 示例1.png","hash":"551fe33f13c2f947de0402818e18222d2f27e956","modified":1622164850464},{"_id":"source/_posts/images/CAS的AAB问题.png","hash":"4fdb6156ef699cfbba4f41355d581dee7118b109","modified":1617806398041},{"_id":"source/_posts/images/CPU高速缓存级别.png","hash":"c3d0fc6735c910ac2273df44aba86101387f53e4","modified":1617672837044},{"_id":"source/_posts/images/ClassLoader的继承关系.png","hash":"e9716ed140d78f32d6e438af2e957d421676787a","modified":1629905424777},{"_id":"source/_posts/images/ClassLoader类的方法.png","hash":"8bc867a0c026d0f5ea917129c0c2d5855a2871d9","modified":1629905297742},{"_id":"source/_posts/images/ConcurrentHashMap - sizeCtl参数含义.png","hash":"36e586e17dee50b9358e29c205a36cec154b303c","modified":1621779813066},{"_id":"source/_posts/images/HashMap_Resize.png","hash":"3751ebc345d81508c88e1de7167cf62160896b7b","modified":1617290063525},{"_id":"source/_posts/images/HashMap继承关系.PNG","hash":"8f199e930fb8c91364f0194e1226f327a9ea128f","modified":1617108418486},{"_id":"source/_posts/images/JDK1.7-ConcurrentHashMap 扩容（三）.png","hash":"5e6ff7991dd3e7285555debf301221d0013b80f8","modified":1619749441473},{"_id":"source/_posts/images/JDK1.7-ConcurrentHashMap 扩容（二）.png","hash":"6a6e9d818ba509d430d9ed7728daa65b54782538","modified":1619749407503},{"_id":"source/_posts/images/JDK1.7-ConcurrentHashMap 断点调试（一）.png","hash":"089b6ca2a179992a06604555b31837e536edc646","modified":1619749171034},{"_id":"source/_posts/images/JDK1.7-ConcurrentHashMap结构图.png","hash":"fe89837875afca67e6d57b20b73d2adaab864c99","modified":1619747679608},{"_id":"source/_posts/images/JDK1.7-ConcurrentHashMap 断点调试（三）.png","hash":"f8246dd5300c73fd77eba24430ab414967414c94","modified":1619749273409},{"_id":"source/_posts/images/JMM.png","hash":"316bef2d71ec11e2a34d190dfa91d3d3badb8f12","modified":1617634368473},{"_id":"source/_posts/images/JDK1.7-ConcurrentHashMap 断点调试（二）.png","hash":"82aa7141d42a550fb9e25761adf04e0c35b7dcca","modified":1619749203033},{"_id":"source/_posts/images/JVM - 堆区参数调配.png","hash":"8f5d05efd50c3effa2eb5f7b57e6cea298bad356","modified":1633704222215},{"_id":"source/_posts/images/JVM - 对象的分配流程.png","hash":"d6257acc7f0802a59f4a9d7731dd0c1949fd8e92","modified":1640103628174},{"_id":"source/_posts/images/JVM - 热点代码的判定过程.png","hash":"682b8a9105bb1baaea6ca366236745b4c854af3b","modified":1639900480498},{"_id":"source/_posts/images/JVM - 第二次GC过程.png","hash":"20f47ec611c404b10a75640f554fdcbb4c4404e7","modified":1634568958777},{"_id":"source/_posts/images/JVM - 第一次GC过程.png","hash":"c3e878077a4f7c5c6ae53cefa311e1d3c4cf909d","modified":1634568655947},{"_id":"source/_posts/images/JVM - 类加载子系统.png","hash":"8e748f623b89042219a1fa2d828c5f4677b41bbe","modified":1629623373807},{"_id":"source/_posts/images/JVM - 第N次GC过程.png","hash":"aa78d986d5aeddfe5115ae0bd91eba143f4a2000","modified":1634569119607},{"_id":"source/_posts/images/JVM-Xmxsize.png","hash":"a6fa818ce4e52d35e33eb645a2e4f0f955629e5d","modified":1633598191988},{"_id":"source/_posts/images/JVM-double和long会占据两个slot.png","hash":"7acdd6d93fce52949cf3c6d090cdc38bae240710","modified":1631432406735},{"_id":"source/_posts/images/JVM-栈帧的内部结构.png","hash":"c313894e72a4e01ca71eab6942d8453d679c013e","modified":1631338723215},{"_id":"source/_posts/images/JVM-除double和long外其它数值类型占1个slot.png","hash":"88070e2f348489629805a5ad9b09e7b7cdc286f4","modified":1631432531543},{"_id":"source/_posts/images/MQ-异步处理完成通知流程.png","hash":"875746e29400c3c4575b73f3e8ade0f5d888b277","modified":1624081290213},{"_id":"source/_posts/images/MySQL - MyISAM索引.png","hash":"32ca44d76c8d08dfaba3c7709bdedee477c190dd","modified":1630939843777},{"_id":"source/_posts/images/MySQL-BTree.png","hash":"9a1ee05061e98bd665a94f63222e06b9493c02ec","modified":1630939597592},{"_id":"source/_posts/images/MySQL-BTree聚簇索引和非聚簇索引.png","hash":"b3e8e468a2f60b88e5f0bc190b770cc186491c37","modified":1630939731233},{"_id":"source/_posts/images/MySQL - MyISAM非聚簇索引.png","hash":"86ba6c53c015028dfdcf488292fb61f73bf1eb56","modified":1630939874953},{"_id":"source/_posts/images/MySQL-B+树.png","hash":"23c472942c8362939d37ec1326f236e82e4272ff","modified":1630939794276},{"_id":"source/_posts/images/MySQL-MVCC(1).png","hash":"2ef98d6e61cc72c7ae0871276b10c55c5b16b10f","modified":1630940076316},{"_id":"source/_posts/images/MySQL-B树.png","hash":"3415bf6a5f6bc93fac4b16d49b32f0dd2152277c","modified":1630939771110},{"_id":"source/_posts/images/MySQL-MVCC(2).png","hash":"dfc2cf63006cfebd68c9d7833b40b762cbe107bd","modified":1630940103442},{"_id":"source/_posts/images/MySQL-MVCC(3).png","hash":"301577384c48e56af9011c15ab98f8a0489a8950","modified":1630940126406},{"_id":"source/_posts/images/MySQL-MVCC(6).png","hash":"db915046b68fdfd8224af88bb6cc768ea9f244e8","modified":1630940206208},{"_id":"source/_posts/images/MySQL-MVCC(4).png","hash":"359c9429f6d529549d18f5502d87710276e4349c","modified":1630940146787},{"_id":"source/_posts/images/MySQL-MVCC(5).png","hash":"c7f782dcf44d21ee4e262132e6e00f1fb8a84b54","modified":1630940166430},{"_id":"source/_posts/images/MySQL-主从复制原理.png","hash":"74a85942d3f0a82aa9195261ce77c1ab99af61ff","modified":1630940988419},{"_id":"source/_posts/images/MySQL-主从复制方案.png","hash":"32c1afd1795df20e21f1a59433cdc24ddeeefde3","modified":1630940953087},{"_id":"source/_posts/images/MySQL-连接查询(1).png","hash":"3a989f94d51c96566c51cc348a43efca679f3c6c","modified":1630940369408},{"_id":"source/_posts/images/MySQL-SQL的执行顺序.png","hash":"a2bb9054dab95db53e365c85ee679df86b1a7544","modified":1630940802041},{"_id":"source/_posts/images/MySQL-分库分表id方案.png","hash":"09a92fd76b5f68227a3f76a60531f7b756fb8712","modified":1630940887180},{"_id":"source/_posts/images/MySQL-连接查询(3).png","hash":"0eb3a02952fa7392fa967ee063650cd7365d3def","modified":1630940434686},{"_id":"source/_posts/images/MySQL-连接查询(2).png","hash":"aa9b7191f1f7ecf862ef597745ce25cf70989103","modified":1630940398421},{"_id":"source/_posts/images/MySQL-锁.png","hash":"4131a0fa2dc0c683b7ce83bcd786618d269bf09a","modified":1630940228519},{"_id":"source/_posts/images/RabbitMQ - Topics通配符模式.png","hash":"cb480452456a04777c3d0d5355f4808be88c53ac","modified":1624110320224},{"_id":"source/_posts/images/RabbitMQ - 交换机备份方案.png","hash":"15048164aac59651d03ce611f6be9ccd2e594648","modified":1624693853529},{"_id":"source/_posts/images/RabbitMQ - Exchange交换机.png","hash":"317a99169ea7856dc0e5164cab043dbf2d3811b8","modified":1624100000029},{"_id":"source/_posts/images/RabbitMQ - 优化初步实现的延时队列.png","hash":"a64f0792db2a5b6d208eb5020a1e73ed7fd855ae","modified":1624544566125},{"_id":"source/_posts/images/RabbitMQ - 发布确认机制方案-高级篇.png","hash":"f52493699bf6c764f7e52b397db6f64316bd02b9","modified":1624623165716},{"_id":"source/_posts/images/RabbitMQ - Topic Exchange路由键匹配规则.png","hash":"c11bae66b21e4f7dd627b7226f36803c5a094758","modified":1624110939548},{"_id":"source/_posts/images/RabbitMQ - 创建VirtualHosts.png","hash":"8c86765c42a1c93f2ab496e289738870e0b2792b","modified":1624088977800},{"_id":"source/_posts/images/RabbitMQ - 发布确认简单实现逻辑-高级篇.png","hash":"56c01862afc4a77f67a64422ee66a924d1bfcebd","modified":1624630111786},{"_id":"source/_posts/images/RabbitMQ - 发布订阅模式.png","hash":"73cd07ceff17621017decefeefda2ca0abcb6fd8","modified":1624096792407},{"_id":"source/_posts/images/RabbitMQ - 工作队列模式.png","hash":"a3d967cc60e48e9293553255ba79d327db638ed7","modified":1624094556264},{"_id":"source/_posts/images/RabbitMQ - 实现延时队列.png","hash":"72771904df801fce745dac633dc12eafbdae9792","modified":1624543442064},{"_id":"source/_posts/images/RabbitMQ - 延迟交换机插件的应用.png","hash":"36622f805f41b57ac28716c0284ca04fa1a1146e","modified":1624596660975},{"_id":"source/_posts/images/RabbitMQ - 控制台新增优先级队列.png","hash":"b134fe799028a130aef221bdcf9e80bd4831bc16","modified":1624709653121},{"_id":"source/_posts/images/RabbitMQ - 用户管理.png","hash":"68299edb12b7d61ff4c4f7edff9f518db04b5192","modified":1624088362485},{"_id":"source/_posts/images/RabbitMQ - 设置Virtual Hosts权限.png","hash":"7629a6e990de20e514ccead3e7a3fe450a08fd9c","modified":1624089059720},{"_id":"source/_posts/images/RabbitMQ - 路由模式.png","hash":"b3676abacdc64a26f64919763373dc5c86cfee81","modified":1624104864036},{"_id":"source/_posts/images/RabbitMQ - 简易模式.png","hash":"1e066682c8d4223d47d7e213c6dad1d953932646","modified":1624094463104},{"_id":"source/_posts/images/SQL优化 - 不要使用 order by rand().png","hash":"32699aac407cc4ed8b4bf4ca1de81067d25cd249","modified":1624781091123},{"_id":"source/_posts/images/RabbitMQ-设置VirtualHosts权限.png","hash":"fb637f9590c1f982c64f1adddc5200fb740a492f","modified":1624089016707},{"_id":"source/_posts/images/SQL优化 - 优化使用 order by rand().png","hash":"83a61e3d23b72284913a4bff4fedb68b629ec980","modified":1624781381067},{"_id":"source/_posts/images/Socket编程 - API函数定义.png","hash":"89eec1ed22a2663fc3febeb75f8b078ea0e292e7","modified":1623168184721},{"_id":"source/_posts/images/Spring依赖注入流程.png","hash":"a789a078fbc6e2507bc4902e0160ac9d854a7505","modified":1619487063063},{"_id":"source/_posts/images/ThreadPool.png","hash":"0378bbde87978189341f7c19145b48fc5765f95a","modified":1617547787212},{"_id":"source/_posts/images/new一个对象在JVM中发生的事.png","hash":"678d6706f27d5ad2a465b9918c318072b4e9e724","modified":1624965872634},{"_id":"source/_posts/images/strategy_1.png","hash":"502b290ef8e04f369ff859e2d1f3c737daf12129","modified":1612071331097},{"_id":"source/_posts/images/spring-beandefinition部分关系图.png","hash":"f0e951d4c5b9cdb10622d0c9e78cf9945c4c13b0","modified":1618902103204},{"_id":"source/_posts/images/rehash.png","hash":"e9b3210ce69ddd00e40d3ffcdf408c82d0728737","modified":1617289636856},{"_id":"source/_posts/images/Unsafe计算数组索引下标的方式.png","hash":"08a46f8726718ca069722e125b6dc9945afcbf5a","modified":1619743340039},{"_id":"source/_posts/images/wrapper_1.png","hash":"2d9a81f93b580b2f4c49b5c6297d574bed357aef","modified":1612455550629},{"_id":"source/_posts/images/依赖注入DI - 行李箱示例.png","hash":"44c5a8206a863ac73dee176a9920f87dae7fce97","modified":1618541168424},{"_id":"source/_posts/images/依赖注入DI - 反转降耦.png","hash":"33b5972c0529e0f6b31ae90da8ecc046bd35b560","modified":1618542096625},{"_id":"source/_posts/images/保证缓存一致性 - 延时双删方案.jpg","hash":"4922cd99ecd46f70202066d16ac6da3ef9919e80","modified":1624964514513},{"_id":"source/_posts/images/分布式事务-2PC方案.png","hash":"b29d1182259a68a249d93ea41ed2356a452a2685","modified":1622181860038},{"_id":"source/_posts/images/保证缓存一致性 - binlog方案.jpg","hash":"0bb1ef0c6dc4520e47502a3c958e490a20b76910","modified":1624964374401},{"_id":"source/_posts/images/保证缓存一致性 - 主动加载方案.jpg","hash":"6a37ca0d16cd566adc8e50e910af6504a4048d2f","modified":1624964640012},{"_id":"source/_posts/images/工厂模式 - 抽象工厂结构.png","hash":"ac5337091ff01bd3f850f8e97ce6efc9f090f2ee","modified":1618387643505},{"_id":"source/_posts/images/工厂模式 - 方法工厂结构.png","hash":"82c0498dfc4536cc3be744656b8bf8bc5b68f139","modified":1618386897665},{"_id":"source/_posts/images/工厂模式 - 简单工厂结构.png","hash":"a68e50b68d0211a897f9340ce0bc8ab6c443c54f","modified":1618385506784},{"_id":"source/_posts/images/计算机层面的编程语言执行概览.png","hash":"099b9d47d260ca4988b160f027ac72df428ba1c6","modified":1629610969167},{"_id":"source/_posts/images/门面模式.png","hash":"c22fc8c8010c006be2f1b48d9f4963b8a212bfd9","modified":1618366974470},{"_id":"source/_posts/images/CPU运行时指令重排.png","hash":"9c41b372394ba05998577d6521c1cdd7b61c6500","modified":1617674029808},{"_id":"source/_posts/images/ClassLoader的职能.png","hash":"8237f15d9d7da8cd827f476a77a4f2eb58b64e17","modified":1618714708238},{"_id":"source/_posts/images/CopyOnWriteArrayList - 原理.png","hash":"1fed83017f6fede76d99ced89e3b74491ac2ff70","modified":1622421801898},{"_id":"source/_posts/images/HTTP协议 - 响应数据包解析.png","hash":"3ac670959ad9f4073119036d9c1b3b73cc4810c5","modified":1623333819723},{"_id":"source/_posts/images/JDK1.7-ConcurrentHashMap 扩容（一）.png","hash":"35bf2e8d67550089d5ba623e1c9b20cb0900bf3d","modified":1619749369337},{"_id":"source/_posts/images/JVM - C2编译器优化的过程.png","hash":"eaf1779a50afaa90a77058b7f6ff1187debc1781","modified":1640102421689},{"_id":"source/_posts/images/JVM - 特殊的GC过程.png","hash":"67feb98282741a7b6fa18eab3de2781655b8805f","modified":1634569228884},{"_id":"source/_posts/images/JVM - 编译器的常见编译路径.png","hash":"cafca025ded5d0246b35f3c436a9515231dc2061","modified":1640102606387},{"_id":"source/_posts/images/JVM-slot的复用.png","hash":"fac94697967fafe5e399475ec73ba67917e3be87","modified":1631433172035},{"_id":"source/_posts/images/JVM-非静态方法的第一个slot为this.png","hash":"71dff36d6ed180bd310553608817c120d4d2ecdb","modified":1631431421462},{"_id":"source/_posts/images/JVM-静态方法不存在this.png","hash":"e6d25025cb0d226d5d647816d4c39283b4ba71cd","modified":1631431243918},{"_id":"source/_posts/images/JVM堆内存区.png","hash":"f3b9964c8dc0b9ac552afabca42674d483beb6ea","modified":1618119332528},{"_id":"source/_posts/images/JVM方法区.png","hash":"2310d8ef43786d1d768254f983a8c2d017aeda92","modified":1618119246858},{"_id":"source/_posts/images/JVM本地方法栈.png","hash":"6dfc98afc74ec82c7f735bd6f046023ba9b74ff7","modified":1618120220750},{"_id":"source/_posts/images/JVM程序计数器.png","hash":"c7130a2fb40458bc4f30d75eabda9493d49ef4a7","modified":1618120094181},{"_id":"source/_posts/images/JVM类不会重复加载.png","hash":"b675f3fff2208baf99bace0f12320748ccb67c0a","modified":1627224080888},{"_id":"source/_posts/images/JVM虚拟机栈区.png","hash":"3018682773e3e1e5c397c2008196b27951b5ce69","modified":1618119880778},{"_id":"source/_posts/images/JVM结构.png","hash":"e0debcbc9f23777647f30d51a909d515a1aa50fc","modified":1618119182418},{"_id":"source/_posts/images/JVM运行流程详情.png","hash":"6460d99a27de3243fa3515920969fb98cb85d842","modified":1629623182539},{"_id":"source/_posts/images/Java中基本的数据类型初始值.png","hash":"1c450c2ad35e3e2a925abf63352b6761bd135135","modified":1629627357179},{"_id":"source/_posts/images/Java程序编译原理（1）.png","hash":"0786bedf30e33f694ca26da80b816870ce938b7b","modified":1618121562942},{"_id":"source/_posts/images/RabbitMQ - 六种模式.png","hash":"1046db85e20803398b7caf5fb8215d17ab5f0d75","modified":1624085206664},{"_id":"source/_posts/images/RabbitMQ - 四大核心关系.png","hash":"c237dae7338f5d7daf117998c0de0476d860332a","modified":1624089842492},{"_id":"source/_posts/images/RabbitMQ - 四大核心示例.png","hash":"cf05ddd49ba7dac0755ee0647bb00740d6a37ac0","modified":1624089753524},{"_id":"source/_posts/images/RabbitMQ - 延时消息交换机插件.png","hash":"f3f30bb903a170148b62c92726d8bfad36368588","modified":1624596013318},{"_id":"source/_posts/images/RabbitMQ - 工作原理示意图.png","hash":"4c7342ccfc059dc1b57a3b68f396e29293ab94c3","modified":1624090364281},{"_id":"source/_posts/images/RabbitMQ - 消息转为死信流程.png","hash":"b3b535658e2d072633d1cefa00e79ee1cc5e27d3","modified":1624288304273},{"_id":"source/_posts/images/RabbitMQ - 消息自动重新入队机制.png","hash":"d225c53a7d44e8f9e463b0de963e3f260b288532","modified":1624115088035},{"_id":"source/_posts/images/RabbitMQ - 预取值.png","hash":"2fb716a98187f7008bfcef0d89f5d278439ae4fb","modified":1624178469153},{"_id":"source/_posts/images/Socket编程.png","hash":"826d8f693eb6e0548a997068e25418073cc719c4","modified":1623168124244},{"_id":"source/_posts/images/Spring BeanDefinitionReader类关系图.png","hash":"20b8993500110b276c266af2b7c90951101240bf","modified":1619492758048},{"_id":"source/_posts/images/Spring源码 - 依赖注入学习大纲.png","hash":"82c12df23736aa43b5929a661d67923c26825dd9","modified":1624788778791},{"_id":"source/_posts/images/UDP和TCP比较.png","hash":"bd04666bcc0d1053b5cfba83d9faef704ea933cb","modified":1623167843238},{"_id":"source/_posts/images/将栈顶值保存到局部变量中指令.png","hash":"6df8722d808db9d71de90bdf03fed588ca510f9e","modified":1618154234041},{"_id":"source/_posts/images/局部变量值转载到栈中指令.png","hash":"db021710093b68c890a7cfa97f1ee8b6f9a6b3b5","modified":1618154191306},{"_id":"source/_posts/images/常量入栈指令.png","hash":"b37ce57e0a20f2aecdbf23a3d8ce6a8f096d3edf","modified":1618154112013},{"_id":"source/_posts/images/执行引擎结构.png","hash":"e46cd337f90ffc32ee70049b88080586c0801e6a","modified":1629621645440},{"_id":"source/_posts/images/程序运行原理分析（三）.png","hash":"3682718b8428a87a79504b342861058ebe5eff6d","modified":1618155746621},{"_id":"source/_posts/images/指令重排序中的等效替换.png","hash":"cf05c6cb911b6e657fcbf20bd325e306d0f8d498","modified":1618215269994},{"_id":"source/_posts/images/程序运行原理分析（九）.png","hash":"28fe834812b6df1846c1ec92c4d3e5d9168e0518","modified":1618157024239},{"_id":"source/_posts/images/程序运行原理分析（五）.png","hash":"7f73b292a61f960621445521303d4593b79a08a6","modified":1618156315231},{"_id":"source/_posts/images/程序运行原理分析（十一）.png","hash":"8b643c7f9148ca64c23635261ccd1a67afb83875","modified":1618157243416},{"_id":"source/_posts/images/程序运行原理分析（十）.png","hash":"81f66b4959bfa108dca6ad69731572870e133a7a","modified":1618157163441},{"_id":"source/_posts/images/程序运行原理分析（十三）.png","hash":"1e57f2cde00b1ded089d47f3d4048b8f766fcdb5","modified":1618157506075},{"_id":"source/_posts/images/程序运行原理分析（六）.png","hash":"4be3d199236047b04c9c40eda60f63c1b3e302b1","modified":1618156468366},{"_id":"source/_posts/images/程序运行原理分析（四）.png","hash":"4b50f2e613245420cda0882be3f0ba7c86530d79","modified":1618156136059},{"_id":"source/_posts/images/线程的六种状态描述.png","hash":"add2a1304ed2d73cb38e17325b4120b288468dc6","modified":1618122549631},{"_id":"source/_posts/images/线程的六种状态.png","hash":"192d5903a972f26e58675f924afc35ad7edc40c9","modified":1618122515545},{"_id":"source/_posts/images/AQS-资源占用流程.png","hash":"7e7859f6e135e47b22194aa17e3dc83bd84f2f79","modified":1620969251794},{"_id":"source/_posts/images/ClassLoader-getResources方法可获取的信息.png","hash":"a3a97699a0f4668f0819968d6f7e2c02d8f5724a","modified":1618716020030},{"_id":"source/_posts/images/ForkJoin.png","hash":"d2e0b54687a8ec722e42fdaa0d9ec87d0855df23","modified":1617603389789},{"_id":"source/_posts/images/HTTP协议 - 响应状态码.png","hash":"5b466755b4400e3a9b0de8b5d7aa6f3dfbfea041","modified":1623333881066},{"_id":"source/_posts/images/JSP的运行原理.png","hash":"c51bf10dbc36e66417755e6c256cfa5f4fefb6d8","modified":1618328965817},{"_id":"source/_posts/images/JVM - Javac编译过程.png","hash":"86ea0f997a28af079b6fbf9e303f7744fa0344e1","modified":1640098874905},{"_id":"source/_posts/images/JVM - 年轻代与老年代.png","hash":"037b3a9b0a72986f833d9e74d823ba11cd73d211","modified":1633704073688},{"_id":"source/_posts/images/JVM-PC寄存器.png","hash":"7d6d3b776a54b292b75ea314e0b1fbfbd339e6c1","modified":1631028636364},{"_id":"source/_posts/images/Lock-ReentrantLock-Condition原理.png","hash":"f5f26fe48c680d278be4a9f1d6cc9de2372b4d63","modified":1619687619234},{"_id":"source/_posts/images/Java代码的执行流程.png","hash":"05d25bad3cc783eaf8ecd71e5362771145c6483d","modified":1629614600780},{"_id":"source/_posts/images/NIO - Buffer工作原理.png","hash":"44881f9efe7c5970560848e81eaf521849d19e6e","modified":1623335177653},{"_id":"source/_posts/images/OSI七层模型.png","hash":"180bca3d2028544eb6489ac53574c2dae3dd186b","modified":1623164177298},{"_id":"source/_posts/images/RabbitMQ - 延时队列应用示例.png","hash":"a88da89ca575f3350e1aa58ac8bb3b481cf9b33f","modified":1624340236554},{"_id":"source/_posts/images/RabbitMQ - 工作队列模式的消息分发.png","hash":"3b900979e094deccde161f60f2a624d31c0d3ed5","modified":1624095554935},{"_id":"source/_posts/images/RabbitMQ - 消息的不公平分发.png","hash":"a2cfb71ccfa8fc411ebaea141846119983cdeb18","modified":1624177822605},{"_id":"source/_posts/images/Spring ResourceLoader类关系图.png","hash":"c84ab2fc4bbd964b12bb657b42c9f0c3b55e24c8","modified":1619489552756},{"_id":"source/_posts/images/Spring-BeanFactory子类关系图.png","hash":"6f6973c4dec570b049696a3e6047c3221f709162","modified":1618922055755},{"_id":"source/_posts/images/Spring5源码学习步骤.png","hash":"5d1b367a7ac869b57031970f7b382518b1985341","modified":1618238724626},{"_id":"source/_posts/images/Spring架构.png","hash":"24b947909d90ef3ace48a045694c9894c4a0385f","modified":1618238845157},{"_id":"source/_posts/images/Spring中InputStreamSource类关系图.png","hash":"7abea6e87a0c62479c220cc70af8d36921cdeff5","modified":1619487955659},{"_id":"source/_posts/images/SpringFramework.png","hash":"e03f83ba551803aeceeabfec1add61f2773c353b","modified":1612705804298},{"_id":"source/_posts/images/TCP协议.png","hash":"eb632600d5edec70be19a81c17211b32eec2526e","modified":1623164353346},{"_id":"source/_posts/images/二进制的与或非、异或运算.png","hash":"5da33e93a79dff87f9042faf04c180d19246f69b","modified":1613652033259},{"_id":"source/_posts/images/字节码文件访问标志.png","hash":"4f483a1008cfe9a993591ab4f1a11e896727a292","modified":1618153209549},{"_id":"source/_posts/images/对象之间复杂的依赖关系.jpg","hash":"a0cc44faa5bada844860ab656842915d8842ee19","modified":1618540600608},{"_id":"source/_posts/images/指令重排序引起的线程可见性问题.png","hash":"028e6a5eb11bab322bc9ea0585979e6ac7ad3226","modified":1618215088495},{"_id":"source/_posts/images/程序运行原理分析（七）.png","hash":"e668ae30f32368d680edb3e8fd34b3397e58756c","modified":1618156645712},{"_id":"source/_posts/images/程序运行原理分析（八）.png","hash":"1b59d594a61998d95a691f680eafd1118a154dd7","modified":1618156910560},{"_id":"source/_posts/images/程序运行原理分析（十二）.png","hash":"b7a20301cbadfb6966e745697b39f70aba3a3f3d","modified":1618157453186},{"_id":"source/_posts/images/自定义注解.png","hash":"82aa5a41ed4e1fa1d290555f7a5c01122dbbb6a5","modified":1618536961320},{"_id":"source/_posts/images/重量级锁监视器(monitor)原理.png","hash":"8ce275486475b28587f8bf1f92732b15364298f7","modified":1619662768498},{"_id":"source/_posts/images/门面模式-通俗.png","hash":"10e36e297329cea610712fc86b9550fc7468e919","modified":1618367128195},{"_id":"source/_posts/images/AQS-接口.png","hash":"045942daf5e0e0a332e6dd04b36decaedc15c27d","modified":1620914628881},{"_id":"source/_posts/images/HTTP协议 - 请求数据包解析.png","hash":"397458388b1fb1a2d9d1e6c79eb93f7d9f7f8bdf","modified":1623333737648},{"_id":"source/_posts/images/IOC解耦过程.jpg","hash":"771bcaf6b4e96e69272ebaf9674ce212d2a30652","modified":1618540915983},{"_id":"source/_posts/images/JVM - TLAB.png","hash":"aa50f49d2ed00eb1322c336c0308853050e44d1e","modified":1635867183973},{"_id":"source/_posts/images/JVM架构模型.png","hash":"8c208a09ca14ac03c53f6ac427f9dcebc33f3be2","modified":1629612951596},{"_id":"source/_posts/images/NIO-Selector选择器.png","hash":"e6a4a0a0538ce25bfac6d72862b47dae968d2c8b","modified":1623939311856},{"_id":"source/_posts/images/Servlet生命周期.png","hash":"4147c089f88ba94f0b666784152f4a82cb217e67","modified":1618371168023},{"_id":"source/_posts/images/分布式事务-TCC方案.png","hash":"55e8ebcf98afe4b2462cf75bedf4eb0e6daca0c9","modified":1622185997370},{"_id":"source/_posts/images/双亲委派机制工作原理.png","hash":"d7858cc960e570b3fa90b24c7073a4f348e77e3f","modified":1630338337860},{"_id":"source/_posts/images/对象自己管理依赖关系图.jpg","hash":"8b6db0126ddd36527b1da765097ea2c84923eebd","modified":1618540540578},{"_id":"source/_posts/images/工作内存缓存结构.png","hash":"cb5d657feb957d8aa230f766c895bb20b1b04212","modified":1618214726208},{"_id":"source/_posts/images/JClassLib-查看字节码文件.png","hash":"8764d5d46285a8e083a7ebcb8161291c7d2551e4","modified":1631426777423},{"_id":"source/_posts/images/NIO - ByteBuffer内存类型.png","hash":"507e4ea984f946f6b023a6cea20c09ed50741f71","modified":1626003410163},{"_id":"source/_posts/images/SpringAOP.png","hash":"5bd6fa40ae8d0e4c5c2d5c1d2af1795f392b91c5","modified":1618242379515},{"_id":"source/_posts/images/TCP握手机制.png","hash":"657be2b9d45a7de7af921a92dbf11e52462883ca","modified":1623166168682},{"_id":"source/_posts/images/程序运行原理分析（一）.png","hash":"3631371549117596e89f7ef4b89074f95587c629","modified":1618154716376},{"_id":"source/_posts/images/程序运行原理分析（二）.png","hash":"571a7366a3323ea6365dd460ade8ee0f00194529","modified":1618155373154},{"_id":"source/_posts/images/HashMap流程图.png","hash":"f3829bc228c7eb0954efe5caebb44c61d4c2c967","modified":1619331652204},{"_id":"source/_posts/images/JVM - 类生命周期.png","hash":"1ab2e86e7b23c1cd04ffdd2c4a5b95bab2c9649a","modified":1626706643424},{"_id":"source/_posts/images/JVM-从偏向锁到重量级锁的过程.png","hash":"e05652634268e44e8191b4ab79067028be4ed502","modified":1619662583602},{"_id":"source/_posts/images/JVM类加载器.png","hash":"2824de9a6498c71cfa0e6ea070e57be44168931d","modified":1627222077699},{"_id":"source/_posts/images/NIO - ServerSocketChannel.png","hash":"b82745ecd777df0896f41a431cca3c72f61ea0e5","modified":1623846682808},{"_id":"source/_posts/images/NIO - SocketChannel概念.png","hash":"7a6d55f20e4cd89a9df9a6b52deec23a8524698f","modified":1623581344466},{"_id":"source/_posts/images/Spring - BeanFactory关系图.png","hash":"ef607ba684c400fcd3b3a9c430b3771e683e1a73","modified":1618921290148},{"_id":"source/_posts/images/NIO-Selector选择器的原理.png","hash":"975306d7da5250b4193dda99071ecbffaacff0f6","modified":1623939383209},{"_id":"source/_posts/images/NIO - Channel通道概念.png","hash":"5dfbfdfe3b45601f14d3459547b860b0768917ce","modified":1623580820779},{"_id":"source/_posts/images/UDP协议.png","hash":"2792f12e001d457097617ea13f395b46a8582a2f","modified":1623167453291},{"_id":"source/_posts/images/synchronized关键字的原理.png","hash":"c136f2a999cde3ad3ab8a599a7f8e25f60482f5d","modified":1619153328811},{"_id":"source/_posts/images/Netty - EventLoopGroup初始化过程.png","hash":"aab70784fef1ec6b4ed3d4dbdeb9076c9c2e5f85","modified":1624858700133},{"_id":"source/_posts/images/Netty - 线程模型.png","hash":"fff44d46f15b5b13e5f4d91f8e08e18371a6dcbb","modified":1624858527170},{"_id":"source/_posts/images/Spring中Resource资源支持Ant表达式.png","hash":"7fc706808691911c1cfe71417fdb42623d2a767a","modified":1619488953691},{"_id":"source/_posts/images/字节码内容 - 常量池.png","hash":"df00b363eb03e872a16513d6c56916d6293a60dc","modified":1618153315604},{"_id":"source/_posts/images/Lock - ReetrantLock锁执行原理.png","hash":"1e6e657c8694502f77ac1f47f133054377b7e912","modified":1619675641204},{"_id":"source/_posts/images/Netty - 整体结构图.png","hash":"c143c49ea882dc6296b1deee580908e9fadb4b58","modified":1624858088321},{"_id":"source/_posts/images/JSP运行原理-HTML生成原理.png","hash":"2c16252af6cd6ff8d7bec661d938219d97af18d8","modified":1618329384701},{"_id":"source/_posts/images/JVM-运行时数据区.png","hash":"e87d6501769d02190bb05a924de704a75ae6efe1","modified":1630941519255},{"_id":"source/_posts/images/Java发展的重大事件（一）.png","hash":"aef9d443f086c8d4f2263e2755584aa1d19f37a8","modified":1629612489333},{"_id":"source/_posts/images/BIO-阻塞IO的含义.png","hash":"ccf27e799d1fb3954f8dc007ec61e969efdce1d6","modified":1623330997267},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1645863504096},{"_id":"themes/next/.eslintrc.json","hash":"611e15c3fcb41dc68fa8532ee595a1262a1b5a8a","modified":1645863504096},{"_id":"themes/next/.gitattributes","hash":"aeeca2f1e987d83232d7870d1435a4e3ed66b648","modified":1645863504096},{"_id":"themes/next/.gitignore","hash":"087b7677078303acb2acb47432165950e4d29b43","modified":1645863504111},{"_id":"themes/next/_config.yml","hash":"770b45d0f67db1ae9830f5ab43303d298dd31d95","modified":1646217613199},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1645863504111},{"_id":"themes/next/_vendors.yml","hash":"7b258f85a083815ef05012103cb1c4a9f86c19b0","modified":1645938137283},{"_id":"themes/next/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":1645863504163},{"_id":"themes/next/package.json","hash":"d52c5dacd768ec2d020af3e33665995256209a35","modified":1645948333333},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1645863504111},{"_id":"themes/next/.githooks/install.js","hash":"305c2a269818466eed9e381b866c6cd1ad7f8afd","modified":1645863504096},{"_id":"themes/next/.githooks/pre-commit","hash":"b69b9d0b51e27d5d4c87c3242f5067c2cda26e44","modified":1645863504111},{"_id":"themes/next/README.md","hash":"43fe29330352545446a532e6630866251129882a","modified":1645863504111},{"_id":"themes/next/LICENSE.md","hash":"8cfb03967dd4cbaf3b825271ffce0039aa3fc22a","modified":1645863504111},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"a103e2d875f7434191859e5b42075cfa9a4cbcb3","modified":1645863504111},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"593ae64e72d43c020a697eac65b1f9c3483ff097","modified":1645863504111},{"_id":"themes/next/.github/config.yml","hash":"0956bf71b6f36632b63b14d26580458041a5abd2","modified":1645863504111},{"_id":"themes/next/.github/labeler.yml","hash":"ff76a903609932a867082b8ccced906e9910533a","modified":1645863504111},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"2fdca1040427cabfe27cae6754ec5e027ec7092e","modified":1645863504111},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1645863504111},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"a1aa85a2fc66ff0c52c65bd97b0fa282e297a73f","modified":1645863504111},{"_id":"themes/next/.github/release-drafter.yml","hash":"de38f816e3023e0a5c1fd1f3c2b626f78bc35246","modified":1645863504111},{"_id":"themes/next/docs/AUTHORS.md","hash":"579014d47f45b27fd1618b9709f0efe9585c7449","modified":1645863504111},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1645863504111},{"_id":"themes/next/languages/README.md","hash":"b1c96465b3bc139bf5ba6200974b66581d8ff85a","modified":1645863504111},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1645863504111},{"_id":"themes/next/docs/LICENSE.txt","hash":"d1cd5a8e83d3bbdb50f902d2b487813da95ddfd3","modified":1645863504111},{"_id":"themes/next/languages/ar.yml","hash":"cc7e3e2855348563d746f15c4752b9c63fcdd91a","modified":1645863504111},{"_id":"themes/next/languages/de.yml","hash":"83023c4246b93a2f89f342afe29a7b9e1185f74f","modified":1645863504111},{"_id":"themes/next/languages/bn.yml","hash":"e78a674af44f19415b9bd91e994548a95be174ae","modified":1645863504111},{"_id":"themes/next/languages/en.yml","hash":"731e56475c1409572c50a387c39ed8381243d4fa","modified":1646212692601},{"_id":"themes/next/languages/es.yml","hash":"21676d658d309eb90342a924e106645611c937bc","modified":1645863504111},{"_id":"themes/next/languages/fa.yml","hash":"e09fad889ab3ae87874093e1acd51edc9297d869","modified":1645863504111},{"_id":"themes/next/languages/ko.yml","hash":"d6e2add7488065ec4f7d21cfcf7f0eaa877a84f4","modified":1645863504127},{"_id":"themes/next/languages/fr.yml","hash":"328c255c82e9b561e20a9f51a4d84abc63d1b90a","modified":1645863504127},{"_id":"themes/next/languages/it.yml","hash":"c038ff0cadbe405750d980bcacfd3900acf96905","modified":1645863504127},{"_id":"themes/next/languages/id.yml","hash":"d7c337ca72efb0bd02ade8b5560c559384ad84dd","modified":1645863504127},{"_id":"themes/next/languages/pt-BR.yml","hash":"305025e932832328b7e2a8a584638a23c462e68f","modified":1645863504127},{"_id":"themes/next/languages/ja.yml","hash":"57a35b21aca04ce8bca64fb5933f35626c462ea3","modified":1645863504127},{"_id":"themes/next/languages/nl.yml","hash":"e47858bd1e0d0622c15366ae6c0513d996f589e3","modified":1645863504127},{"_id":"themes/next/languages/pt.yml","hash":"ff93459250c33d3c7ba06c30164cc4208edf9b33","modified":1645863504127},{"_id":"themes/next/languages/ru.yml","hash":"837bb39651769244b19ce458053757d429869764","modified":1645863504127},{"_id":"themes/next/languages/tk.yml","hash":"bf61562ac892231bd28f23a2a5597ee98fb05aa6","modified":1645863504127},{"_id":"themes/next/languages/si.yml","hash":"c15ed758dbad890e856f4fc281208d7b78cc1a59","modified":1645863504127},{"_id":"themes/next/languages/tr.yml","hash":"d3262d2221b0583a52e5d20a3cd1380f5dc49378","modified":1645863504127},{"_id":"themes/next/languages/uk.yml","hash":"f32871f67c63d26bc4e3e15df9b01f5a41236a50","modified":1645863504127},{"_id":"themes/next/languages/vi.yml","hash":"e452ea8c48993262a3e8fce9d92072cafabfc734","modified":1645863504127},{"_id":"themes/next/languages/zh-CN.yml","hash":"f8379d15038e22ef7039d91272cb4f36842dbbe1","modified":1645863504127},{"_id":"themes/next/layout/_layout.njk","hash":"2a7a98005d766ca21cce9c4051204cf47075dfad","modified":1646218167626},{"_id":"themes/next/languages/zh-HK.yml","hash":"c1ee97ceb56da76ecdc7b69fa975f28c8574441b","modified":1645863504127},{"_id":"themes/next/layout/index.njk","hash":"fa52c3049871e879980cb6abccdea3792ca4ce70","modified":1645863504161},{"_id":"themes/next/layout/archive.njk","hash":"1b74bfe176e96c20915bb73f547603e43f52f3ea","modified":1646154207056},{"_id":"themes/next/test/index.js","hash":"983a505399796b9d9e174ba46d89abbdde38f8ee","modified":1645863504223},{"_id":"themes/next/languages/zh-TW.yml","hash":"70c45076ad722b777956048fcc430eac37844c11","modified":1645863504127},{"_id":"themes/next/layout/category.njk","hash":"82f541452cae76a94ee15cb8d8a888f44260a0fd","modified":1645863504161},{"_id":"themes/next/layout/post.njk","hash":"707a50e50b90df5fbeaf8407d12895d04163a290","modified":1645863504162},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"7dec949b13131783e726facb2f4acde0945db1b8","modified":1645863504111},{"_id":"themes/next/layout/page.njk","hash":"98990d6be13e9df75e0e420944d262e8e145d375","modified":1646302197857},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"46d0b29dc561fe571d91fd06a7c8ef606b984c72","modified":1645863504111},{"_id":"themes/next/.github/workflows/lock.yml","hash":"58eca481fd71088a8ae1dbc04645bcfc03460b87","modified":1645863504111},{"_id":"themes/next/.github/workflows/release-drafter.yml","hash":"359b74890a47d784e35a5cc3c7885d5cdf302e82","modified":1645863504111},{"_id":"themes/next/.github/workflows/stale.yml","hash":"32e7dfb55ecf8af66aebfed471be09ef2eb10e18","modified":1645863504111},{"_id":"themes/next/layout/tag.njk","hash":"b6c017d30d08ddd30d66e9c6f3a71aa65d214eac","modified":1646154541314},{"_id":"themes/next/docs/ru/README.md","hash":"e1d6bf38cf34972ca2ee5331a727787fe14082a3","modified":1645863504111},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"daeedc5da2ee74ac31cf71846b766ca6499e9fc6","modified":1645863504111},{"_id":"themes/next/.github/workflows/linter.yml","hash":"b57d876c90d1645a52bbba8a52d47ad0b0c96140","modified":1645863504111},{"_id":"themes/next/.github/workflows/tester.yml","hash":"b53053d82f428605f29274b318d73429a37fb275","modified":1645863504111},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"032194e7975564176f2109aa8b7c020fa6d5e6b1","modified":1645863504111},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4a7885fe2c8b25be02ab57c345cd862aeeeeacaf","modified":1645863504111},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7befb4325b107dd668d9eae3d7e86a34910ce3f2","modified":1645863504111},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"618d07b49f4774cd79613d4001984a19d954a6ad","modified":1645863504111},{"_id":"themes/next/docs/zh-CN/README.md","hash":"354b0b0a24cbe97cccf2ec8bd97eb7d624fa0dea","modified":1645863504111},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"d9d8e6d7a6a8c80009dd5334cc17fd3e4977a008","modified":1645863504127},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a09ceb82b45dd8b7da76c227f3d0bb7eebe7d5d1","modified":1645863504111},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"be779ec6d11bf9ba28f89191ab70728581042f5a","modified":1645936512915},{"_id":"themes/next/layout/_scripts/index.njk","hash":"4eb65641b47ea9b23ed2ddfd69b18f21d7d8f214","modified":1645863504149},{"_id":"themes/next/layout/_macro/post.njk","hash":"60d1a4edf91249e09a0f67bccd9c97332a499a56","modified":1646147930946},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d6b7bb7764e3b471ed6b4e5715f6cbe2dd453f59","modified":1645863504127},{"_id":"themes/next/layout/_partials/footer.njk","hash":"18c609ef34d9440b3525fe47041bdbd849fb9504","modified":1645947880726},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1645863504144},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"0a1470440f11362df2b1cd6b6228e273d9f999d6","modified":1645863504149},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"73bc15a9c3c5c239ab90efa19a1e721f41f3cb93","modified":1645863504157},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"53ad3c31762b74e5d29787b37d5e494cc4fded9b","modified":1645863504155},{"_id":"themes/next/layout/_third-party/index.njk","hash":"33a4a3275474bd3bb2e8d1b0ea01b42dda9ea608","modified":1645863504155},{"_id":"themes/next/scripts/events/index.js","hash":"3bc03b801ce874fa7cbdacd31a7ff25a603a8ac4","modified":1646206858193},{"_id":"themes/next/layout/_partials/languages.njk","hash":"537026fc120adeef9148c98ebf074207e3810538","modified":1645863504141},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"13b2a77b4858a127f458ea092b6f713b052befac","modified":1645863504157},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"d0444179fec512760ab1d4f76928d795b971c884","modified":1645863504157},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"54a89accfdbfa2e6df912994c496815ed802cc6e","modified":1645891986526},{"_id":"themes/next/scripts/filters/locals.js","hash":"87f3bff03fa9fd96cf0787a6442464a7ff57f76b","modified":1645863504169},{"_id":"themes/next/scripts/filters/minify.js","hash":"056f9c9f8c6e34b084b4ac69901c9858a072d9ab","modified":1645863504169},{"_id":"themes/next/scripts/helpers/engine.js","hash":"11c40cd31cec00bfca7a45d596e76b425fc397c5","modified":1645863504170},{"_id":"themes/next/scripts/filters/post.js","hash":"5a132b7f9280a40b3d5fb40928c8cbbe071fe6f6","modified":1645863504170},{"_id":"themes/next/scripts/helpers/font.js","hash":"0a6fa582a0890ecaf5f03f758a730936e48aeca1","modified":1645863504171},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"0c9a1fe9906672724dbf274154a37bac1915ca2c","modified":1645863504168},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"e73f43f1bcb46965e317285d6831e129a40ea59b","modified":1645974792211},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"98fc68cf3fcd6253bbb94068ab1d86578a4ef9ea","modified":1645863504171},{"_id":"themes/next/scripts/tags/button.js","hash":"86c71c73a63744efbbbb367612871fede0d69529","modified":1645863504172},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"52acbc74c1ead8a77cd3bbcba4e033053683f7d0","modified":1645863504172},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"8e912c715702addaf0cefe63e580e45b97ae8c3f","modified":1645863504172},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"b4d12e6fe29089be0f43bafc9eea736602cd16bf","modified":1645863504173},{"_id":"themes/next/scripts/tags/label.js","hash":"c18b0e619a779ed40be7f014db92af18f45fbd5c","modified":1645863504174},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"1c609312a71d47f838226346aad5c2e1c35f15dd","modified":1645863504173},{"_id":"themes/next/scripts/tags/index.js","hash":"255dd1090e8319b557eeca43571f0e4f8aab013b","modified":1645863504174},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"b3844e168b51a99d495ca05562ffac47677f5728","modified":1645863504175},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"3f358bb78c5c6fdf45de287f3ead553e3a6a93c2","modified":1645863504174},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e0ed5fe1bc9d2957952a1aacdf3252d6ef3f9743","modified":1645863504175},{"_id":"themes/next/scripts/tags/note.js","hash":"a12fd53e421400836a3722ae69130969558d6ac0","modified":1645863504175},{"_id":"themes/next/scripts/tags/pdf.js","hash":"317ba4611020cc840854386dde098dbbe452777e","modified":1645863504175},{"_id":"themes/next/source/css/_colors.styl","hash":"5ea14958044d7d6fe57c5312774a28b23932f90c","modified":1646023211579},{"_id":"themes/next/scripts/tags/video.js","hash":"f6ad3f52779f0636251238d3cbdc5b6f91cc5aba","modified":1645863504176},{"_id":"themes/next/source/css/_mixins.styl","hash":"77f6b65a85b4be40329ce9cc2f15bda760e24001","modified":1646202434346},{"_id":"themes/next/source/css/main.styl","hash":"38b8a12681a3a04bed02aa1659054912ed6def11","modified":1645863504207},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1645863504207},{"_id":"themes/next/source/css/noscript.styl","hash":"7dc97674c232f6ca71e48b95e3f66472cd8e9c05","modified":1645863504207},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1645863504207},{"_id":"themes/next/source/images/link.svg","hash":"6b87076b7dbd6cd6bd7112d86f193c7cdee7c255","modified":1646155730860},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1645863504207},{"_id":"themes/next/source/images/avatar.png","hash":"950a75e7c1a7f9d510ede71f7d0bdeb1466ca514","modified":1645106268902},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1645863504207},{"_id":"themes/next/source/js/bookmark.js","hash":"1457291a7244b7786ec35b949d97183e4fbd181d","modified":1645863504207},{"_id":"themes/next/source/js/comments.js","hash":"0b4daf0ce610760bd52e95d423f61f3e1c72442a","modified":1645863504207},{"_id":"themes/next/source/js/comments-buttons.js","hash":"81ea6cbcdf0357094753d7523919c1eafa38e79f","modified":1645863504207},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1645863504207},{"_id":"themes/next/source/js/config.js","hash":"211a9ab35205ccfa6b7c74394bade84da0d00af7","modified":1645863504207},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1645279153596},{"_id":"themes/next/source/js/motion.js","hash":"20b979ebe3671cb415e6e7171485d65cc347086e","modified":1645863504207},{"_id":"themes/next/source/js/pjax.js","hash":"85293c253e0f43540572c4e4615c712325a732e2","modified":1645863504207},{"_id":"themes/next/test/helpers/index.js","hash":"2fb58dca3df2fe53116ee2b1232fa26ebe7b2ce5","modified":1645863504223},{"_id":"themes/next/source/js/utils.js","hash":"b6f1d24bc40da927e267916c9552b455cdaa5545","modified":1645891586831},{"_id":"themes/next/source/js/next-boot.js","hash":"b0bdb542a809932182cfbb8772328115142a0b77","modified":1645891634324},{"_id":"themes/next/test/helpers/font.js","hash":"6f5076bd3f2724e47b46ca69028393a9b6275cd1","modified":1645863504223},{"_id":"themes/next/test/helpers/next-url.js","hash":"08e84781f1cd54e5634b86877ad9cefae4a78e95","modified":1645863504223},{"_id":"themes/next/test/tags/caniuse.js","hash":"2852be850d9103c25114253a45e6c62e32517de4","modified":1645863504223},{"_id":"themes/next/test/tags/center-quote.js","hash":"2ac4b5a358681691a17e736de06fce0b640a7023","modified":1645863504223},{"_id":"themes/next/test/tags/button.js","hash":"a50ca44eaec3d91c2958e3157d624cd3e68828c7","modified":1645863504223},{"_id":"themes/next/source/js/schedule.js","hash":"6dade4388aa6579576a35758075134f573985d57","modified":1645863504207},{"_id":"themes/next/test/tags/index.js","hash":"5cad001936a694bf32d59751cc2b68a66199f976","modified":1645863504223},{"_id":"themes/next/test/tags/label.js","hash":"6cad7d84c42511459a89cda3971e8ea5cdee0125","modified":1645863504223},{"_id":"themes/next/test/tags/mermaid.js","hash":"f718a3d0e303d842e2ca5a3b162539a49e45a520","modified":1645863504223},{"_id":"themes/next/test/tags/link-grid.js","hash":"41730266306c02362258384cd73659223928361f","modified":1645863504223},{"_id":"themes/next/test/tags/pdf.js","hash":"2d114596a8a180b2f3cd2a9c6528a328961f12d4","modified":1645863504223},{"_id":"themes/next/test/tags/group-pictures.js","hash":"8f66d3c6f03fb11d85aa2ab05c9b3c9aa2b4e994","modified":1645863504223},{"_id":"themes/next/test/tags/note.js","hash":"161a81ce749e239d2403681372d48ecc1b51d7b9","modified":1645863504223},{"_id":"themes/next/test/validate/index.js","hash":"560862194991c5963da5a411629d8e6c71d20ee2","modified":1645863504223},{"_id":"themes/next/test/tags/video.js","hash":"88db9a3a26cd35525c43c0339fcd1c5965ec9518","modified":1645863504223},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"fd83bbe03833b126c0138c9312ea306a6cf556cd","modified":1645863504127},{"_id":"themes/next/test/tags/tabs.js","hash":"b19d2592347eae5d6a7a97ca7e8cec03e8f25b51","modified":1645863504223},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"1b2ae17f3c394ce310fe2d9ed5f4d07d8cc74ae7","modified":1645888056158},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"8f11cdf5147ffbe1eee2c16aa208faea0207cfe5","modified":1645972348217},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"3ff7e251bf99a275cd5dfda1b3e51f773c5f7b05","modified":1645863504127},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"f066390762faf6684a523e2eb943420023aac2b1","modified":1645863504127},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"bb711592430b03bdf4fcf89d16278a72c68f7ded","modified":1645968297570},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"b352346dd2cb42f7eeaec5e39d9a2a353b029775","modified":1645863504143},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"940cad08a67e6c361214045096bd3cdffdf44fcf","modified":1645863504140},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"e9e788b2e66ca5ffa3ea8dfa2085d03cd5790307","modified":1645954331104},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"9c136edd2248e2d50c1f6110b75e2b75c299bbd7","modified":1645863504142},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"130e776575d634201d4f8ef3d78dc12624f19fde","modified":1645863504144},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"e3502059bcc443ce932946a9891fcbe8b2bb362d","modified":1645863504145},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1646150988115},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"0ebc0142abebbeef4278e32abb543c7d7fa75d88","modified":1645863504145},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"93fbb449fbd599cb4315d7eb0daeb239811b233f","modified":1645863504147},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"ebf83083856f8bd81ad47ffb985d44e338b4e6bb","modified":1645863504145},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"17e03b61e20a5cb4195f0e0d75261ce61a1cddc4","modified":1645863504146},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"9766852e72c1809d8c1eea71ac6116b4cc0886d2","modified":1645863504147},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"0d0e2c9f066cb210f8b6c428b658c36a43400e6b","modified":1646151107648},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"3e80332f88b101141be69f2a07f54ed8c053eabb","modified":1645863504150},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"c7cea42f6db2137c11ca1d83e43fcb7ad7ccfb89","modified":1645863504150},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"fe9ab235884a8033f2d536184f12c2fa65f16c46","modified":1646213337964},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"52ad137450f7b3d6a330e16b3ed1c6174290f0eb","modified":1645863504151},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"9ff9ec05c2037beea229a6bb698f9e3546973220","modified":1645863504151},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"eef710e9be20e7fed7573d0824feaa4eb1cf2737","modified":1645863504151},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"50c42adf5ba59ff227e9bce6dc4085694e5fe3c2","modified":1645863504151},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"09d2c9487d75894d45a823e3237ae9f90fd6ee01","modified":1645863504152},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"3fbc72427c1211e5dcfd269af1a74852a7ba5c1a","modified":1645863504152},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"d5c79ccb72bd4fd67b0d6c52eae7108c3f27bacd","modified":1646214533274},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"375a86f0b19e130cfa7707007e3a53d9ae7c9b64","modified":1645863504152},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"5f7967bd946060f4102263a552ddfbae9975e7ea","modified":1645863504153},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"2b016e9b9dcf5f4b9851fccd9a43b7f5dbb375fd","modified":1645893761267},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"c5086b4c35f730f82c99c4a8317f2f153ebde869","modified":1645863504154},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"b0828dd1b1fd66ecd612d9e886a08e7579e9a4f7","modified":1645863504153},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"a7921be7328e1509d33b435175f5333a9aada66f","modified":1645863504155},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"b8e0d5de584cece5e05b03db5b86145aa1e422b4","modified":1645863504154},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"6fd4df5c21cfe530dbb0c012bc0b202f2c362b9c","modified":1645863504154},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"38badcc7624a13961381c2465478056b9602aee5","modified":1645863504154},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"a62aa1ed4e35b8d0451d83f341bf0a97538bc9a4","modified":1645863504156},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"67f67a77f27103177b9940446f43610229536d82","modified":1645863504158},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"a84db8bc8804335f95609a221ac1746433dcdc89","modified":1645863504156},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"210c32b654adae3d8076c4417d370b42af258cea","modified":1645863504158},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"d97790e4b442a1e3ded7d7b4f84b8ee6cdb6e8ea","modified":1645863504159},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"af5336e8bbdc4638435971da115bb7443d374ade","modified":1645863504159},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"8703d1855bb8d251c9b7c2940b7e3be525e53000","modified":1645863504160},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"866ffa15a3250678eb8a90aa6f609fa965db90fd","modified":1645863504159},{"_id":"themes/next/scripts/events/lib/config.js","hash":"f78cd74b25cc0ef65c060fec1d7e056967e26b4b","modified":1645863504164},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"0386c708975cc5faea4f782611c5d2c6b8ac2850","modified":1645863504160},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"dd8f963acd5a3685be46fd5319c06df0308d99b2","modified":1645863504160},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"1f1ea7b579a49f17574c31d78d663c54896133eb","modified":1645863504164},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"00cec6980cafd417def885f496371856cd524a25","modified":1645863504164},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"17fbc99521440a5d6c32ac991ba2038a12f86b31","modified":1645863504166},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1645863504166},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"09cba2c433fe47981d07d67c038790f4fc2ec16b","modified":1645948932820},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"7bdf8588563cd13a1eb7a2c5bcffd831855b59a0","modified":1645863504165},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"70eb507ef7f1a4fc3ca71a3814cc57afe7f3f60c","modified":1645863504167},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"1cb58aa6b88f7461c3c3f9605273686adcc30979","modified":1645863504166},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"c22cbccd7d514947e084eeac6a3af1aa41ec857a","modified":1645863504167},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"96e58efba0dc76af409cc7d2db225f0fe4526ea8","modified":1645863504167},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"1856c4b035c5b8e64300a11af0461b519dfc4cf4","modified":1645863504156},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"a50718c081685fd35ff8ea9ca13682c284399ed8","modified":1645863504168},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3283bdd6e5ac7d10376df8ddd5faaec5dc1bd667","modified":1645863504167},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"bb8ebb541c40362c0cbbd8e83d3b777302bb6c40","modified":1645863504168},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"ab7d6cced9dfa0a5141f0d0ece5afd675214a143","modified":1645947293096},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"0fa7516da1175628216621c1ac3b8eeff7e7a210","modified":1645952357075},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"c4537fa2de33d98baff2c87a73801770414e0b69","modified":1645863504192},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ebee77b2307bf4b260afb06c060171ef42b7141","modified":1645863504207},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"58014a2d087c4126058a99b5b1cb7d8a2eb6224d","modified":1645863504207},{"_id":"themes/next/source/js/schemes/muse.js","hash":"b05dd5cc085684f9808e1d9d9e297b72af74e306","modified":1645938721740},{"_id":"themes/next/source/js/third-party/rating.js","hash":"a1f44247c18ac00ee3e0026560398429e4c77dd7","modified":1645863504207},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"5b0197e061f57e00875be3636ba372a67693abe0","modified":1645863504207},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"8a847a7bbdbc0086dd1de12b82107a854b43f5e5","modified":1645863504207},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"991c1f80995cec418dc00d3d6b13e2d911ac9894","modified":1645863504178},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ce20cdf434e9ea7a442b03d0ef3dfe5b11529b69","modified":1646154741538},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"e148c10b0ca5d5c727942f135b2f28443b183c3e","modified":1646202538733},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1646151839333},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"7782dfae7a0f8cd61b936fa8ac980440a7bbd3bb","modified":1645863504189},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"f3defd56be33dba4866a695396d96c767ce63182","modified":1645863504183},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"cbd263b341b986f202d965d85fce51f140d2e5c4","modified":1645939719220},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"f768ecb2fe3e9384777c1c115cd7409e9155edd7","modified":1645863504192},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"2db4462e9cb87b8aef3f50f850fed407de16da3e","modified":1645863504190},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b9388016f8d9274703e77e306a1feaad1b7b9d6c","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"cf8446f4378dcab27b55ede1635c608ae6b8a5c8","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"90f7d3baab061e860172b536c9edc38c7fd2ef5c","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"607117c6ccb89567821ecdc85deaaa4ea54413c7","modified":1645969357472},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"fd89988442f380cba907752fe3f608e3498f8c93","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"60184a58f4df34c4460f939e1bb46aa2b893cb63","modified":1646156097928},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"9d482e253e54edeeac23e34dba745040ccef7683","modified":1646152116877},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"89bf3f6b82cb0fafbbd483431df8f450857c5a0b","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"459375cf22bcd20478089a967ffecb2d7a6d7a80","modified":1646149961731},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"9b2cba0c9aa5a64957294f7548c199db1f63f0f4","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"898508239b1373bbf15dd582be0c5d6e0e0373c4","modified":1646151954920},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6bb9fe1ab5e07ed86c7f8dcce0aae4f25e24a251","modified":1646156097918},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"28030c61288cc0e1321b18373a5c79029fd76a53","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"b11a4d209af2b9aca58219535acd6dafdefa1426","modified":1646153311130},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"9f60d501808f67d151af437221d0dfacc27c180c","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86c5868450d6fadff4a59511738ead05e9551941","modified":1646149029068},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5c3dd08c520a16ee49f85fa12b4935e725ef261","modified":1645863504192},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"72e0766752b78a723fb30e92d533a8b353104e2d","modified":1645863504207},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f9579a02599de063ccff336177ba964a2931a6e9","modified":1645863504207},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"f755e8537ccbbb0bd84c26923f320d4e206e7428","modified":1645863504207},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"3764f8ed9b311f2d32bda979891a6bfc674954eb","modified":1646156097932},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"14b024c920a8b359777d79dd8e1a849387f8f3ad","modified":1645863504207},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"08f23c34c19da2358a89a0ecb3230923cf4e60f4","modified":1645946275821},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"77c231bcd64f1c09bd9989909e9fee703b65f47f","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"1c282d6c2151346d1f0aa95055d17abe77054ec9","modified":1645863504207},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"d77d4934d959e7125128754b568f1d041c3fbfff","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"b9b9fd2f0e098a123b34a4932da912a9485ffe6c","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"b4cb06fdf531292e2361398a98d75a4ca2b8473a","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"5460de247c038d6cfbe774d7f8747f0a958d9017","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"68892d74ef5fc308c6e7e6b4f190826d79f3055d","modified":1645863504207},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"5c63ec71458b4fe0cd98fd4a04e11c3746764f11","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"ec44d7f1c8b51b0aa3cccba099a78f3575ac828c","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"1e8509356fb027d948d118ab220d9631f4d482fa","modified":1645863504207},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"d93556184b2c0aa1dbc4a6fb892d2f77b80d7d9f","modified":1645863504207},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"ea94731438d8c518d946601f8f46a65b92381fac","modified":1645863504207},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"d0829fe41d2fe86b8499e2a896556c1275ea0066","modified":1645863504223},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"dc2b0e89aa32afc7f7a7e2d7a277dadb7f96e06d","modified":1645893724123},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"e109c2d6828f527f0289d5fa3bb02fce63ee6d93","modified":1645863504223},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"6abdc209f4503d4efd676e18bc30ddea813b6ff9","modified":1645863504223},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"2618135cbcee6bf228f6734767de1995e5eaaac6","modified":1645863504223},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1477558306000},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"4626bacb6b8cae52bb967d1038cf0199d1251ea6","modified":1645964615580},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"791bc9befb0d4d06e3e517eccfe0bc3551a02a60","modified":1645863504181},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"df2fbd0ada00f37439b0de965c6f1c29d3c97429","modified":1645863504180},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"c34936a17c3d8af6c0988ac6746d7509dc0b50eb","modified":1645863504182},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"c3e47c33ea5fa5df5ac130a0ea0bf14562b0c59a","modified":1646156097924},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"e53a5eb1d1771e284044bdb0bc0ed2de27923669","modified":1645863504182},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"d29b87bb49150725af3d0e470d3508bcec994264","modified":1646216677004},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"0a779f955a0e25df0852e0731517dadb234aa181","modified":1645863504183},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fde10ce94e9ae21a03b60d41d532835b54abdcb1","modified":1645863504179},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"025ec8ecc52a0527b459dcc76eafdb1f040c7db5","modified":1646201159802},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1645863504179},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"80595d274f593b321c0b644a06f3165fe07b16f5","modified":1645863504179},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"2ce7468aa2647f1f68971b19c2b3c1a812660597","modified":1646216390362},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"091b8c763e43447d087c122a86538f290f83136a","modified":1645863504179},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"352571c6469ccc29357343cc18286bbf5200c1d9","modified":1646156062998},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"fb165c1a0d990c5cf98b87773e0dc50410229b96","modified":1645863504184},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"7b36f776c41fbb744572c5de2c8d49b35656ec21","modified":1645863504185},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"0c4c5e39f8ac12febaa0f4ff7265151e139edad8","modified":1645863504185},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"1e5776ad4c5c8bcf7596ac74dcabc30704b3f5a0","modified":1645863504185},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"0527153aa821bdbdb84c7b47f60e3cefd95a742f","modified":1645863504186},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"c8648c8ea3105556be0068d9fb2735261d0d94bc","modified":1645863504187},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"d28856f365a9373c4ae6fe1e5673d63df2dfd65f","modified":1645863504186},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"67fc7a1eb59c8451eec34e572cbb2fd1424757bc","modified":1645863504188},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"c1e9edbfd1c3696b35d5452ae2e6d766f3fe91aa","modified":1645863504184},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"49c26184580fde8a732899a4de5aae8662e289b8","modified":1645863504186},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"05af22f3edc2383a3d97ec4c05e9ac43b014bead","modified":1645863504188},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"d9bc2b520636b9df7f946295cd430593df4118ff","modified":1645863504189},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"86b0925e968f35bbc76b473a861e8f9797f7580e","modified":1645863504189},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"2db695204d39e4c7daa7b91585a0ea4b06b49f11","modified":1645863504188},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2c2bfbc34b6f19d262ae7c041474985e12f4f4ad","modified":1645863504191},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"1c324d56ae83e96db2c4c6d63edd7ee51c936fc1","modified":1645863504191},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"63d8f5f169c2b1c969928fc79244c5fe89ee484e","modified":1645863504192},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"09bed6818f55729c74214528e49b396a951e688a","modified":1645892571916},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"f2f5498a3798d6a66a455f8170bcebc0496ee12d","modified":1645938668236},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"6cec28209076c1feeec89e866da653008394d133","modified":1646064545261},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"6681ffe283f8a7e3c86310ef4f6ca1e499c1a19f","modified":1645863504192},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2de038def2cb91da143b14696366c14a66e0e569","modified":1645863504192},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"2732f3ff32256e3ad80222ae22252075d7b73744","modified":1645975015093},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"8aac130364803c613e916d03a703f93a21d1ae32","modified":1645963282100},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a586566bd12b85a431cdda0fb8bcd003c17c5324","modified":1645966949177},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"a4003e1408844568cb5102a5a111046cb19b2d31","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"8d9218980e185210ce034e9769ab639b9630fd88","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"e22fde6f1657d311d46f64d868c4491d535c8caa","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"531daf2612c6217950677a2d03924459ce57c291","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"c7754dc6c866928b538f0863a05b96ec44b5e986","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"ee05c1d00bc38397bd320128bbe15d05d9100039","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"77122986509a6b4968bae2729417b7016137534c","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"6b3680e0dbea8e14c1cec24ef63b7fae5e37f7ef","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7075dd32dd70da1e161e4bd14b46f1e8be62fa3c","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"2e9dc3b3546e19e9de18050ad04b1741841116bc","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"40a38f2129617ffd4e8d5cd78e982fdfc9941acf","modified":1645863504192},{"_id":"themes/next/source/js/jquery.js","hash":"255057d893d00bf46df9a1471672e5a68d67199d","modified":1626582637617},{"_id":"themes/next/source/js/mo.min.js","hash":"4c69f052549568088af3f84b46830a24e7dfc97d","modified":1626582732969},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1477558304000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1477558304000},{"_id":"themes/next/yarn.lock","hash":"d5de7e059870af5239d49d6cc5837fd9ca56031d","modified":1646012504787},{"_id":"themes/next/source/images/wechatpay.png","hash":"3b8195f975a57bf0f5a482d3d9f664df4eabc440","modified":1646211935308},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1477558304000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1477558304000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1477558304000},{"_id":"themes/next/source/images/alipay.png","hash":"5425e500d40af6ac2fec38a40315918590512c97","modified":1646211887634},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1477558304000},{"_id":"public/search.xml","hash":"76612ea3cd6c0c7cda4630ed98244a4834fcadf6","modified":1646301345322},{"_id":"public/tags/index.html","hash":"860d9ac9aa78ce97468507dcac955c4902d1f106","modified":1646301345322},{"_id":"public/friends/index.html","hash":"15d21fac6caafe3eef504be228111bb4dcc842a3","modified":1646301345322},{"_id":"public/2021/08/22/Java并发 - JUC 单例模式/index.html","hash":"9fc8efd63ade6dba86c709581a6bf80670bdf80f","modified":1646301345322},{"_id":"public/2021/08/22/Java并发 - JMM 内存模型/index.html","hash":"24a5683bfc811dafbef6fdd570617ad74b8dbef9","modified":1646301345322},{"_id":"public/2021/08/22/Java并发 - ForkJoin/index.html","hash":"a912666d33319f811d43730c01171a80e9ee75c1","modified":1646301345322},{"_id":"public/2021/06/07/Java并发 - synchronized/index.html","hash":"ca0cfc401685551f8152b7bb3eceefd0022ee9f6","modified":1646301345322},{"_id":"public/2021/06/03/Java并发 - Queue/index.html","hash":"4e11d0dc99f8695b2fb730ca6f2523653dfc330f","modified":1646301345322},{"_id":"public/2021/06/01/Java并发 - AQS抽象队列同步器/index.html","hash":"1d23035fe117ec0666e5509be27bdb7a21e9daa9","modified":1646301345322},{"_id":"public/2021/05/14/Java并发 - Semaphore信号量/index.html","hash":"4d34ca81856ec96b96758c112345d82cf479de0f","modified":1646301345322},{"_id":"public/2021/04/29/Java并发 - ReetrantLock、读写锁/index.html","hash":"3138b75dfa7fcbb1b45090c5e1659fd6d5921a63","modified":1646301345322},{"_id":"public/2021/04/12/Java并发 - interrupt+isInterrupted/index.html","hash":"233aa4eb710ac4c0454713ebb1caa993839581fd","modified":1646301345322},{"_id":"public/2021/04/10/Java并发 - Callable/index.html","hash":"52ac1416faf90e07cf242c9c75c8a512fcc7f203","modified":1646301345322},{"_id":"public/2019/05/31/Java并发 - ArrayList/index.html","hash":"a3b51305b0b1500c89e7c7219b0e05f017bd9323","modified":1646301345322},{"_id":"public/archives/index.html","hash":"d212d95240fc76267865e176df6015fbca77e480","modified":1646301345322},{"_id":"public/archives/page/2/index.html","hash":"5b63693b92cac04ed61fb3e2015697b66972beee","modified":1646301345322},{"_id":"public/archives/2019/index.html","hash":"77fe878cdbc84b6f6cda759932bbf30034bf914a","modified":1646301345322},{"_id":"public/archives/2019/05/index.html","hash":"b8de5821f2eb5a8d7bfb5d7bf4ac3cd813fe1c1e","modified":1646301345322},{"_id":"public/archives/2021/index.html","hash":"7c87a5b99dc982b777696a3b066b3bcf13e4a8ed","modified":1646301345322},{"_id":"public/archives/2021/04/index.html","hash":"407ee7686cdcacf6b99cfef37b427cb5a5178654","modified":1646301345322},{"_id":"public/archives/2021/05/index.html","hash":"0a44972c0e277389a342ddbaae82b8a341648c73","modified":1646301345322},{"_id":"public/archives/2021/06/index.html","hash":"378d283e08aff960f7541aa05c3baf7e8cc19a9f","modified":1646301345322},{"_id":"public/archives/2021/08/index.html","hash":"0b3d6a29a31c127bc2105bdc0c6de8e26b9bb8c9","modified":1646301345322},{"_id":"public/page/2/index.html","hash":"528652a1ad340434475b8c335c0e625a844f6183","modified":1646301345322},{"_id":"public/tags/JUC并发包/index.html","hash":"da9688722cd3b294d6dac57841c03b0179d6d9b6","modified":1646301345322},{"_id":"public/tags/Java/index.html","hash":"f5d0d34c825b5191616269fb16e40b1e10de2106","modified":1646301345322},{"_id":"public/index.html","hash":"3834ca98785e288b3b037a0ab0e2699dc78c938b","modified":1646301345322},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1646301345322},{"_id":"public/images/avatar.png","hash":"950a75e7c1a7f9d510ede71f7d0bdeb1466ca514","modified":1646301345322},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1646301345322},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1646301345322},{"_id":"public/images/link.svg","hash":"6b87076b7dbd6cd6bd7112d86f193c7cdee7c255","modified":1646301345322},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1646301345322},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1646301345322},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1646301345322},{"_id":"public/css/noscript.css","hash":"54d14cd43dc297950a4a8d39ec9644dd5fc3499f","modified":1646301345322},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1646301345322},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1646301345322},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1646301345322},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1646301345322},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1646301345322},{"_id":"public/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1646301345322},{"_id":"public/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1646301345322},{"_id":"public/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1646301345322},{"_id":"public/js/schemes/muse.js","hash":"cbe5d95c2b084dec03d11f8c97f1be1c8a0574d5","modified":1646301345322},{"_id":"public/js/utils.js","hash":"5f025437287ff9d726835614ddc972a70ad41a5a","modified":1646301345322},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1646301345322},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1646301345322},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1646301345322},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1646301345322},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1646301345322},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1646301345322},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1646301345322},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1646301345322},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1646301345322},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1646301345322},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1646301345322},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1646301345322},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1646301345322},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1646301345322},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1646301345322},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1646301345322},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1646301345322},{"_id":"public/css/main.css","hash":"b7f5134ba42f682602a1dfd9e9458e0bc3d68858","modified":1646301345322},{"_id":"public/js/jquery.js","hash":"3cca78feb86ab7549f20306ab25c7ab76c72b21f","modified":1646301345322},{"_id":"public/js/mo.min.js","hash":"fc7ec6c51e67a25019e08d6dd5e71633b27e69ad","modified":1646301345322},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1646301345322},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1646301345322},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1646301345322},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1646301345322},{"_id":"public/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1646301345322},{"_id":"public/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1646301345322},{"_id":"public/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1646301345322},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1646301345322},{"_id":"public/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1646301345322},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1646301345322},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1646301345322},{"_id":"public/images/wechatpay.png","hash":"3b8195f975a57bf0f5a482d3d9f664df4eabc440","modified":1646301345322},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1646301345322},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1646301345322},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1646301345322},{"_id":"public/images/alipay.png","hash":"5425e500d40af6ac2fec38a40315918590512c97","modified":1646301345322},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1646301345322},{"_id":"source/friends/index.html","hash":"16e1da505f877ba6e0cfc843e3b2e4982ad01fe4","modified":1646301440611},{"_id":"themes/next/layout/_partials/page/friends.njk","hash":"fedd35a4beb400001b367acd969f7382d19403ba","modified":1646301973310},{"_id":"themes/next/source/css/_common/components/pages/friends.styl","hash":"04c70e94400d7a7e845976144244e719da7a9865","modified":1646302197846}],"Category":[],"Data":[],"Page":[{"date":"2022-02-24T16:21:14.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ndate: 2022-02-25 00:21:14\ntype: \"tags\"\ncomments: false\n---\n","updated":"2022-02-27T09:20:39.488Z","path":"tags/index.html","title":"","layout":"page","_id":"cl0atbcon00007cu59jdo88tm","content":"","site":{"data":{}},"excerpt":"","more":""},{"date":"2022-03-01T17:32:55.000Z","title":"Friends","comments":0,"_content":"<style rel=\"stylesheet\">\n    .friends-model {\n        position: relative;\n        top: 3px;\n        left: 1px;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        font-size: 17px;\n        font-weight: 500;\n        opacity: .9\n    }\n    \n    .friends-href {\n        display: block;\n        margin: 15px 0;\n        min-height: 220px\n    }\n    \n    .friends-href a {\n        display: inline-block;\n        font-size: 15px;\n        margin-top: 15px;\n        letter-spacing: .4px;\n        position: relative;\n        width: 200px;\n        margin-left: 40px;\n        font-weight: 500;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        border-bottom: none !important\n    }\n    \n    .friends-href a i {\n        margin-right: .4em;\n        color: #6db33f\n    }\n    \n    .friends-href a:before {\n        position: absolute;\n        top: -50%;\n        left: -50%;\n        padding: 1.3em 1em 1em 4em;\n        width: 150%;\n        height: 100%;\n        background: var(--content-bg-color) url(/images/link.svg) no-repeat -3em 50%;\n        background-size: auto 35%;\n        color: #404d5b;\n        color: transparent;\n        content: attr(href);\n        white-space: pre-wrap;\n        word-break: break-all;\n        font-weight: 600;\n        font-size: 50%;\n        line-height: 1.2;\n        opacity: .2;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        font-size: 16px !important;\n        -webkit-transition: opacity .3s, color .3s, -webkit-transform .3s, background-position .2s;\n        -webkit-transition: opacity .3s, color .3s, background-position .2s, -webkit-transform .3s;\n        transition: opacity .3s, color .3s, background-position .2s, -webkit-transform .3s;\n        transition: opacity .3s, color .3s, transform .3s, background-position .2s;\n        transition: opacity .3s, color .3s, transform .3s, background-position .2s, -webkit-transform .3s;\n        -webkit-transform: scale(.5);\n        transform: scale(.5);\n        pointer-events: auto\n    }\n    \n    .friends-href a:focus::before, .friends-href a:hover::before {\n        background-position: 1em 50%;\n        color: #6db33f;\n        opacity: 1;\n        border: 1px solid #f9f9f9;\n        -webkit-box-shadow: 1px 1px 1px #ededed;\n        box-shadow: 1px 1px 1px #ededed;\n        border-radius: 2px;\n        -webkit-transition-delay: 0s, 0s, 0s, .1s;\n        transition-delay: 0s, 0s, 0s, .1s;\n        -webkit-transform: scale(1) translateY(-80%);\n        transform: scale(1) translateY(-80%)\n    }\n</style>\n\n<div class=\"friends-page\">\n    <div class=\"friends-href\">\n        <a href=\"https://www.github.com/mrdjun\" target=\"_blank\" class=\"ignore-href\">\n            <i class=\"fa fa-fw fa-star\"></i>github's href\n        </a>\n    </div>\n</div>","source":"friends/index.md","raw":"---\ndate: 2022-03-02 01:32:55\ntitle: \"Friends\"\ncomments: false\n---\n<style rel=\"stylesheet\">\n    .friends-model {\n        position: relative;\n        top: 3px;\n        left: 1px;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        font-size: 17px;\n        font-weight: 500;\n        opacity: .9\n    }\n    \n    .friends-href {\n        display: block;\n        margin: 15px 0;\n        min-height: 220px\n    }\n    \n    .friends-href a {\n        display: inline-block;\n        font-size: 15px;\n        margin-top: 15px;\n        letter-spacing: .4px;\n        position: relative;\n        width: 200px;\n        margin-left: 40px;\n        font-weight: 500;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        border-bottom: none !important\n    }\n    \n    .friends-href a i {\n        margin-right: .4em;\n        color: #6db33f\n    }\n    \n    .friends-href a:before {\n        position: absolute;\n        top: -50%;\n        left: -50%;\n        padding: 1.3em 1em 1em 4em;\n        width: 150%;\n        height: 100%;\n        background: var(--content-bg-color) url(/images/link.svg) no-repeat -3em 50%;\n        background-size: auto 35%;\n        color: #404d5b;\n        color: transparent;\n        content: attr(href);\n        white-space: pre-wrap;\n        word-break: break-all;\n        font-weight: 600;\n        font-size: 50%;\n        line-height: 1.2;\n        opacity: .2;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        font-size: 16px !important;\n        -webkit-transition: opacity .3s, color .3s, -webkit-transform .3s, background-position .2s;\n        -webkit-transition: opacity .3s, color .3s, background-position .2s, -webkit-transform .3s;\n        transition: opacity .3s, color .3s, background-position .2s, -webkit-transform .3s;\n        transition: opacity .3s, color .3s, transform .3s, background-position .2s;\n        transition: opacity .3s, color .3s, transform .3s, background-position .2s, -webkit-transform .3s;\n        -webkit-transform: scale(.5);\n        transform: scale(.5);\n        pointer-events: auto\n    }\n    \n    .friends-href a:focus::before, .friends-href a:hover::before {\n        background-position: 1em 50%;\n        color: #6db33f;\n        opacity: 1;\n        border: 1px solid #f9f9f9;\n        -webkit-box-shadow: 1px 1px 1px #ededed;\n        box-shadow: 1px 1px 1px #ededed;\n        border-radius: 2px;\n        -webkit-transition-delay: 0s, 0s, 0s, .1s;\n        transition-delay: 0s, 0s, 0s, .1s;\n        -webkit-transform: scale(1) translateY(-80%);\n        transform: scale(1) translateY(-80%)\n    }\n</style>\n\n<div class=\"friends-page\">\n    <div class=\"friends-href\">\n        <a href=\"https://www.github.com/mrdjun\" target=\"_blank\" class=\"ignore-href\">\n            <i class=\"fa fa-fw fa-star\"></i>github's href\n        </a>\n    </div>\n</div>","updated":"2022-03-03T09:57:45.874Z","path":"friends/index.html","layout":"page","_id":"cl0atdx4g0001tgu5gch80ulr","content":"<style rel=\"stylesheet\">\n    .friends-model {\n        position: relative;\n        top: 3px;\n        left: 1px;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        font-size: 17px;\n        font-weight: 500;\n        opacity: .9\n    }\n    \n    .friends-href {\n        display: block;\n        margin: 15px 0;\n        min-height: 220px\n    }\n    \n    .friends-href a {\n        display: inline-block;\n        font-size: 15px;\n        margin-top: 15px;\n        letter-spacing: .4px;\n        position: relative;\n        width: 200px;\n        margin-left: 40px;\n        font-weight: 500;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        border-bottom: none !important\n    }\n    \n    .friends-href a i {\n        margin-right: .4em;\n        color: #6db33f\n    }\n    \n    .friends-href a:before {\n        position: absolute;\n        top: -50%;\n        left: -50%;\n        padding: 1.3em 1em 1em 4em;\n        width: 150%;\n        height: 100%;\n        background: var(--content-bg-color) url(/images/link.svg) no-repeat -3em 50%;\n        background-size: auto 35%;\n        color: #404d5b;\n        color: transparent;\n        content: attr(href);\n        white-space: pre-wrap;\n        word-break: break-all;\n        font-weight: 600;\n        font-size: 50%;\n        line-height: 1.2;\n        opacity: .2;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        font-size: 16px !important;\n        -webkit-transition: opacity .3s, color .3s, -webkit-transform .3s, background-position .2s;\n        -webkit-transition: opacity .3s, color .3s, background-position .2s, -webkit-transform .3s;\n        transition: opacity .3s, color .3s, background-position .2s, -webkit-transform .3s;\n        transition: opacity .3s, color .3s, transform .3s, background-position .2s;\n        transition: opacity .3s, color .3s, transform .3s, background-position .2s, -webkit-transform .3s;\n        -webkit-transform: scale(.5);\n        transform: scale(.5);\n        pointer-events: auto\n    }\n    \n    .friends-href a:focus::before, .friends-href a:hover::before {\n        background-position: 1em 50%;\n        color: #6db33f;\n        opacity: 1;\n        border: 1px solid #f9f9f9;\n        -webkit-box-shadow: 1px 1px 1px #ededed;\n        box-shadow: 1px 1px 1px #ededed;\n        border-radius: 2px;\n        -webkit-transition-delay: 0s, 0s, 0s, .1s;\n        transition-delay: 0s, 0s, 0s, .1s;\n        -webkit-transform: scale(1) translateY(-80%);\n        transform: scale(1) translateY(-80%)\n    }\n</style>\n\n<div class=\"friends-page\">\n    <div class=\"friends-href\">\n        <a href=\"https://www.github.com/mrdjun\" target=\"_blank\" class=\"ignore-href\">\n            <i class=\"fa fa-fw fa-star\"></i>github's href\n        </a>\n    </div>\n</div>","site":{"data":{}},"excerpt":"","more":"<style rel=\"stylesheet\">\n    .friends-model {\n        position: relative;\n        top: 3px;\n        left: 1px;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        font-size: 17px;\n        font-weight: 500;\n        opacity: .9\n    }\n    \n    .friends-href {\n        display: block;\n        margin: 15px 0;\n        min-height: 220px\n    }\n    \n    .friends-href a {\n        display: inline-block;\n        font-size: 15px;\n        margin-top: 15px;\n        letter-spacing: .4px;\n        position: relative;\n        width: 200px;\n        margin-left: 40px;\n        font-weight: 500;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        border-bottom: none !important\n    }\n    \n    .friends-href a i {\n        margin-right: .4em;\n        color: #6db33f\n    }\n    \n    .friends-href a:before {\n        position: absolute;\n        top: -50%;\n        left: -50%;\n        padding: 1.3em 1em 1em 4em;\n        width: 150%;\n        height: 100%;\n        background: var(--content-bg-color) url(/images/link.svg) no-repeat -3em 50%;\n        background-size: auto 35%;\n        color: #404d5b;\n        color: transparent;\n        content: attr(href);\n        white-space: pre-wrap;\n        word-break: break-all;\n        font-weight: 600;\n        font-size: 50%;\n        line-height: 1.2;\n        opacity: .2;\n        font-family: 'Josefin Sans', 'PingFang SC';\n        font-size: 16px !important;\n        -webkit-transition: opacity .3s, color .3s, -webkit-transform .3s, background-position .2s;\n        -webkit-transition: opacity .3s, color .3s, background-position .2s, -webkit-transform .3s;\n        transition: opacity .3s, color .3s, background-position .2s, -webkit-transform .3s;\n        transition: opacity .3s, color .3s, transform .3s, background-position .2s;\n        transition: opacity .3s, color .3s, transform .3s, background-position .2s, -webkit-transform .3s;\n        -webkit-transform: scale(.5);\n        transform: scale(.5);\n        pointer-events: auto\n    }\n    \n    .friends-href a:focus::before, .friends-href a:hover::before {\n        background-position: 1em 50%;\n        color: #6db33f;\n        opacity: 1;\n        border: 1px solid #f9f9f9;\n        -webkit-box-shadow: 1px 1px 1px #ededed;\n        box-shadow: 1px 1px 1px #ededed;\n        border-radius: 2px;\n        -webkit-transition-delay: 0s, 0s, 0s, .1s;\n        transition-delay: 0s, 0s, 0s, .1s;\n        -webkit-transform: scale(1) translateY(-80%);\n        transform: scale(1) translateY(-80%)\n    }\n</style>\n\n<div class=\"friends-page\">\n    <div class=\"friends-href\">\n        <a href=\"https://www.github.com/mrdjun\" target=\"_blank\" class=\"ignore-href\">\n            <i class=\"fa fa-fw fa-star\"></i>github's href\n        </a>\n    </div>\n</div>"}],"Post":[{"title":"ArrayList","date":"2019-05-31T07:05:00.000Z","comments":0,"description":"关于如何去学习容器类的源码？先从这个容器类的属性去看这个容器是怎么存储的，再看入口的构造函数，最后是怎么增删改查元素的。","_content":"\n> Tips：分享一个心得\n\n关于如何去学习容器类的源码？先从这个容器类的属性去看这个容器是怎么存储的，再看入口的构造函数，最后是怎么增删改查元素的。\n\n-----\n\n## 存储结构\n\nArrayList底层存储使用的是Object[] elementData。\n\n## 添加元素\n\n添加元素之前判断是否需要扩容（实际上每一次新增元素都需要至少增加一个容量），然后赋值给数组中的元素。\n\n```java\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n```\n\n最小容量默认为10，小于10的按10来设置。\n\n```java\nprivate void ensureCapacityInternal(int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        // private static final int DEFAULT_CAPACITY = 10;\n        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    ensureExplicitCapacity(minCapacity);\n}\n```\n\n接着往下点，可以看到真正扩容的方法是grow方法。\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n点进Arrays工具类的copyof方法：\n\n```java\npublic static <T> T[] copyOf(T[] original, int newLength) {\n    return (T[]) copyOf(original, newLength, original.getClass());\n}\n\npublic static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {\n    @SuppressWarnings(\"unchecked\")\n    T[] copy = ((Object)newType == (Object)Object[].class)\n        ? (T[]) new Object[newLength]\n        : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n    System.arraycopy(original, 0, copy, 0,\n                     Math.min(original.length, newLength));\n    return copy;\n}\n\n// 一直往下到这个方法，可以看到调用的是用其它语言实现的数组赋值\npublic static native void arraycopy(Object src,  int  srcPos,\n                                    Object dest, int destPos,\n                                    int length);\n```\n\n增删查就是对一个数组的一些基本操作。\n\n","source":"_posts/Java并发 - ArrayList.md","raw":"---\ntitle: ArrayList\ndate: 2019-05-31 15:05:00\ntags:\n- JUC并发包\ncomments: false\ndescription: 关于如何去学习容器类的源码？先从这个容器类的属性去看这个容器是怎么存储的，再看入口的构造函数，最后是怎么增删改查元素的。\n---\n\n> Tips：分享一个心得\n\n关于如何去学习容器类的源码？先从这个容器类的属性去看这个容器是怎么存储的，再看入口的构造函数，最后是怎么增删改查元素的。\n\n-----\n\n## 存储结构\n\nArrayList底层存储使用的是Object[] elementData。\n\n## 添加元素\n\n添加元素之前判断是否需要扩容（实际上每一次新增元素都需要至少增加一个容量），然后赋值给数组中的元素。\n\n```java\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n```\n\n最小容量默认为10，小于10的按10来设置。\n\n```java\nprivate void ensureCapacityInternal(int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        // private static final int DEFAULT_CAPACITY = 10;\n        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    ensureExplicitCapacity(minCapacity);\n}\n```\n\n接着往下点，可以看到真正扩容的方法是grow方法。\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n点进Arrays工具类的copyof方法：\n\n```java\npublic static <T> T[] copyOf(T[] original, int newLength) {\n    return (T[]) copyOf(original, newLength, original.getClass());\n}\n\npublic static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {\n    @SuppressWarnings(\"unchecked\")\n    T[] copy = ((Object)newType == (Object)Object[].class)\n        ? (T[]) new Object[newLength]\n        : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n    System.arraycopy(original, 0, copy, 0,\n                     Math.min(original.length, newLength));\n    return copy;\n}\n\n// 一直往下到这个方法，可以看到调用的是用其它语言实现的数组赋值\npublic static native void arraycopy(Object src,  int  srcPos,\n                                    Object dest, int destPos,\n                                    int length);\n```\n\n增删查就是对一个数组的一些基本操作。\n\n","slug":"Java并发 - ArrayList","published":1,"updated":"2022-03-02T11:31:20.843Z","layout":"post","photos":[],"link":"","_id":"cl0atbcop00017cu5bjf62z3c","content":"<blockquote>\n<p>Tips：分享一个心得</p>\n</blockquote>\n<p>关于如何去学习容器类的源码？先从这个容器类的属性去看这个容器是怎么存储的，再看入口的构造函数，最后是怎么增删改查元素的。</p>\n<hr>\n<h2 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h2><p>ArrayList底层存储使用的是Object[] elementData。</p>\n<h2 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h2><p>添加元素之前判断是否需要扩容（实际上每一次新增元素都需要至少增加一个容量），然后赋值给数组中的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最小容量默认为10，小于10的按10来设置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// private static final int DEFAULT_CAPACITY = 10;</span></span><br><span class=\"line\">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着往下点，可以看到真正扩容的方法是grow方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>点进Arrays工具类的copyof方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class=\"type\">int</span> newLength) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class=\"type\">int</span> newLength, Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">T</span>[]&gt; newType) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class=\"line\">        ? (T[]) <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[newLength]</span><br><span class=\"line\">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class=\"line\">    System.arraycopy(original, <span class=\"number\">0</span>, copy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                     Math.min(original.length, newLength));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一直往下到这个方法，可以看到调用的是用其它语言实现的数组赋值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">arraycopy</span><span class=\"params\">(Object src,  <span class=\"type\">int</span>  srcPos,</span></span><br><span class=\"line\"><span class=\"params\">                                    Object dest, <span class=\"type\">int</span> destPos,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">int</span> length)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>增删查就是对一个数组的一些基本操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Tips：分享一个心得</p>\n</blockquote>\n<p>关于如何去学习容器类的源码？先从这个容器类的属性去看这个容器是怎么存储的，再看入口的构造函数，最后是怎么增删改查元素的。</p>\n<hr>\n<h2 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h2><p>ArrayList底层存储使用的是Object[] elementData。</p>\n<h2 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h2><p>添加元素之前判断是否需要扩容（实际上每一次新增元素都需要至少增加一个容量），然后赋值给数组中的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最小容量默认为10，小于10的按10来设置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// private static final int DEFAULT_CAPACITY = 10;</span></span><br><span class=\"line\">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着往下点，可以看到真正扩容的方法是grow方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>点进Arrays工具类的copyof方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class=\"type\">int</span> newLength) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class=\"type\">int</span> newLength, Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">T</span>[]&gt; newType) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class=\"line\">        ? (T[]) <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[newLength]</span><br><span class=\"line\">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class=\"line\">    System.arraycopy(original, <span class=\"number\">0</span>, copy, <span class=\"number\">0</span>,</span><br><span class=\"line\">                     Math.min(original.length, newLength));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一直往下到这个方法，可以看到调用的是用其它语言实现的数组赋值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title function_\">arraycopy</span><span class=\"params\">(Object src,  <span class=\"type\">int</span>  srcPos,</span></span><br><span class=\"line\"><span class=\"params\">                                    Object dest, <span class=\"type\">int</span> destPos,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">int</span> length)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>增删查就是对一个数组的一些基本操作。</p>\n"},{"title":"AQS抽象队列同步器","date":"2021-06-01T09:19:14.000Z","comments":0,"_content":"\nAQS全称为 AbstractQueuedSynchronizer。提供了对资源占用、释放，线程等待、唤醒等接口和具体实现。可以用在各种需要控制资源争用的场景，例如ReentrantLock、CountDownLatch、Semphore中。\n\n![image-20210513220313583](.\\images\\AQS-接口.png)\n\nacquire、acquireShared：定义了资源争用的逻辑，如果没拿到则等待。\n\ntryAcquire、tryAcquireShared：实际执行占用资源的操作，如何判断一个由使用者具体去实现。\n\nrelease、releaseShared：定义释放资源的逻辑，释放之后通知后续节点进行争抢。\n\ntryRelease、tryReleaseShared：实际执行资源释放的操作，具体由使用者去实现。\n\n## 简单应用 \n\n通过这个实例加深对AQS的理解，为看懂源码打下一定的基础。\n\n```java\npublic class MyAqs {\n    // 占用当前资源的线程\n    public volatile AtomicReference<Thread> owner = new AtomicReference<>();\n    // 保存等待的线程\n    public volatile LinkedBlockingQueue<Thread> waiters = new LinkedBlockingQueue<>();\n    // 记录资源状态\n    public volatile AtomicInteger state = new AtomicInteger(0);\n    \n    public void acquire() {\n        boolean addQ = true;\n        while (!tryAcquire()) {\n            if (addQ) {\n                // 没拿到锁，加入到等待集合\n                waiters.offer(Thread.currentThread());\n                addQ = false;\n            } else {\n                // 阻塞、挂起当前的线程\n                LockSupport.park(); \n            }\n        }\n        // 当前线程拿到锁后，移除当前线程\n        waiters.remove(Thread.currentThread()); \n    }\n    \n    /**\n     * 交由使用者自己实现\n     */\n    public boolean tryAcquire() { \n        throw new UnsupportedOperationException();\n    }\n    \n    public void release() {\n        if (tryRelease()) {\n            // 通知等待者\n            Iterator<Thread> iterator = waiters.iterator();\n            if (iterator.hasNext()) {\n                Thread next = iterator.next();\n                // 当前线程释放资源后，唤醒下一个线程\n                LockSupport.unpark(next); \n            }\n        }\n    }\n    \n    public boolean tryRelease() {\n        throw new UnsupportedOperationException();\n    }\n    \n    //================== 共享资源逻辑 ==================//\n    public void acquireShared() {\n        boolean addQ = true;\n        while (tryAcquireShared() < 0) {\n            if (addQ) {\n                waiters.offer(Thread.currentThread());\n                addQ = false;\n            } else {\n                LockSupport.park(); \n            }\n        }\n        waiters.remove(Thread.currentThread());\n    }\n    \n    public int tryAcquireShared() {\n        throw new UnsupportedOperationException();\n    }\n\t\n    public void releaseShared() {\n        if (tryReleaseShared()) {\n            Iterator<Thread> iterator = waiters.iterator();\n            if (iterator.hasNext()) {\n                Thread next = iterator.next();\n                LockSupport.unpark(next);\n            }\n        }\n    }\n    \n    public boolean tryReleaseShared() {\n        throw new UnsupportedOperationException();\n    }\n    \n    // 给使用者提供状态修改方法\n    public AtomicInteger getState() {\n        return state;\n    }\n\n    public void setState(AtomicInteger state) {\n        this.state = state;\n    }\n}\n```\n\n## AQS源码阅读\n\n源码中等待队列维护的是一个链表，而不是我们上面使用的BlockingQueue。\n\n在独占模式下忽略中断的情况获取锁。如果没有拿到锁则当前线程存入队列等待后，不断尝试获取锁，具体代码在acquireQueued() 中。\n\n```java\npublic final void acquire(int arg) {\n    // 判断是否拿到锁\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\nprotected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n```\n\n如果第一次执行tryAcquire() 没有拿到锁，则当前线程将进行自旋，直到成功拿到锁。\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false; // 当前线程释放中断的标志位\n        for (;;) {// 不断尝试\n            final Node p = node.predecessor(); // 获取前一个节点\n            if (p == head && tryAcquire(arg)) { // 如果前一个节点是head，尝试抢一次锁\n                setHead(node); // 更换head\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            // 检查在当前节点之前的线程节点状态，是否需要挂起线程\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())// 如果需要挂起，则通过Park进入停车场挂起\n                interrupted = true; // 如果出现中断，则修改标记\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\nfinal Node predecessor() throws NullPointerException {\n    // 当前节点前如果没有其它节点，那就肯定是head节点\n    Node p = prev;\n    if (p == null)\n        throw new NullPointerException();\n    else\n        return p;\n}\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus; // 根据 前置节点的状态 执行不同的流程\n    if (ws == Node.SIGNAL) // 前置节点释放锁之后会通知当前线程，挂起吧\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) { // 前置节点处于CANCELLED状态，跳过它继续寻找正常的节点，并且甩掉中间那段不正常的节点\n        /*\n         * Predecessor was cancelled. Skip over predecessors and\n         * indicate retry.\n         */\n        do { // 也可以理解为，这是一次队列检查\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don't park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); // 修改前置的状态为SIGNAL，用意是释放锁之后会通知后续节点\n    }\n    return false;\n}\n```\n\n释放资源。解锁成功后，单向链表中的线程节点往后移，唤醒下一个状态正常的线程。\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head; // 从头开始找\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h); // 唤醒下一个线程\n        return true;\n    }\n    return false;\n}\n\nprotected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n\nprivate void unparkSuccessor(Node node) {\n    /*\n     * If status is negative (i.e., possibly needing signal) try\n     * to clear in anticipation of signalling.  It is OK if this\n     * fails or if status is changed by waiting thread.\n     */\n    int ws = node.waitStatus; // 正在释放锁的线程节点状态\n    if (ws < 0)\n        compareAndSetWaitStatus(node, ws, 0); // 修改当前节点状态\n\n    /*\n     * Thread to unpark is held in successor, which is normally\n     * just the next node.  But if cancelled or apparently null,\n     * traverse backwards from tail to find the actual\n     * non-cancelled successor.\n     */\n    Node s = node.next; // 找下一个节点\n    if (s == null || s.waitStatus > 0) { // 如果不存在或者被取消了，继续寻找合适的下一个节点\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null) // 如果找到了合适的节点，就唤醒它\n        LockSupport.unpark(s.thread);\n}\n```\n\n##  总结\n\n资源占用流程\n\n![image-20210514131357784](.\\images\\AQS-资源占用流程.png)\n\n","source":"_posts/Java并发 - AQS抽象队列同步器.md","raw":"---\ntitle: AQS抽象队列同步器\ndate: 2021-06-1 17:19:14\ntags:\n- JUC并发包\ncomments: false\n---\n\nAQS全称为 AbstractQueuedSynchronizer。提供了对资源占用、释放，线程等待、唤醒等接口和具体实现。可以用在各种需要控制资源争用的场景，例如ReentrantLock、CountDownLatch、Semphore中。\n\n![image-20210513220313583](.\\images\\AQS-接口.png)\n\nacquire、acquireShared：定义了资源争用的逻辑，如果没拿到则等待。\n\ntryAcquire、tryAcquireShared：实际执行占用资源的操作，如何判断一个由使用者具体去实现。\n\nrelease、releaseShared：定义释放资源的逻辑，释放之后通知后续节点进行争抢。\n\ntryRelease、tryReleaseShared：实际执行资源释放的操作，具体由使用者去实现。\n\n## 简单应用 \n\n通过这个实例加深对AQS的理解，为看懂源码打下一定的基础。\n\n```java\npublic class MyAqs {\n    // 占用当前资源的线程\n    public volatile AtomicReference<Thread> owner = new AtomicReference<>();\n    // 保存等待的线程\n    public volatile LinkedBlockingQueue<Thread> waiters = new LinkedBlockingQueue<>();\n    // 记录资源状态\n    public volatile AtomicInteger state = new AtomicInteger(0);\n    \n    public void acquire() {\n        boolean addQ = true;\n        while (!tryAcquire()) {\n            if (addQ) {\n                // 没拿到锁，加入到等待集合\n                waiters.offer(Thread.currentThread());\n                addQ = false;\n            } else {\n                // 阻塞、挂起当前的线程\n                LockSupport.park(); \n            }\n        }\n        // 当前线程拿到锁后，移除当前线程\n        waiters.remove(Thread.currentThread()); \n    }\n    \n    /**\n     * 交由使用者自己实现\n     */\n    public boolean tryAcquire() { \n        throw new UnsupportedOperationException();\n    }\n    \n    public void release() {\n        if (tryRelease()) {\n            // 通知等待者\n            Iterator<Thread> iterator = waiters.iterator();\n            if (iterator.hasNext()) {\n                Thread next = iterator.next();\n                // 当前线程释放资源后，唤醒下一个线程\n                LockSupport.unpark(next); \n            }\n        }\n    }\n    \n    public boolean tryRelease() {\n        throw new UnsupportedOperationException();\n    }\n    \n    //================== 共享资源逻辑 ==================//\n    public void acquireShared() {\n        boolean addQ = true;\n        while (tryAcquireShared() < 0) {\n            if (addQ) {\n                waiters.offer(Thread.currentThread());\n                addQ = false;\n            } else {\n                LockSupport.park(); \n            }\n        }\n        waiters.remove(Thread.currentThread());\n    }\n    \n    public int tryAcquireShared() {\n        throw new UnsupportedOperationException();\n    }\n\t\n    public void releaseShared() {\n        if (tryReleaseShared()) {\n            Iterator<Thread> iterator = waiters.iterator();\n            if (iterator.hasNext()) {\n                Thread next = iterator.next();\n                LockSupport.unpark(next);\n            }\n        }\n    }\n    \n    public boolean tryReleaseShared() {\n        throw new UnsupportedOperationException();\n    }\n    \n    // 给使用者提供状态修改方法\n    public AtomicInteger getState() {\n        return state;\n    }\n\n    public void setState(AtomicInteger state) {\n        this.state = state;\n    }\n}\n```\n\n## AQS源码阅读\n\n源码中等待队列维护的是一个链表，而不是我们上面使用的BlockingQueue。\n\n在独占模式下忽略中断的情况获取锁。如果没有拿到锁则当前线程存入队列等待后，不断尝试获取锁，具体代码在acquireQueued() 中。\n\n```java\npublic final void acquire(int arg) {\n    // 判断是否拿到锁\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\nprotected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n```\n\n如果第一次执行tryAcquire() 没有拿到锁，则当前线程将进行自旋，直到成功拿到锁。\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false; // 当前线程释放中断的标志位\n        for (;;) {// 不断尝试\n            final Node p = node.predecessor(); // 获取前一个节点\n            if (p == head && tryAcquire(arg)) { // 如果前一个节点是head，尝试抢一次锁\n                setHead(node); // 更换head\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            // 检查在当前节点之前的线程节点状态，是否需要挂起线程\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())// 如果需要挂起，则通过Park进入停车场挂起\n                interrupted = true; // 如果出现中断，则修改标记\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\nfinal Node predecessor() throws NullPointerException {\n    // 当前节点前如果没有其它节点，那就肯定是head节点\n    Node p = prev;\n    if (p == null)\n        throw new NullPointerException();\n    else\n        return p;\n}\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus; // 根据 前置节点的状态 执行不同的流程\n    if (ws == Node.SIGNAL) // 前置节点释放锁之后会通知当前线程，挂起吧\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) { // 前置节点处于CANCELLED状态，跳过它继续寻找正常的节点，并且甩掉中间那段不正常的节点\n        /*\n         * Predecessor was cancelled. Skip over predecessors and\n         * indicate retry.\n         */\n        do { // 也可以理解为，这是一次队列检查\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don't park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); // 修改前置的状态为SIGNAL，用意是释放锁之后会通知后续节点\n    }\n    return false;\n}\n```\n\n释放资源。解锁成功后，单向链表中的线程节点往后移，唤醒下一个状态正常的线程。\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head; // 从头开始找\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h); // 唤醒下一个线程\n        return true;\n    }\n    return false;\n}\n\nprotected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n\nprivate void unparkSuccessor(Node node) {\n    /*\n     * If status is negative (i.e., possibly needing signal) try\n     * to clear in anticipation of signalling.  It is OK if this\n     * fails or if status is changed by waiting thread.\n     */\n    int ws = node.waitStatus; // 正在释放锁的线程节点状态\n    if (ws < 0)\n        compareAndSetWaitStatus(node, ws, 0); // 修改当前节点状态\n\n    /*\n     * Thread to unpark is held in successor, which is normally\n     * just the next node.  But if cancelled or apparently null,\n     * traverse backwards from tail to find the actual\n     * non-cancelled successor.\n     */\n    Node s = node.next; // 找下一个节点\n    if (s == null || s.waitStatus > 0) { // 如果不存在或者被取消了，继续寻找合适的下一个节点\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null) // 如果找到了合适的节点，就唤醒它\n        LockSupport.unpark(s.thread);\n}\n```\n\n##  总结\n\n资源占用流程\n\n![image-20210514131357784](.\\images\\AQS-资源占用流程.png)\n\n","slug":"Java并发 - AQS抽象队列同步器","published":1,"updated":"2022-03-02T11:27:05.006Z","layout":"post","photos":[],"link":"","_id":"cl0atbcos00037cu52d3k8hka","content":"<p>AQS全称为 AbstractQueuedSynchronizer。提供了对资源占用、释放，线程等待、唤醒等接口和具体实现。可以用在各种需要控制资源争用的场景，例如ReentrantLock、CountDownLatch、Semphore中。</p>\n<p><img src=\"/.%5Cimages%5CAQS-%E6%8E%A5%E5%8F%A3.png\" alt=\"image-20210513220313583\"></p>\n<p>acquire、acquireShared：定义了资源争用的逻辑，如果没拿到则等待。</p>\n<p>tryAcquire、tryAcquireShared：实际执行占用资源的操作，如何判断一个由使用者具体去实现。</p>\n<p>release、releaseShared：定义释放资源的逻辑，释放之后通知后续节点进行争抢。</p>\n<p>tryRelease、tryReleaseShared：实际执行资源释放的操作，具体由使用者去实现。</p>\n<h2 id=\"简单应用\"><a href=\"#简单应用\" class=\"headerlink\" title=\"简单应用\"></a>简单应用</h2><p>通过这个实例加深对AQS的理解，为看懂源码打下一定的基础。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAqs</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 占用当前资源的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> AtomicReference&lt;Thread&gt; owner = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicReference</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 保存等待的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> LinkedBlockingQueue&lt;Thread&gt; waiters = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 记录资源状态</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">state</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">addQ</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!tryAcquire()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addQ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没拿到锁，加入到等待集合</span></span><br><span class=\"line\">                waiters.offer(Thread.currentThread());</span><br><span class=\"line\">                addQ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 阻塞、挂起当前的线程</span></span><br><span class=\"line\">                LockSupport.park(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当前线程拿到锁后，移除当前线程</span></span><br><span class=\"line\">        waiters.remove(Thread.currentThread()); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 交由使用者自己实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAcquire</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">release</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tryRelease()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待者</span></span><br><span class=\"line\">            Iterator&lt;Thread&gt; iterator = waiters.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                <span class=\"comment\">// 当前线程释放资源后，唤醒下一个线程</span></span><br><span class=\"line\">                LockSupport.unpark(next); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryRelease</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//================== 共享资源逻辑 ==================//</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquireShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">addQ</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tryAcquireShared() &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addQ) &#123;</span><br><span class=\"line\">                waiters.offer(Thread.currentThread());</span><br><span class=\"line\">                addQ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                LockSupport.park(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        waiters.remove(Thread.currentThread());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">tryAcquireShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">releaseShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tryReleaseShared()) &#123;</span><br><span class=\"line\">            Iterator&lt;Thread&gt; iterator = waiters.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                LockSupport.unpark(next);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryReleaseShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 给使用者提供状态修改方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> AtomicInteger <span class=\"title function_\">getState</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setState</span><span class=\"params\">(AtomicInteger state)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.state = state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"AQS源码阅读\"><a href=\"#AQS源码阅读\" class=\"headerlink\" title=\"AQS源码阅读\"></a>AQS源码阅读</h2><p>源码中等待队列维护的是一个链表，而不是我们上面使用的BlockingQueue。</p>\n<p>在独占模式下忽略中断的情况获取锁。如果没有拿到锁则当前线程存入队列等待后，不断尝试获取锁，具体代码在acquireQueued() 中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否拿到锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAcquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果第一次执行tryAcquire() 没有拿到锁，则当前线程将进行自旋，直到成功拿到锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">failed</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 当前线程释放中断的标志位</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;<span class=\"comment\">// 不断尝试</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">Node</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> node.predecessor(); <span class=\"comment\">// 获取前一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class=\"comment\">// 如果前一个节点是head，尝试抢一次锁</span></span><br><span class=\"line\">                setHead(node); <span class=\"comment\">// 更换head</span></span><br><span class=\"line\">                p.next = <span class=\"literal\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 检查在当前节点之前的线程节点状态，是否需要挂起线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())<span class=\"comment\">// 如果需要挂起，则通过Park进入停车场挂起</span></span><br><span class=\"line\">                interrupted = <span class=\"literal\">true</span>; <span class=\"comment\">// 如果出现中断，则修改标记</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node <span class=\"title function_\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前节点前如果没有其它节点，那就肯定是head节点</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ws</span> <span class=\"operator\">=</span> pred.waitStatus; <span class=\"comment\">// 根据 前置节点的状态 执行不同的流程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL) <span class=\"comment\">// 前置节点释放锁之后会通知当前线程，挂起吧</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">         * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 前置节点处于CANCELLED状态，跳过它继续寻找正常的节点，并且甩掉中间那段不正常的节点</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">         * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123; <span class=\"comment\">// 也可以理解为，这是一次队列检查</span></span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class=\"line\"><span class=\"comment\">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class=\"line\"><span class=\"comment\">         * retry to make sure it cannot acquire before parking.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class=\"comment\">// 修改前置的状态为SIGNAL，用意是释放锁之后会通知后续节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放资源。解锁成功后，单向链表中的线程节点往后移，唤醒下一个状态正常的线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">release</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> head; <span class=\"comment\">// 从头开始找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"literal\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h); <span class=\"comment\">// 唤醒下一个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryRelease</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unparkSuccessor</span><span class=\"params\">(Node node)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class=\"line\"><span class=\"comment\">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class=\"line\"><span class=\"comment\">     * fails or if status is changed by waiting thread.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ws</span> <span class=\"operator\">=</span> node.waitStatus; <span class=\"comment\">// 正在释放锁的线程节点状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>); <span class=\"comment\">// 修改当前节点状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Thread to unpark is held in successor, which is normally</span></span><br><span class=\"line\"><span class=\"comment\">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class=\"line\"><span class=\"comment\">     * traverse backwards from tail to find the actual</span></span><br><span class=\"line\"><span class=\"comment\">     * non-cancelled successor.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> node.next; <span class=\"comment\">// 找下一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果不存在或者被取消了，继续寻找合适的下一个节点</span></span><br><span class=\"line\">        s = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">Node</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> tail; t != <span class=\"literal\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                s = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"literal\">null</span>) <span class=\"comment\">// 如果找到了合适的节点，就唤醒它</span></span><br><span class=\"line\">        LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>资源占用流程</p>\n<p><img src=\"/.%5Cimages%5CAQS-%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%B5%81%E7%A8%8B.png\" alt=\"image-20210514131357784\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>AQS全称为 AbstractQueuedSynchronizer。提供了对资源占用、释放，线程等待、唤醒等接口和具体实现。可以用在各种需要控制资源争用的场景，例如ReentrantLock、CountDownLatch、Semphore中。</p>\n<p><img src=\"/.%5Cimages%5CAQS-%E6%8E%A5%E5%8F%A3.png\" alt=\"image-20210513220313583\"></p>\n<p>acquire、acquireShared：定义了资源争用的逻辑，如果没拿到则等待。</p>\n<p>tryAcquire、tryAcquireShared：实际执行占用资源的操作，如何判断一个由使用者具体去实现。</p>\n<p>release、releaseShared：定义释放资源的逻辑，释放之后通知后续节点进行争抢。</p>\n<p>tryRelease、tryReleaseShared：实际执行资源释放的操作，具体由使用者去实现。</p>\n<h2 id=\"简单应用\"><a href=\"#简单应用\" class=\"headerlink\" title=\"简单应用\"></a>简单应用</h2><p>通过这个实例加深对AQS的理解，为看懂源码打下一定的基础。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAqs</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 占用当前资源的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> AtomicReference&lt;Thread&gt; owner = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicReference</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 保存等待的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> LinkedBlockingQueue&lt;Thread&gt; waiters = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 记录资源状态</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">state</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">addQ</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!tryAcquire()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addQ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没拿到锁，加入到等待集合</span></span><br><span class=\"line\">                waiters.offer(Thread.currentThread());</span><br><span class=\"line\">                addQ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 阻塞、挂起当前的线程</span></span><br><span class=\"line\">                LockSupport.park(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当前线程拿到锁后，移除当前线程</span></span><br><span class=\"line\">        waiters.remove(Thread.currentThread()); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 交由使用者自己实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAcquire</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">release</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tryRelease()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待者</span></span><br><span class=\"line\">            Iterator&lt;Thread&gt; iterator = waiters.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                <span class=\"comment\">// 当前线程释放资源后，唤醒下一个线程</span></span><br><span class=\"line\">                LockSupport.unpark(next); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryRelease</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//================== 共享资源逻辑 ==================//</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquireShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">addQ</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tryAcquireShared() &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addQ) &#123;</span><br><span class=\"line\">                waiters.offer(Thread.currentThread());</span><br><span class=\"line\">                addQ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                LockSupport.park(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        waiters.remove(Thread.currentThread());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">tryAcquireShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">releaseShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tryReleaseShared()) &#123;</span><br><span class=\"line\">            Iterator&lt;Thread&gt; iterator = waiters.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                LockSupport.unpark(next);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryReleaseShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 给使用者提供状态修改方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> AtomicInteger <span class=\"title function_\">getState</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setState</span><span class=\"params\">(AtomicInteger state)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.state = state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"AQS源码阅读\"><a href=\"#AQS源码阅读\" class=\"headerlink\" title=\"AQS源码阅读\"></a>AQS源码阅读</h2><p>源码中等待队列维护的是一个链表，而不是我们上面使用的BlockingQueue。</p>\n<p>在独占模式下忽略中断的情况获取锁。如果没有拿到锁则当前线程存入队列等待后，不断尝试获取锁，具体代码在acquireQueued() 中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否拿到锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAcquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果第一次执行tryAcquire() 没有拿到锁，则当前线程将进行自旋，直到成功拿到锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">failed</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 当前线程释放中断的标志位</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;<span class=\"comment\">// 不断尝试</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">Node</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> node.predecessor(); <span class=\"comment\">// 获取前一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class=\"comment\">// 如果前一个节点是head，尝试抢一次锁</span></span><br><span class=\"line\">                setHead(node); <span class=\"comment\">// 更换head</span></span><br><span class=\"line\">                p.next = <span class=\"literal\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 检查在当前节点之前的线程节点状态，是否需要挂起线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())<span class=\"comment\">// 如果需要挂起，则通过Park进入停车场挂起</span></span><br><span class=\"line\">                interrupted = <span class=\"literal\">true</span>; <span class=\"comment\">// 如果出现中断，则修改标记</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node <span class=\"title function_\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前节点前如果没有其它节点，那就肯定是head节点</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ws</span> <span class=\"operator\">=</span> pred.waitStatus; <span class=\"comment\">// 根据 前置节点的状态 执行不同的流程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL) <span class=\"comment\">// 前置节点释放锁之后会通知当前线程，挂起吧</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">         * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 前置节点处于CANCELLED状态，跳过它继续寻找正常的节点，并且甩掉中间那段不正常的节点</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">         * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123; <span class=\"comment\">// 也可以理解为，这是一次队列检查</span></span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class=\"line\"><span class=\"comment\">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class=\"line\"><span class=\"comment\">         * retry to make sure it cannot acquire before parking.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class=\"comment\">// 修改前置的状态为SIGNAL，用意是释放锁之后会通知后续节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放资源。解锁成功后，单向链表中的线程节点往后移，唤醒下一个状态正常的线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">release</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> head; <span class=\"comment\">// 从头开始找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"literal\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h); <span class=\"comment\">// 唤醒下一个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryRelease</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unparkSuccessor</span><span class=\"params\">(Node node)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class=\"line\"><span class=\"comment\">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class=\"line\"><span class=\"comment\">     * fails or if status is changed by waiting thread.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ws</span> <span class=\"operator\">=</span> node.waitStatus; <span class=\"comment\">// 正在释放锁的线程节点状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>); <span class=\"comment\">// 修改当前节点状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Thread to unpark is held in successor, which is normally</span></span><br><span class=\"line\"><span class=\"comment\">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class=\"line\"><span class=\"comment\">     * traverse backwards from tail to find the actual</span></span><br><span class=\"line\"><span class=\"comment\">     * non-cancelled successor.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> node.next; <span class=\"comment\">// 找下一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果不存在或者被取消了，继续寻找合适的下一个节点</span></span><br><span class=\"line\">        s = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">Node</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> tail; t != <span class=\"literal\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                s = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"literal\">null</span>) <span class=\"comment\">// 如果找到了合适的节点，就唤醒它</span></span><br><span class=\"line\">        LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>资源占用流程</p>\n<p><img src=\"/.%5Cimages%5CAQS-%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%B5%81%E7%A8%8B.png\" alt=\"image-20210514131357784\"></p>\n"},{"title":"ForkJoinPool","date":"2021-08-22T04:50:00.000Z","comments":0,"_content":"\n​\t\tForkJoinPool 是ExecutorService 接口的实现，它专为可以递归分解成小块的工作而设计。Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务（Runnable）：把一个大任务拆成多个小任务并行处理，最后将子任务结果合并成最后的计算结果。充分利用多线程处理器的优势，提高程序性能。\n\n## 具有高性能低冲突的原因\n\n- 每个Worker线程都维护一个任务队列，即ForkJoinWorkerThread中的任务队列；\n\n- ForkJoin维护的任务队列是双端队列（DeQueue），可以同时支持LIFO（先进后出）和FIFO（先进先出）；\n\n- 子任务会被加入到原先任务所在 Worker 线程的任务队列；\n\n- 当任务队列为空时，线程会随机从其他的 Worker 的队列中拿走一个任务执行（工作窃取：steal work），工作窃取带来的性能提升偏理论，API的复杂性较高，实际研发中可控性来说不如其他API。\n\n## 缺点\n\n- 如果一个 Worker 线程遇到了 join 操作，而这时候正在处理其他任务，会等到这个任务结束。否则直接返回；\n\n- 如果一个 Worker 线程窃取任务失败，它会调用 yield 或者 sleep 之类的方法休息一会儿，再尝试（如果所有线程都是空闲状态，即没有任务执行，那么该线程也会进入阻塞状态等待新任务的到来）；\n\n## 适用场景\n\n使用尽可能少的线程池，在大多数情况下，最好的决定是为每个应用程序或系统使用一个线程池；\n\n如果不需要特定调整，请使用默认的公共线程池；\n\n使用合理的阈值将ForkJoinTask拆分为子任务；\n\n避免在ForkJoinTask中出现任何阻塞（例如耗时IO，大量查询数据库、网络请求等）；\n\n适合数据处理、结果汇总、统计等场景；\n\njava8实例：java.utilArrays类用于其 parallelSort() 方法；\n\n## 应用示例\n\n例如，下面将从 0 加到 10_0000_0000：\n\n```java\npublic void test1() {\n    long start = System.currentTimeMillis();\n    long sum = 0;\n    for (long i = 0; i < 10_0000_0000L; i++) {\n        sum += i;\n    }\n    System.out.println(sum + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\");// 耗时：361ms\n}\n```\n\n使用 ForkJoinPool 执行该任务：\n\n```java\npublic void test2() throws ExecutionException, InterruptedException {\n    long start = System.currentTimeMillis();\n\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinTask<Long> task = new Task04051(0L, 10_0000_0000L);\n    ForkJoinTask<Long> submit = pool.submit(task);\n    Long result = submit.get();\n\n    System.out.println(result + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\"); // 耗时：186ms\n}\n```\n\n使用  stream 并行执行任务：\n\n```java\npublic void test3() {\n    long start = System.currentTimeMillis();\n\t// 与 LongStream 类似的有DoubleStream、IntegerStream 等\n    long sum = LongStream.rangeClosed(0L, num).parallel().reduce(0, Long::sum);\n\n    System.out.println(sum + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\");// 耗时：126ms\n}\n```\n\n","source":"_posts/Java并发 - ForkJoin.md","raw":"---\ntitle: ForkJoinPool\ndate: 2021-08-22 12:50:00\ntags:\n- Java\ncomments: false\n---\n\n​\t\tForkJoinPool 是ExecutorService 接口的实现，它专为可以递归分解成小块的工作而设计。Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务（Runnable）：把一个大任务拆成多个小任务并行处理，最后将子任务结果合并成最后的计算结果。充分利用多线程处理器的优势，提高程序性能。\n\n## 具有高性能低冲突的原因\n\n- 每个Worker线程都维护一个任务队列，即ForkJoinWorkerThread中的任务队列；\n\n- ForkJoin维护的任务队列是双端队列（DeQueue），可以同时支持LIFO（先进后出）和FIFO（先进先出）；\n\n- 子任务会被加入到原先任务所在 Worker 线程的任务队列；\n\n- 当任务队列为空时，线程会随机从其他的 Worker 的队列中拿走一个任务执行（工作窃取：steal work），工作窃取带来的性能提升偏理论，API的复杂性较高，实际研发中可控性来说不如其他API。\n\n## 缺点\n\n- 如果一个 Worker 线程遇到了 join 操作，而这时候正在处理其他任务，会等到这个任务结束。否则直接返回；\n\n- 如果一个 Worker 线程窃取任务失败，它会调用 yield 或者 sleep 之类的方法休息一会儿，再尝试（如果所有线程都是空闲状态，即没有任务执行，那么该线程也会进入阻塞状态等待新任务的到来）；\n\n## 适用场景\n\n使用尽可能少的线程池，在大多数情况下，最好的决定是为每个应用程序或系统使用一个线程池；\n\n如果不需要特定调整，请使用默认的公共线程池；\n\n使用合理的阈值将ForkJoinTask拆分为子任务；\n\n避免在ForkJoinTask中出现任何阻塞（例如耗时IO，大量查询数据库、网络请求等）；\n\n适合数据处理、结果汇总、统计等场景；\n\njava8实例：java.utilArrays类用于其 parallelSort() 方法；\n\n## 应用示例\n\n例如，下面将从 0 加到 10_0000_0000：\n\n```java\npublic void test1() {\n    long start = System.currentTimeMillis();\n    long sum = 0;\n    for (long i = 0; i < 10_0000_0000L; i++) {\n        sum += i;\n    }\n    System.out.println(sum + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\");// 耗时：361ms\n}\n```\n\n使用 ForkJoinPool 执行该任务：\n\n```java\npublic void test2() throws ExecutionException, InterruptedException {\n    long start = System.currentTimeMillis();\n\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinTask<Long> task = new Task04051(0L, 10_0000_0000L);\n    ForkJoinTask<Long> submit = pool.submit(task);\n    Long result = submit.get();\n\n    System.out.println(result + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\"); // 耗时：186ms\n}\n```\n\n使用  stream 并行执行任务：\n\n```java\npublic void test3() {\n    long start = System.currentTimeMillis();\n\t// 与 LongStream 类似的有DoubleStream、IntegerStream 等\n    long sum = LongStream.rangeClosed(0L, num).parallel().reduce(0, Long::sum);\n\n    System.out.println(sum + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\");// 耗时：126ms\n}\n```\n\n","slug":"Java并发 - ForkJoin","published":1,"updated":"2022-02-28T10:08:07.552Z","layout":"post","photos":[],"link":"","_id":"cl0atbcou00057cu58k9e9ces","content":"<p>​        ForkJoinPool 是ExecutorService 接口的实现，它专为可以递归分解成小块的工作而设计。Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务（Runnable）：把一个大任务拆成多个小任务并行处理，最后将子任务结果合并成最后的计算结果。充分利用多线程处理器的优势，提高程序性能。</p>\n<h2 id=\"具有高性能低冲突的原因\"><a href=\"#具有高性能低冲突的原因\" class=\"headerlink\" title=\"具有高性能低冲突的原因\"></a>具有高性能低冲突的原因</h2><ul>\n<li><p>每个Worker线程都维护一个任务队列，即ForkJoinWorkerThread中的任务队列；</p>\n</li>\n<li><p>ForkJoin维护的任务队列是双端队列（DeQueue），可以同时支持LIFO（先进后出）和FIFO（先进先出）；</p>\n</li>\n<li><p>子任务会被加入到原先任务所在 Worker 线程的任务队列；</p>\n</li>\n<li><p>当任务队列为空时，线程会随机从其他的 Worker 的队列中拿走一个任务执行（工作窃取：steal work），工作窃取带来的性能提升偏理论，API的复杂性较高，实际研发中可控性来说不如其他API。</p>\n</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li><p>如果一个 Worker 线程遇到了 join 操作，而这时候正在处理其他任务，会等到这个任务结束。否则直接返回；</p>\n</li>\n<li><p>如果一个 Worker 线程窃取任务失败，它会调用 yield 或者 sleep 之类的方法休息一会儿，再尝试（如果所有线程都是空闲状态，即没有任务执行，那么该线程也会进入阻塞状态等待新任务的到来）；</p>\n</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>使用尽可能少的线程池，在大多数情况下，最好的决定是为每个应用程序或系统使用一个线程池；</p>\n<p>如果不需要特定调整，请使用默认的公共线程池；</p>\n<p>使用合理的阈值将ForkJoinTask拆分为子任务；</p>\n<p>避免在ForkJoinTask中出现任何阻塞（例如耗时IO，大量查询数据库、网络请求等）；</p>\n<p>适合数据处理、结果汇总、统计等场景；</p>\n<p>java8实例：java.utilArrays类用于其 parallelSort() 方法；</p>\n<h2 id=\"应用示例\"><a href=\"#应用示例\" class=\"headerlink\" title=\"应用示例\"></a>应用示例</h2><p>例如，下面将从 0 加到 10_0000_0000：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10_0000_0000L</span>; i++) &#123;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(sum + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>);<span class=\"comment\">// 耗时：361ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 ForkJoinPool 执行该任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ForkJoinPool</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinPool</span>();</span><br><span class=\"line\">    ForkJoinTask&lt;Long&gt; task = <span class=\"keyword\">new</span> <span class=\"title class_\">Task04051</span>(<span class=\"number\">0L</span>, <span class=\"number\">10_0000_0000L</span>);</span><br><span class=\"line\">    ForkJoinTask&lt;Long&gt; submit = pool.submit(task);</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> submit.get();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(result + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>); <span class=\"comment\">// 耗时：186ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用  stream 并行执行任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">\t<span class=\"comment\">// 与 LongStream 类似的有DoubleStream、IntegerStream 等</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> LongStream.rangeClosed(<span class=\"number\">0L</span>, num).parallel().reduce(<span class=\"number\">0</span>, Long::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(sum + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>);<span class=\"comment\">// 耗时：126ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>​        ForkJoinPool 是ExecutorService 接口的实现，它专为可以递归分解成小块的工作而设计。Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务（Runnable）：把一个大任务拆成多个小任务并行处理，最后将子任务结果合并成最后的计算结果。充分利用多线程处理器的优势，提高程序性能。</p>\n<h2 id=\"具有高性能低冲突的原因\"><a href=\"#具有高性能低冲突的原因\" class=\"headerlink\" title=\"具有高性能低冲突的原因\"></a>具有高性能低冲突的原因</h2><ul>\n<li><p>每个Worker线程都维护一个任务队列，即ForkJoinWorkerThread中的任务队列；</p>\n</li>\n<li><p>ForkJoin维护的任务队列是双端队列（DeQueue），可以同时支持LIFO（先进后出）和FIFO（先进先出）；</p>\n</li>\n<li><p>子任务会被加入到原先任务所在 Worker 线程的任务队列；</p>\n</li>\n<li><p>当任务队列为空时，线程会随机从其他的 Worker 的队列中拿走一个任务执行（工作窃取：steal work），工作窃取带来的性能提升偏理论，API的复杂性较高，实际研发中可控性来说不如其他API。</p>\n</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li><p>如果一个 Worker 线程遇到了 join 操作，而这时候正在处理其他任务，会等到这个任务结束。否则直接返回；</p>\n</li>\n<li><p>如果一个 Worker 线程窃取任务失败，它会调用 yield 或者 sleep 之类的方法休息一会儿，再尝试（如果所有线程都是空闲状态，即没有任务执行，那么该线程也会进入阻塞状态等待新任务的到来）；</p>\n</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>使用尽可能少的线程池，在大多数情况下，最好的决定是为每个应用程序或系统使用一个线程池；</p>\n<p>如果不需要特定调整，请使用默认的公共线程池；</p>\n<p>使用合理的阈值将ForkJoinTask拆分为子任务；</p>\n<p>避免在ForkJoinTask中出现任何阻塞（例如耗时IO，大量查询数据库、网络请求等）；</p>\n<p>适合数据处理、结果汇总、统计等场景；</p>\n<p>java8实例：java.utilArrays类用于其 parallelSort() 方法；</p>\n<h2 id=\"应用示例\"><a href=\"#应用示例\" class=\"headerlink\" title=\"应用示例\"></a>应用示例</h2><p>例如，下面将从 0 加到 10_0000_0000：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10_0000_0000L</span>; i++) &#123;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(sum + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>);<span class=\"comment\">// 耗时：361ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 ForkJoinPool 执行该任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ForkJoinPool</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinPool</span>();</span><br><span class=\"line\">    ForkJoinTask&lt;Long&gt; task = <span class=\"keyword\">new</span> <span class=\"title class_\">Task04051</span>(<span class=\"number\">0L</span>, <span class=\"number\">10_0000_0000L</span>);</span><br><span class=\"line\">    ForkJoinTask&lt;Long&gt; submit = pool.submit(task);</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> submit.get();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(result + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>); <span class=\"comment\">// 耗时：186ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用  stream 并行执行任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">\t<span class=\"comment\">// 与 LongStream 类似的有DoubleStream、IntegerStream 等</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> LongStream.rangeClosed(<span class=\"number\">0L</span>, num).parallel().reduce(<span class=\"number\">0</span>, Long::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(sum + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>);<span class=\"comment\">// 耗时：126ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Callable接口","date":"2021-04-10T12:40:00.000Z","comments":0,"description":"线程创建的入口接口之一，可抛异常、可带返回值。例如常用的 FutureTask 的源码中就用到了该接口。","_content":"\n多线程的第三种创建方式，可抛异常、可带返回值。\n\n实现 Callable\\<T\\> 接口创建线程示例：\n\n```java\npublic class ThreadCallable {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        FutureTask<String> futureTask = new FutureTask<>(new MyThread0403());\n        new Thread(futureTask,\"A\").start();\n        String result = futureTask.get();\n        System.out.println(result);\n    }\n}\n// 实现 Callable<T> 接口,T是返回值的类型\nclass MyThread0403 implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        System.out.println(Thread.currentThread().getName()+\"--->Call()\");\n        return \"1024\";\n    }\n}\n```\n\n上面使用的是 Thread 类中的 public Thread(Runnable target, String name) 这个构造函数，只能接收 Runnable 对象，点进FutureTask：\n\n```java\n// 再点进 RunnableFuture\npublic class FutureTask<V> implements RunnableFuture<V> {}\n\n// RunnableFuture接口继承与Runnable，FutureTask间接的实现了Runnable接口\npublic interface RunnableFuture<V> extends Runnable, Future<V> {}\n```\n\nFuture.get() 由于线程执行的call方法中可能会使用耗时操作，所以可能会产生阻塞，一般将该线程放在最后执行，或者使用异步同行来执行","source":"_posts/Java并发 - Callable.md","raw":"---\ntitle: Callable接口\ndate: 2021-04-10 20:40:00\ntags:\n- JUC并发包\ncomments: false\ndescription: 线程创建的入口接口之一，可抛异常、可带返回值。例如常用的 FutureTask 的源码中就用到了该接口。\n---\n\n多线程的第三种创建方式，可抛异常、可带返回值。\n\n实现 Callable\\<T\\> 接口创建线程示例：\n\n```java\npublic class ThreadCallable {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        FutureTask<String> futureTask = new FutureTask<>(new MyThread0403());\n        new Thread(futureTask,\"A\").start();\n        String result = futureTask.get();\n        System.out.println(result);\n    }\n}\n// 实现 Callable<T> 接口,T是返回值的类型\nclass MyThread0403 implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        System.out.println(Thread.currentThread().getName()+\"--->Call()\");\n        return \"1024\";\n    }\n}\n```\n\n上面使用的是 Thread 类中的 public Thread(Runnable target, String name) 这个构造函数，只能接收 Runnable 对象，点进FutureTask：\n\n```java\n// 再点进 RunnableFuture\npublic class FutureTask<V> implements RunnableFuture<V> {}\n\n// RunnableFuture接口继承与Runnable，FutureTask间接的实现了Runnable接口\npublic interface RunnableFuture<V> extends Runnable, Future<V> {}\n```\n\nFuture.get() 由于线程执行的call方法中可能会使用耗时操作，所以可能会产生阻塞，一般将该线程放在最后执行，或者使用异步同行来执行","slug":"Java并发 - Callable","published":1,"updated":"2022-02-28T10:59:26.090Z","layout":"post","photos":[],"link":"","_id":"cl0atbcov00067cu535r99woh","content":"<p>多线程的第三种创建方式，可抛异常、可带返回值。</p>\n<p>实现 Callable&lt;T&gt; 接口创建线程示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadCallable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        FutureTask&lt;String&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyThread0403</span>());</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask,<span class=\"string\">&quot;A&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> futureTask.get();</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 实现 Callable&lt;T&gt; 接口,T是返回值的类型</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread0403</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Callable</span>&lt;String&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;---&gt;Call()&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;1024&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面使用的是 Thread 类中的 public Thread(Runnable target, String name) 这个构造函数，只能接收 Runnable 对象，点进FutureTask：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 再点进 RunnableFuture</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FutureTask</span>&lt;V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">RunnableFuture</span>&lt;V&gt; &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RunnableFuture接口继承与Runnable，FutureTask间接的实现了Runnable接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RunnableFuture</span>&lt;V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Runnable</span>, Future&lt;V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Future.get() 由于线程执行的call方法中可能会使用耗时操作，所以可能会产生阻塞，一般将该线程放在最后执行，或者使用异步同行来执行</p>\n","site":{"data":{}},"excerpt":"","more":"<p>多线程的第三种创建方式，可抛异常、可带返回值。</p>\n<p>实现 Callable&lt;T&gt; 接口创建线程示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadCallable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        FutureTask&lt;String&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyThread0403</span>());</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask,<span class=\"string\">&quot;A&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> futureTask.get();</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 实现 Callable&lt;T&gt; 接口,T是返回值的类型</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread0403</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Callable</span>&lt;String&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;---&gt;Call()&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;1024&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面使用的是 Thread 类中的 public Thread(Runnable target, String name) 这个构造函数，只能接收 Runnable 对象，点进FutureTask：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 再点进 RunnableFuture</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FutureTask</span>&lt;V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">RunnableFuture</span>&lt;V&gt; &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RunnableFuture接口继承与Runnable，FutureTask间接的实现了Runnable接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RunnableFuture</span>&lt;V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Runnable</span>, Future&lt;V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Future.get() 由于线程执行的call方法中可能会使用耗时操作，所以可能会产生阻塞，一般将该线程放在最后执行，或者使用异步同行来执行</p>\n"},{"title":"JMM 内存模型","date":"2021-08-22T04:51:00.000Z","comments":0,"description":"为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。例如：CPU高速缓存。尽可能的避免处理器访问主存的时间开销，处理器大多会利用缓存来提高性能。","_content":"\n# Java并发 - JMM 内存模型\n\n## 一、CPU缓存\n\n### 1、CPU性能优化手段 - 缓存\n\n为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。例如：CPU高速缓存。尽可能的避免处理器访问主存的时间开销，处理器大多会利用缓存来提高性能。\n\n![CPU高速缓存级别](.\\images\\CPU高速缓存级别.png)\n\n**多级缓存**\n\nCPU的缓存分为三个级别，离CPU越远等级越大：\n\n- L1 Cache(一级缓存)是CPU第一层高速缓存，分为**数据缓存**和**指令缓存**。一般服务器CPU的L1缓存容量通常在 32-4096KB（实在是太小了）。\n- L2 Cache(二级缓存) 由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一个高速存储器（由于在外部，有延迟导致速度还是不够快）。\n- L3 现在的都是内置的。L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时的处理器性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为，及较短消息和处理器队列长度。一般是多核共享一个L3缓存。\n\n**缓存的同步协议**\n\n多CPU读取同样的数据进行缓存，进行不同的运算之后，最终写入主内存，那么以哪个CPU为准？\n\n这些 CPU 厂商就制定了一个缓存一致性的协议，就是 MESI协议，规定每条缓存有一个状态位，同时定义了四个状态：\n\n- 修改态(Modified) ：此cache行已被修改过(脏行)，内容已不同于主存，为此cache专有\n\n- 专有态(Exclusive)：此cache行内容同于主存，但不出现于其他cache中；\n\n- 共享态(Shared)：此cache行内容同于主存，但也出现于其他cache中；\n\n- 无效态(Invalid)：此cache行内容无效(空行)；\n\n\n多处理器时，单个CPU对缓存中数据进行了改动，需通知给其他CPU。也就是说，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证数据的**最终一致**。\n\n缓存中的数据与主存的数据并不是实时同步的，各CPU核心间的缓存数据也不是实时同步的。在同一时间点，各个CPU所看到同一内存地址的数据可能是不一致的，就会存在线程安全问题。\n\n### 2、CPU性能优化手段 - 运行时指令重排\n\n指令重排：当CPU**写缓存时**发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的**读缓存命令优先执行**。例如：\n\n![CPU运行时指令重排](.\\images\\CPU运行时指令重排.png)\n\n**重排需要遵循 as-if-serial 语义**：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。也就是说：编译器和处理器**不会对存在数据依赖关系的操作做重排序**。\n\n`as-if-serial语义`把单线程程序保护了起来，换句话说：`as-if-serial语义`仅在单CPU单线程的情况下能保证结果正确。多核多线程中，指令逻辑无法分辨因果关系，可能会出现**乱序执行**，导致程序运行结果错误，就会存在线程安全问题。\n\n## 二、内存屏障\n\n不论是缓存同步还是指令重排，都是线程不安全的。\n\n处理器提供了两个内存屏障指令(Memory Barrier)用于解决缓存同步和指令重排的问题。 \n\n- 读内存屏障(Load Memory Barrier)：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。\n\n- 写内存屏障(Store Memory Barrier)：在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。\n\n## 三、JMM 内存模型\n\n首先，先要了解[JVM分区的概念](./Java并发 - JVM分区与程序运行原理)。在JVM中堆（heap）和方法区是线程共享区域，虚拟机栈、本地方法栈和程序计数器是线程独占部分。虚拟机栈中有多个线程，每个线程对应一个栈帧，每个栈帧中存放有局部变量表、操作数栈、方法返回地址等。线程与线程之间是不能够直接建立沟通的，需要借助于共享区域才来建立沟通。\n\n内存模型的含义：Java编程语言内存模型通过检查执行跟踪中的每个读操作，并根据某些规则检查该读操作观察到的写操作是否有效来工作。只要程序的所有执行产生的结果都可以由内存模型预测。具体的实现者任意实现，包括操作的重新排序和删除不必要的同步。\n\nJMM 内存模型是一种虚拟机的规范，描述程序的可能行为。\n\n1、线程解锁前，必须把共享变量立刻刷回主存。\n\n2、线程加锁前，必须读取主存中的最新值到工作内存中。\n\n3、加锁和解锁是同一把锁。\n\n![JMM](..\\images\\JMM.png)\n\n线程A从主存中读到值flag=true，加载到自己的工作内存中，由执行引擎处理后将值再赋值给工作内存，写入存储过程（存储过程就是把store操作从工作内存中得到的变量放入主存中的操作）。\n\nlock 作用于主内存的变量，把一个变量标识为线程独占状态，unlock 也是作用于主内存的变量，将被锁定的变量释放出来，释放后才能被其它线程锁定。\n\n 问题：Java 内存模型中存在多线程操作变量时，变量被其中一个线程修改后，不能实时修改其它线程正在使用该变量的值，如下例：\n\n```java\npublic static int n = 0;\npublic void test() throws InterruptedException {\n    new Thread(() -> {\n        while (n == 0) {\n        }\n    }, \"A\").start();\n\t\n    // 休眠 1s 后修改n=1，能否停止线程A？\n    Thread.sleep(1000);\n    n = 1;\n    System.out.println(\"线程停止了吗？\");\n}\n```\n\n分析：线程A从主内存中读取到n=0，加载到自己的工作内存，一秒钟后，main线程把n的值改为1后写回主内存，此时A还没有拿到最新的值。所以线程A是不会停止执行的。\n\n解决：当主存中的值发生修改后，应该通知所有操作主存变量的线程。可以使用 volatile 关键字来解决这个问题。\n\n下面对这个问题进行深入分析：\n\n## 线程的可见性问题\n\n缓存引起的可见性问题。当主存中的data发生改变后，其他线程栈中的使用的 data 是不能够及时修改的。\n\n![image-20210412160457763](.\\images\\工作内存缓存结构.png)\n\n指令重排序引起的可见性问题。在Java层面，指令重排序不能够通过 javap 查看出class文件中的重排序，而是发生在运行时的编译器（JIT - Just In Time），将字节码进行重排序编译机器语言（汇编）。\n\n```\n什么是Just In Time编译器?\nJava程序一开始是通过解释器（Interpreter）进行解释执行的。当JVM发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“热点代码（Hot Spot Code）”，然后JVM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为：即时编译器（Just In Time Compiler，JIT）。\nJIT编译器是“动态编译器”的一种，相对的“静态编译器”则是指的比如：C/C++的编译器。\n注意：\nJIT并不是JVM的必须部分，JVM规范并没有规定JIT必须存在，更没有限定和指导JIT。但是，JIT性能的好坏、代码优化程度的高低却是衡量一款JVM是否优秀的最关键指标之一，也是虚拟机中最核心且最能体现虚拟机技术水平的部分。\n```\n\n![image-20210412161108065](.\\images\\指令重排序引起的线程可见性问题.png)\n\n还可能发生等效替换。\n\n![image-20210412161403491](.\\images\\指令重排序中的等效替换.png)\n\n将上面这些代码java.exe 编译成class字节码加载到JVM之后，通过运行时编译器JIT将class字节码转成汇编指令后进行重排序或等效替换。 \n\n在运行时，JVM会根据代码的调用情况进行判断：如果 n=0，那么while(n==0) 就相当于是一个死循环成为热点代码，那么JIT就会认为可以执行成为 if(n==0){while(true){}} 这样的优化，就不会再回去读取 n 的值，相当于执行了一次Java层面的重排序。\n\n```java\n// 刚开始int n = 0;\nwhile (n == 0) {}  被JIT编译器指令重排序为 if(n==0){while(true){}}\n```\n\n如果代码改为加锁的方式，虚拟机对于这种关键的代码段是不会进行优化处理的。\n\n```java\nnew Thread(() -> {\n    while (n == 0) {\n        synchronized(this){\n            add();\n        }\n    }\n}, \"A\").start();\n```\n\n## 线程操作的定义\n\nwrite要写的变量以及要写的值。\nread要读的变量以及可见的写入值(由此，我们可以确定可见的值)。\nlock要锁定的管程(监视器monitor)。\nunlock要解锁的管程。\n外部操作(socket等等..)\n启动和终止\n\n（线程间）程序顺序：如果一个程序没有数据竞争，那么程序的所有执行看起来都是顺序一致的。\n\n## happen—before 先行发生规则\n\nhappen-before是JMM最核心的概念之一。在JMM中如果一个操作的结果需要对另一个线程可见，那么这两个操作之间必须 要存在happens-before规则。\n\n规则内容：\n\n1、程序次序原则：一个线程内，按照程序代码顺序，书写在前面的操作先行发生与书写在后面的操作。\n\n2、监视器锁规则：一个unlock操作先行发生与后面对同一个锁的lock操作者，这里必须指同一个锁，后面指的是时间上的先后顺序。\n\n3、volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样指时间上的先后顺序。\n\n4、线程启动规则：Thread 对象的 start() 方法先行发生于此线程的任意动作。\n\n5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过thread.join方法结束，thread.isAlive的返回值等手段检测到线程已经终止执行。\n\n6、线程中断原则：对线程interrupt方法的调用先行发生于被中断线程的代码监测到中断时间的发生，可以通过interrupt方法检测到是否又中断发生。\n\n7、对象终结规则：一个对象的初始化完成，先行发生于它的finalize方法的开始。\n\n8、传递性：如果A先行发生于B，B先行发生于C，则A先行发生于C。\n\n## final 在JMM中的处理\n\n在下面这个实例中，在read() 方法中，一个变量加了final修饰，一个没加，在多线程的情况下未加final修饰符变量的值，有可能为0，不保证值为构造函数中的赋值。\n\n```java\nclass A {\n    final int x;\n    int y;\n    static A a;\n    \n    public A() {\n        x=3;\n        y=4;\n    }\n    \n    static void write(){\n        a = new A();\n    }\n   \n    static void read(){\n        if(f!=null){\n            int i = a.x; // 肯定是3\n            int j = a.y; // 可能是0\n        }\n    }\n}\n```\n\n读取该共享对象的final成员变量之前，先要读取共享的对象。伪代码示例：r = bew A()；k = r.a 这两个操作不能重排序。\n\n","source":"_posts/Java并发 - JMM 内存模型.md","raw":"---\ntitle: JMM 内存模型\ndate: 2021-08-22 12:51:00\ntags:\n- JUC并发包\ncomments: false\ndescription: 为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。例如：CPU高速缓存。尽可能的避免处理器访问主存的时间开销，处理器大多会利用缓存来提高性能。\n---\n\n# Java并发 - JMM 内存模型\n\n## 一、CPU缓存\n\n### 1、CPU性能优化手段 - 缓存\n\n为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。例如：CPU高速缓存。尽可能的避免处理器访问主存的时间开销，处理器大多会利用缓存来提高性能。\n\n![CPU高速缓存级别](.\\images\\CPU高速缓存级别.png)\n\n**多级缓存**\n\nCPU的缓存分为三个级别，离CPU越远等级越大：\n\n- L1 Cache(一级缓存)是CPU第一层高速缓存，分为**数据缓存**和**指令缓存**。一般服务器CPU的L1缓存容量通常在 32-4096KB（实在是太小了）。\n- L2 Cache(二级缓存) 由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一个高速存储器（由于在外部，有延迟导致速度还是不够快）。\n- L3 现在的都是内置的。L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时的处理器性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为，及较短消息和处理器队列长度。一般是多核共享一个L3缓存。\n\n**缓存的同步协议**\n\n多CPU读取同样的数据进行缓存，进行不同的运算之后，最终写入主内存，那么以哪个CPU为准？\n\n这些 CPU 厂商就制定了一个缓存一致性的协议，就是 MESI协议，规定每条缓存有一个状态位，同时定义了四个状态：\n\n- 修改态(Modified) ：此cache行已被修改过(脏行)，内容已不同于主存，为此cache专有\n\n- 专有态(Exclusive)：此cache行内容同于主存，但不出现于其他cache中；\n\n- 共享态(Shared)：此cache行内容同于主存，但也出现于其他cache中；\n\n- 无效态(Invalid)：此cache行内容无效(空行)；\n\n\n多处理器时，单个CPU对缓存中数据进行了改动，需通知给其他CPU。也就是说，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证数据的**最终一致**。\n\n缓存中的数据与主存的数据并不是实时同步的，各CPU核心间的缓存数据也不是实时同步的。在同一时间点，各个CPU所看到同一内存地址的数据可能是不一致的，就会存在线程安全问题。\n\n### 2、CPU性能优化手段 - 运行时指令重排\n\n指令重排：当CPU**写缓存时**发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的**读缓存命令优先执行**。例如：\n\n![CPU运行时指令重排](.\\images\\CPU运行时指令重排.png)\n\n**重排需要遵循 as-if-serial 语义**：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。也就是说：编译器和处理器**不会对存在数据依赖关系的操作做重排序**。\n\n`as-if-serial语义`把单线程程序保护了起来，换句话说：`as-if-serial语义`仅在单CPU单线程的情况下能保证结果正确。多核多线程中，指令逻辑无法分辨因果关系，可能会出现**乱序执行**，导致程序运行结果错误，就会存在线程安全问题。\n\n## 二、内存屏障\n\n不论是缓存同步还是指令重排，都是线程不安全的。\n\n处理器提供了两个内存屏障指令(Memory Barrier)用于解决缓存同步和指令重排的问题。 \n\n- 读内存屏障(Load Memory Barrier)：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。\n\n- 写内存屏障(Store Memory Barrier)：在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。\n\n## 三、JMM 内存模型\n\n首先，先要了解[JVM分区的概念](./Java并发 - JVM分区与程序运行原理)。在JVM中堆（heap）和方法区是线程共享区域，虚拟机栈、本地方法栈和程序计数器是线程独占部分。虚拟机栈中有多个线程，每个线程对应一个栈帧，每个栈帧中存放有局部变量表、操作数栈、方法返回地址等。线程与线程之间是不能够直接建立沟通的，需要借助于共享区域才来建立沟通。\n\n内存模型的含义：Java编程语言内存模型通过检查执行跟踪中的每个读操作，并根据某些规则检查该读操作观察到的写操作是否有效来工作。只要程序的所有执行产生的结果都可以由内存模型预测。具体的实现者任意实现，包括操作的重新排序和删除不必要的同步。\n\nJMM 内存模型是一种虚拟机的规范，描述程序的可能行为。\n\n1、线程解锁前，必须把共享变量立刻刷回主存。\n\n2、线程加锁前，必须读取主存中的最新值到工作内存中。\n\n3、加锁和解锁是同一把锁。\n\n![JMM](..\\images\\JMM.png)\n\n线程A从主存中读到值flag=true，加载到自己的工作内存中，由执行引擎处理后将值再赋值给工作内存，写入存储过程（存储过程就是把store操作从工作内存中得到的变量放入主存中的操作）。\n\nlock 作用于主内存的变量，把一个变量标识为线程独占状态，unlock 也是作用于主内存的变量，将被锁定的变量释放出来，释放后才能被其它线程锁定。\n\n 问题：Java 内存模型中存在多线程操作变量时，变量被其中一个线程修改后，不能实时修改其它线程正在使用该变量的值，如下例：\n\n```java\npublic static int n = 0;\npublic void test() throws InterruptedException {\n    new Thread(() -> {\n        while (n == 0) {\n        }\n    }, \"A\").start();\n\t\n    // 休眠 1s 后修改n=1，能否停止线程A？\n    Thread.sleep(1000);\n    n = 1;\n    System.out.println(\"线程停止了吗？\");\n}\n```\n\n分析：线程A从主内存中读取到n=0，加载到自己的工作内存，一秒钟后，main线程把n的值改为1后写回主内存，此时A还没有拿到最新的值。所以线程A是不会停止执行的。\n\n解决：当主存中的值发生修改后，应该通知所有操作主存变量的线程。可以使用 volatile 关键字来解决这个问题。\n\n下面对这个问题进行深入分析：\n\n## 线程的可见性问题\n\n缓存引起的可见性问题。当主存中的data发生改变后，其他线程栈中的使用的 data 是不能够及时修改的。\n\n![image-20210412160457763](.\\images\\工作内存缓存结构.png)\n\n指令重排序引起的可见性问题。在Java层面，指令重排序不能够通过 javap 查看出class文件中的重排序，而是发生在运行时的编译器（JIT - Just In Time），将字节码进行重排序编译机器语言（汇编）。\n\n```\n什么是Just In Time编译器?\nJava程序一开始是通过解释器（Interpreter）进行解释执行的。当JVM发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“热点代码（Hot Spot Code）”，然后JVM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为：即时编译器（Just In Time Compiler，JIT）。\nJIT编译器是“动态编译器”的一种，相对的“静态编译器”则是指的比如：C/C++的编译器。\n注意：\nJIT并不是JVM的必须部分，JVM规范并没有规定JIT必须存在，更没有限定和指导JIT。但是，JIT性能的好坏、代码优化程度的高低却是衡量一款JVM是否优秀的最关键指标之一，也是虚拟机中最核心且最能体现虚拟机技术水平的部分。\n```\n\n![image-20210412161108065](.\\images\\指令重排序引起的线程可见性问题.png)\n\n还可能发生等效替换。\n\n![image-20210412161403491](.\\images\\指令重排序中的等效替换.png)\n\n将上面这些代码java.exe 编译成class字节码加载到JVM之后，通过运行时编译器JIT将class字节码转成汇编指令后进行重排序或等效替换。 \n\n在运行时，JVM会根据代码的调用情况进行判断：如果 n=0，那么while(n==0) 就相当于是一个死循环成为热点代码，那么JIT就会认为可以执行成为 if(n==0){while(true){}} 这样的优化，就不会再回去读取 n 的值，相当于执行了一次Java层面的重排序。\n\n```java\n// 刚开始int n = 0;\nwhile (n == 0) {}  被JIT编译器指令重排序为 if(n==0){while(true){}}\n```\n\n如果代码改为加锁的方式，虚拟机对于这种关键的代码段是不会进行优化处理的。\n\n```java\nnew Thread(() -> {\n    while (n == 0) {\n        synchronized(this){\n            add();\n        }\n    }\n}, \"A\").start();\n```\n\n## 线程操作的定义\n\nwrite要写的变量以及要写的值。\nread要读的变量以及可见的写入值(由此，我们可以确定可见的值)。\nlock要锁定的管程(监视器monitor)。\nunlock要解锁的管程。\n外部操作(socket等等..)\n启动和终止\n\n（线程间）程序顺序：如果一个程序没有数据竞争，那么程序的所有执行看起来都是顺序一致的。\n\n## happen—before 先行发生规则\n\nhappen-before是JMM最核心的概念之一。在JMM中如果一个操作的结果需要对另一个线程可见，那么这两个操作之间必须 要存在happens-before规则。\n\n规则内容：\n\n1、程序次序原则：一个线程内，按照程序代码顺序，书写在前面的操作先行发生与书写在后面的操作。\n\n2、监视器锁规则：一个unlock操作先行发生与后面对同一个锁的lock操作者，这里必须指同一个锁，后面指的是时间上的先后顺序。\n\n3、volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样指时间上的先后顺序。\n\n4、线程启动规则：Thread 对象的 start() 方法先行发生于此线程的任意动作。\n\n5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过thread.join方法结束，thread.isAlive的返回值等手段检测到线程已经终止执行。\n\n6、线程中断原则：对线程interrupt方法的调用先行发生于被中断线程的代码监测到中断时间的发生，可以通过interrupt方法检测到是否又中断发生。\n\n7、对象终结规则：一个对象的初始化完成，先行发生于它的finalize方法的开始。\n\n8、传递性：如果A先行发生于B，B先行发生于C，则A先行发生于C。\n\n## final 在JMM中的处理\n\n在下面这个实例中，在read() 方法中，一个变量加了final修饰，一个没加，在多线程的情况下未加final修饰符变量的值，有可能为0，不保证值为构造函数中的赋值。\n\n```java\nclass A {\n    final int x;\n    int y;\n    static A a;\n    \n    public A() {\n        x=3;\n        y=4;\n    }\n    \n    static void write(){\n        a = new A();\n    }\n   \n    static void read(){\n        if(f!=null){\n            int i = a.x; // 肯定是3\n            int j = a.y; // 可能是0\n        }\n    }\n}\n```\n\n读取该共享对象的final成员变量之前，先要读取共享的对象。伪代码示例：r = bew A()；k = r.a 这两个操作不能重排序。\n\n","slug":"Java并发 - JMM 内存模型","published":1,"updated":"2022-03-02T11:27:55.502Z","layout":"post","photos":[],"link":"","_id":"cl0atbcow00077cu570702hny","content":"<h1 id=\"Java并发-JMM-内存模型\"><a href=\"#Java并发-JMM-内存模型\" class=\"headerlink\" title=\"Java并发 - JMM 内存模型\"></a>Java并发 - JMM 内存模型</h1><h2 id=\"一、CPU缓存\"><a href=\"#一、CPU缓存\" class=\"headerlink\" title=\"一、CPU缓存\"></a>一、CPU缓存</h2><h3 id=\"1、CPU性能优化手段-缓存\"><a href=\"#1、CPU性能优化手段-缓存\" class=\"headerlink\" title=\"1、CPU性能优化手段 - 缓存\"></a>1、CPU性能优化手段 - 缓存</h3><p>为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。例如：CPU高速缓存。尽可能的避免处理器访问主存的时间开销，处理器大多会利用缓存来提高性能。</p>\n<p><img src=\"/.%5Cimages%5CCPU%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%BA%A7%E5%88%AB.png\" alt=\"CPU高速缓存级别\"></p>\n<p><strong>多级缓存</strong></p>\n<p>CPU的缓存分为三个级别，离CPU越远等级越大：</p>\n<ul>\n<li>L1 Cache(一级缓存)是CPU第一层高速缓存，分为<strong>数据缓存</strong>和<strong>指令缓存</strong>。一般服务器CPU的L1缓存容量通常在 32-4096KB（实在是太小了）。</li>\n<li>L2 Cache(二级缓存) 由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一个高速存储器（由于在外部，有延迟导致速度还是不够快）。</li>\n<li>L3 现在的都是内置的。L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时的处理器性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为，及较短消息和处理器队列长度。一般是多核共享一个L3缓存。</li>\n</ul>\n<p><strong>缓存的同步协议</strong></p>\n<p>多CPU读取同样的数据进行缓存，进行不同的运算之后，最终写入主内存，那么以哪个CPU为准？</p>\n<p>这些 CPU 厂商就制定了一个缓存一致性的协议，就是 MESI协议，规定每条缓存有一个状态位，同时定义了四个状态：</p>\n<ul>\n<li><p>修改态(Modified) ：此cache行已被修改过(脏行)，内容已不同于主存，为此cache专有</p>\n</li>\n<li><p>专有态(Exclusive)：此cache行内容同于主存，但不出现于其他cache中；</p>\n</li>\n<li><p>共享态(Shared)：此cache行内容同于主存，但也出现于其他cache中；</p>\n</li>\n<li><p>无效态(Invalid)：此cache行内容无效(空行)；</p>\n</li>\n</ul>\n<p>多处理器时，单个CPU对缓存中数据进行了改动，需通知给其他CPU。也就是说，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证数据的<strong>最终一致</strong>。</p>\n<p>缓存中的数据与主存的数据并不是实时同步的，各CPU核心间的缓存数据也不是实时同步的。在同一时间点，各个CPU所看到同一内存地址的数据可能是不一致的，就会存在线程安全问题。</p>\n<h3 id=\"2、CPU性能优化手段-运行时指令重排\"><a href=\"#2、CPU性能优化手段-运行时指令重排\" class=\"headerlink\" title=\"2、CPU性能优化手段 - 运行时指令重排\"></a>2、CPU性能优化手段 - 运行时指令重排</h3><p>指令重排：当CPU<strong>写缓存时</strong>发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的<strong>读缓存命令优先执行</strong>。例如：</p>\n<p><img src=\"/.%5Cimages%5CCPU%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.png\" alt=\"CPU运行时指令重排\"></p>\n<p><strong>重排需要遵循 as-if-serial 语义</strong>：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。也就是说：编译器和处理器<strong>不会对存在数据依赖关系的操作做重排序</strong>。</p>\n<p><code>as-if-serial语义</code>把单线程程序保护了起来，换句话说：<code>as-if-serial语义</code>仅在单CPU单线程的情况下能保证结果正确。多核多线程中，指令逻辑无法分辨因果关系，可能会出现<strong>乱序执行</strong>，导致程序运行结果错误，就会存在线程安全问题。</p>\n<h2 id=\"二、内存屏障\"><a href=\"#二、内存屏障\" class=\"headerlink\" title=\"二、内存屏障\"></a>二、内存屏障</h2><p>不论是缓存同步还是指令重排，都是线程不安全的。</p>\n<p>处理器提供了两个内存屏障指令(Memory Barrier)用于解决缓存同步和指令重排的问题。 </p>\n<ul>\n<li><p>读内存屏障(Load Memory Barrier)：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。</p>\n</li>\n<li><p>写内存屏障(Store Memory Barrier)：在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。</p>\n</li>\n</ul>\n<h2 id=\"三、JMM-内存模型\"><a href=\"#三、JMM-内存模型\" class=\"headerlink\" title=\"三、JMM 内存模型\"></a>三、JMM 内存模型</h2><p>首先，先要了解[JVM分区的概念](./Java并发 - JVM分区与程序运行原理)。在JVM中堆（heap）和方法区是线程共享区域，虚拟机栈、本地方法栈和程序计数器是线程独占部分。虚拟机栈中有多个线程，每个线程对应一个栈帧，每个栈帧中存放有局部变量表、操作数栈、方法返回地址等。线程与线程之间是不能够直接建立沟通的，需要借助于共享区域才来建立沟通。</p>\n<p>内存模型的含义：Java编程语言内存模型通过检查执行跟踪中的每个读操作，并根据某些规则检查该读操作观察到的写操作是否有效来工作。只要程序的所有执行产生的结果都可以由内存模型预测。具体的实现者任意实现，包括操作的重新排序和删除不必要的同步。</p>\n<p>JMM 内存模型是一种虚拟机的规范，描述程序的可能行为。</p>\n<p>1、线程解锁前，必须把共享变量立刻刷回主存。</p>\n<p>2、线程加锁前，必须读取主存中的最新值到工作内存中。</p>\n<p>3、加锁和解锁是同一把锁。</p>\n<p><img src=\"/..%5Cimages%5CJMM.png\" alt=\"JMM\"></p>\n<p>线程A从主存中读到值flag=true，加载到自己的工作内存中，由执行引擎处理后将值再赋值给工作内存，写入存储过程（存储过程就是把store操作从工作内存中得到的变量放入主存中的操作）。</p>\n<p>lock 作用于主内存的变量，把一个变量标识为线程独占状态，unlock 也是作用于主内存的变量，将被锁定的变量释放出来，释放后才能被其它线程锁定。</p>\n<p> 问题：Java 内存模型中存在多线程操作变量时，变量被其中一个线程修改后，不能实时修改其它线程正在使用该变量的值，如下例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;A&quot;</span>).start();</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 休眠 1s 后修改n=1，能否停止线程A？</span></span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    n = <span class=\"number\">1</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;线程停止了吗？&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分析：线程A从主内存中读取到n=0，加载到自己的工作内存，一秒钟后，main线程把n的值改为1后写回主内存，此时A还没有拿到最新的值。所以线程A是不会停止执行的。</p>\n<p>解决：当主存中的值发生修改后，应该通知所有操作主存变量的线程。可以使用 volatile 关键字来解决这个问题。</p>\n<p>下面对这个问题进行深入分析：</p>\n<h2 id=\"线程的可见性问题\"><a href=\"#线程的可见性问题\" class=\"headerlink\" title=\"线程的可见性问题\"></a>线程的可见性问题</h2><p>缓存引起的可见性问题。当主存中的data发生改变后，其他线程栈中的使用的 data 是不能够及时修改的。</p>\n<p><img src=\"/.%5Cimages%5C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84.png\" alt=\"image-20210412160457763\"></p>\n<p>指令重排序引起的可见性问题。在Java层面，指令重排序不能够通过 javap 查看出class文件中的重排序，而是发生在运行时的编译器（JIT - Just In Time），将字节码进行重排序编译机器语言（汇编）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">什么是Just In Time编译器?</span><br><span class=\"line\">Java程序一开始是通过解释器（Interpreter）进行解释执行的。当JVM发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“热点代码（Hot Spot Code）”，然后JVM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为：即时编译器（Just In Time Compiler，JIT）。</span><br><span class=\"line\">JIT编译器是“动态编译器”的一种，相对的“静态编译器”则是指的比如：C/C++的编译器。</span><br><span class=\"line\">注意：</span><br><span class=\"line\">JIT并不是JVM的必须部分，JVM规范并没有规定JIT必须存在，更没有限定和指导JIT。但是，JIT性能的好坏、代码优化程度的高低却是衡量一款JVM是否优秀的最关键指标之一，也是虚拟机中最核心且最能体现虚拟机技术水平的部分。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/.%5Cimages%5C%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98.png\" alt=\"image-20210412161108065\"></p>\n<p>还可能发生等效替换。</p>\n<p><img src=\"/.%5Cimages%5C%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%AD%E7%9A%84%E7%AD%89%E6%95%88%E6%9B%BF%E6%8D%A2.png\" alt=\"image-20210412161403491\"></p>\n<p>将上面这些代码java.exe 编译成class字节码加载到JVM之后，通过运行时编译器JIT将class字节码转成汇编指令后进行重排序或等效替换。 </p>\n<p>在运行时，JVM会根据代码的调用情况进行判断：如果 n=0，那么while(n==0) 就相当于是一个死循环成为热点代码，那么JIT就会认为可以执行成为 if(n==0){while(true){}} 这样的优化，就不会再回去读取 n 的值，相当于执行了一次Java层面的重排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 刚开始int n = 0;</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (n == <span class=\"number\">0</span>) &#123;&#125;  被JIT编译器指令重排序为 <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)&#123;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果代码改为加锁的方式，虚拟机对于这种关键的代码段是不会进行优化处理的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"built_in\">this</span>)&#123;</span><br><span class=\"line\">            add();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;A&quot;</span>).start();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程操作的定义\"><a href=\"#线程操作的定义\" class=\"headerlink\" title=\"线程操作的定义\"></a>线程操作的定义</h2><p>write要写的变量以及要写的值。<br>read要读的变量以及可见的写入值(由此，我们可以确定可见的值)。<br>lock要锁定的管程(监视器monitor)。<br>unlock要解锁的管程。<br>外部操作(socket等等..)<br>启动和终止</p>\n<p>（线程间）程序顺序：如果一个程序没有数据竞争，那么程序的所有执行看起来都是顺序一致的。</p>\n<h2 id=\"happen—before-先行发生规则\"><a href=\"#happen—before-先行发生规则\" class=\"headerlink\" title=\"happen—before 先行发生规则\"></a>happen—before 先行发生规则</h2><p>happen-before是JMM最核心的概念之一。在JMM中如果一个操作的结果需要对另一个线程可见，那么这两个操作之间必须 要存在happens-before规则。</p>\n<p>规则内容：</p>\n<p>1、程序次序原则：一个线程内，按照程序代码顺序，书写在前面的操作先行发生与书写在后面的操作。</p>\n<p>2、监视器锁规则：一个unlock操作先行发生与后面对同一个锁的lock操作者，这里必须指同一个锁，后面指的是时间上的先后顺序。</p>\n<p>3、volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样指时间上的先后顺序。</p>\n<p>4、线程启动规则：Thread 对象的 start() 方法先行发生于此线程的任意动作。</p>\n<p>5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过thread.join方法结束，thread.isAlive的返回值等手段检测到线程已经终止执行。</p>\n<p>6、线程中断原则：对线程interrupt方法的调用先行发生于被中断线程的代码监测到中断时间的发生，可以通过interrupt方法检测到是否又中断发生。</p>\n<p>7、对象终结规则：一个对象的初始化完成，先行发生于它的finalize方法的开始。</p>\n<p>8、传递性：如果A先行发生于B，B先行发生于C，则A先行发生于C。</p>\n<h2 id=\"final-在JMM中的处理\"><a href=\"#final-在JMM中的处理\" class=\"headerlink\" title=\"final 在JMM中的处理\"></a>final 在JMM中的处理</h2><p>在下面这个实例中，在read() 方法中，一个变量加了final修饰，一个没加，在多线程的情况下未加final修饰符变量的值，有可能为0，不保证值为构造函数中的赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">int</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> A a;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">A</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        x=<span class=\"number\">3</span>;</span><br><span class=\"line\">        y=<span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        a = <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> a.x; <span class=\"comment\">// 肯定是3</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> a.y; <span class=\"comment\">// 可能是0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读取该共享对象的final成员变量之前，先要读取共享的对象。伪代码示例：r = bew A()；k = r.a 这两个操作不能重排序。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java并发-JMM-内存模型\"><a href=\"#Java并发-JMM-内存模型\" class=\"headerlink\" title=\"Java并发 - JMM 内存模型\"></a>Java并发 - JMM 内存模型</h1><h2 id=\"一、CPU缓存\"><a href=\"#一、CPU缓存\" class=\"headerlink\" title=\"一、CPU缓存\"></a>一、CPU缓存</h2><h3 id=\"1、CPU性能优化手段-缓存\"><a href=\"#1、CPU性能优化手段-缓存\" class=\"headerlink\" title=\"1、CPU性能优化手段 - 缓存\"></a>1、CPU性能优化手段 - 缓存</h3><p>为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。例如：CPU高速缓存。尽可能的避免处理器访问主存的时间开销，处理器大多会利用缓存来提高性能。</p>\n<p><img src=\"/.%5Cimages%5CCPU%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%BA%A7%E5%88%AB.png\" alt=\"CPU高速缓存级别\"></p>\n<p><strong>多级缓存</strong></p>\n<p>CPU的缓存分为三个级别，离CPU越远等级越大：</p>\n<ul>\n<li>L1 Cache(一级缓存)是CPU第一层高速缓存，分为<strong>数据缓存</strong>和<strong>指令缓存</strong>。一般服务器CPU的L1缓存容量通常在 32-4096KB（实在是太小了）。</li>\n<li>L2 Cache(二级缓存) 由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一个高速存储器（由于在外部，有延迟导致速度还是不够快）。</li>\n<li>L3 现在的都是内置的。L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时的处理器性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为，及较短消息和处理器队列长度。一般是多核共享一个L3缓存。</li>\n</ul>\n<p><strong>缓存的同步协议</strong></p>\n<p>多CPU读取同样的数据进行缓存，进行不同的运算之后，最终写入主内存，那么以哪个CPU为准？</p>\n<p>这些 CPU 厂商就制定了一个缓存一致性的协议，就是 MESI协议，规定每条缓存有一个状态位，同时定义了四个状态：</p>\n<ul>\n<li><p>修改态(Modified) ：此cache行已被修改过(脏行)，内容已不同于主存，为此cache专有</p>\n</li>\n<li><p>专有态(Exclusive)：此cache行内容同于主存，但不出现于其他cache中；</p>\n</li>\n<li><p>共享态(Shared)：此cache行内容同于主存，但也出现于其他cache中；</p>\n</li>\n<li><p>无效态(Invalid)：此cache行内容无效(空行)；</p>\n</li>\n</ul>\n<p>多处理器时，单个CPU对缓存中数据进行了改动，需通知给其他CPU。也就是说，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证数据的<strong>最终一致</strong>。</p>\n<p>缓存中的数据与主存的数据并不是实时同步的，各CPU核心间的缓存数据也不是实时同步的。在同一时间点，各个CPU所看到同一内存地址的数据可能是不一致的，就会存在线程安全问题。</p>\n<h3 id=\"2、CPU性能优化手段-运行时指令重排\"><a href=\"#2、CPU性能优化手段-运行时指令重排\" class=\"headerlink\" title=\"2、CPU性能优化手段 - 运行时指令重排\"></a>2、CPU性能优化手段 - 运行时指令重排</h3><p>指令重排：当CPU<strong>写缓存时</strong>发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的<strong>读缓存命令优先执行</strong>。例如：</p>\n<p><img src=\"/.%5Cimages%5CCPU%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.png\" alt=\"CPU运行时指令重排\"></p>\n<p><strong>重排需要遵循 as-if-serial 语义</strong>：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。也就是说：编译器和处理器<strong>不会对存在数据依赖关系的操作做重排序</strong>。</p>\n<p><code>as-if-serial语义</code>把单线程程序保护了起来，换句话说：<code>as-if-serial语义</code>仅在单CPU单线程的情况下能保证结果正确。多核多线程中，指令逻辑无法分辨因果关系，可能会出现<strong>乱序执行</strong>，导致程序运行结果错误，就会存在线程安全问题。</p>\n<h2 id=\"二、内存屏障\"><a href=\"#二、内存屏障\" class=\"headerlink\" title=\"二、内存屏障\"></a>二、内存屏障</h2><p>不论是缓存同步还是指令重排，都是线程不安全的。</p>\n<p>处理器提供了两个内存屏障指令(Memory Barrier)用于解决缓存同步和指令重排的问题。 </p>\n<ul>\n<li><p>读内存屏障(Load Memory Barrier)：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。</p>\n</li>\n<li><p>写内存屏障(Store Memory Barrier)：在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。</p>\n</li>\n</ul>\n<h2 id=\"三、JMM-内存模型\"><a href=\"#三、JMM-内存模型\" class=\"headerlink\" title=\"三、JMM 内存模型\"></a>三、JMM 内存模型</h2><p>首先，先要了解[JVM分区的概念](./Java并发 - JVM分区与程序运行原理)。在JVM中堆（heap）和方法区是线程共享区域，虚拟机栈、本地方法栈和程序计数器是线程独占部分。虚拟机栈中有多个线程，每个线程对应一个栈帧，每个栈帧中存放有局部变量表、操作数栈、方法返回地址等。线程与线程之间是不能够直接建立沟通的，需要借助于共享区域才来建立沟通。</p>\n<p>内存模型的含义：Java编程语言内存模型通过检查执行跟踪中的每个读操作，并根据某些规则检查该读操作观察到的写操作是否有效来工作。只要程序的所有执行产生的结果都可以由内存模型预测。具体的实现者任意实现，包括操作的重新排序和删除不必要的同步。</p>\n<p>JMM 内存模型是一种虚拟机的规范，描述程序的可能行为。</p>\n<p>1、线程解锁前，必须把共享变量立刻刷回主存。</p>\n<p>2、线程加锁前，必须读取主存中的最新值到工作内存中。</p>\n<p>3、加锁和解锁是同一把锁。</p>\n<p><img src=\"/..%5Cimages%5CJMM.png\" alt=\"JMM\"></p>\n<p>线程A从主存中读到值flag=true，加载到自己的工作内存中，由执行引擎处理后将值再赋值给工作内存，写入存储过程（存储过程就是把store操作从工作内存中得到的变量放入主存中的操作）。</p>\n<p>lock 作用于主内存的变量，把一个变量标识为线程独占状态，unlock 也是作用于主内存的变量，将被锁定的变量释放出来，释放后才能被其它线程锁定。</p>\n<p> 问题：Java 内存模型中存在多线程操作变量时，变量被其中一个线程修改后，不能实时修改其它线程正在使用该变量的值，如下例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;A&quot;</span>).start();</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 休眠 1s 后修改n=1，能否停止线程A？</span></span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    n = <span class=\"number\">1</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;线程停止了吗？&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分析：线程A从主内存中读取到n=0，加载到自己的工作内存，一秒钟后，main线程把n的值改为1后写回主内存，此时A还没有拿到最新的值。所以线程A是不会停止执行的。</p>\n<p>解决：当主存中的值发生修改后，应该通知所有操作主存变量的线程。可以使用 volatile 关键字来解决这个问题。</p>\n<p>下面对这个问题进行深入分析：</p>\n<h2 id=\"线程的可见性问题\"><a href=\"#线程的可见性问题\" class=\"headerlink\" title=\"线程的可见性问题\"></a>线程的可见性问题</h2><p>缓存引起的可见性问题。当主存中的data发生改变后，其他线程栈中的使用的 data 是不能够及时修改的。</p>\n<p><img src=\"/.%5Cimages%5C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84.png\" alt=\"image-20210412160457763\"></p>\n<p>指令重排序引起的可见性问题。在Java层面，指令重排序不能够通过 javap 查看出class文件中的重排序，而是发生在运行时的编译器（JIT - Just In Time），将字节码进行重排序编译机器语言（汇编）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">什么是Just In Time编译器?</span><br><span class=\"line\">Java程序一开始是通过解释器（Interpreter）进行解释执行的。当JVM发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“热点代码（Hot Spot Code）”，然后JVM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为：即时编译器（Just In Time Compiler，JIT）。</span><br><span class=\"line\">JIT编译器是“动态编译器”的一种，相对的“静态编译器”则是指的比如：C/C++的编译器。</span><br><span class=\"line\">注意：</span><br><span class=\"line\">JIT并不是JVM的必须部分，JVM规范并没有规定JIT必须存在，更没有限定和指导JIT。但是，JIT性能的好坏、代码优化程度的高低却是衡量一款JVM是否优秀的最关键指标之一，也是虚拟机中最核心且最能体现虚拟机技术水平的部分。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/.%5Cimages%5C%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E5%BC%95%E8%B5%B7%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98.png\" alt=\"image-20210412161108065\"></p>\n<p>还可能发生等效替换。</p>\n<p><img src=\"/.%5Cimages%5C%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%AD%E7%9A%84%E7%AD%89%E6%95%88%E6%9B%BF%E6%8D%A2.png\" alt=\"image-20210412161403491\"></p>\n<p>将上面这些代码java.exe 编译成class字节码加载到JVM之后，通过运行时编译器JIT将class字节码转成汇编指令后进行重排序或等效替换。 </p>\n<p>在运行时，JVM会根据代码的调用情况进行判断：如果 n=0，那么while(n==0) 就相当于是一个死循环成为热点代码，那么JIT就会认为可以执行成为 if(n==0){while(true){}} 这样的优化，就不会再回去读取 n 的值，相当于执行了一次Java层面的重排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 刚开始int n = 0;</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (n == <span class=\"number\">0</span>) &#123;&#125;  被JIT编译器指令重排序为 <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)&#123;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果代码改为加锁的方式，虚拟机对于这种关键的代码段是不会进行优化处理的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"built_in\">this</span>)&#123;</span><br><span class=\"line\">            add();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;A&quot;</span>).start();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程操作的定义\"><a href=\"#线程操作的定义\" class=\"headerlink\" title=\"线程操作的定义\"></a>线程操作的定义</h2><p>write要写的变量以及要写的值。<br>read要读的变量以及可见的写入值(由此，我们可以确定可见的值)。<br>lock要锁定的管程(监视器monitor)。<br>unlock要解锁的管程。<br>外部操作(socket等等..)<br>启动和终止</p>\n<p>（线程间）程序顺序：如果一个程序没有数据竞争，那么程序的所有执行看起来都是顺序一致的。</p>\n<h2 id=\"happen—before-先行发生规则\"><a href=\"#happen—before-先行发生规则\" class=\"headerlink\" title=\"happen—before 先行发生规则\"></a>happen—before 先行发生规则</h2><p>happen-before是JMM最核心的概念之一。在JMM中如果一个操作的结果需要对另一个线程可见，那么这两个操作之间必须 要存在happens-before规则。</p>\n<p>规则内容：</p>\n<p>1、程序次序原则：一个线程内，按照程序代码顺序，书写在前面的操作先行发生与书写在后面的操作。</p>\n<p>2、监视器锁规则：一个unlock操作先行发生与后面对同一个锁的lock操作者，这里必须指同一个锁，后面指的是时间上的先后顺序。</p>\n<p>3、volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面同样指时间上的先后顺序。</p>\n<p>4、线程启动规则：Thread 对象的 start() 方法先行发生于此线程的任意动作。</p>\n<p>5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过thread.join方法结束，thread.isAlive的返回值等手段检测到线程已经终止执行。</p>\n<p>6、线程中断原则：对线程interrupt方法的调用先行发生于被中断线程的代码监测到中断时间的发生，可以通过interrupt方法检测到是否又中断发生。</p>\n<p>7、对象终结规则：一个对象的初始化完成，先行发生于它的finalize方法的开始。</p>\n<p>8、传递性：如果A先行发生于B，B先行发生于C，则A先行发生于C。</p>\n<h2 id=\"final-在JMM中的处理\"><a href=\"#final-在JMM中的处理\" class=\"headerlink\" title=\"final 在JMM中的处理\"></a>final 在JMM中的处理</h2><p>在下面这个实例中，在read() 方法中，一个变量加了final修饰，一个没加，在多线程的情况下未加final修饰符变量的值，有可能为0，不保证值为构造函数中的赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">int</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> A a;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">A</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        x=<span class=\"number\">3</span>;</span><br><span class=\"line\">        y=<span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        a = <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> a.x; <span class=\"comment\">// 肯定是3</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> a.y; <span class=\"comment\">// 可能是0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读取该共享对象的final成员变量之前，先要读取共享的对象。伪代码示例：r = bew A()；k = r.a 这两个操作不能重排序。</p>\n"},{"title":"四种单例模式","date":"2021-08-22T04:57:00.000Z","comments":0,"_content":"\n其实在学Spring5源码的时候，就已经罗列了各种单例模式。在此，学习过 java.util.concurrent 包后，站在多线程的角度上分析比较经典的懒汉模式的双重锁校验，又称为DCL懒汉式（Double Check Lock）。\n\n1、逐步进阶，基础版本：\n\n```java\nprivate static LazySingleton singleton4;\n\nprivate static LazySingleton lazy() {\n    if (singleton4 == null) {\n        singleton4 = new LazySingleton();\n    }\n    return singleton4;\n}\n```\n\n存在问题分析：多线程进行访问时，可能多个线程会同时进入if 的作用域中，那么就会创建多个 LazySingleton() 对象，导致这些线程返回的对象地址不一致。\n\n2、普通加锁版本\n\n直接方法加锁，确实能够解决问题，但是性能十分低下。\n\n```java\nprivate static LazySingleton singleton4;\n\nprivate synchronized static LazySingleton lazy() {\n    if (singleton4 == null) {\n        singleton4 = new LazySingleton();\n    }\n    return singleton4;\n}\n```\n\n3、双重校验加锁版本\n\n​\t\t多线程都可以进入方法和第一个 if 的作用域，锁类的目的是保证只能有一个线程进入当前类后进入第二个if作用域创建实例对象，随后解锁，让其它进入第一个if作用域的阻塞线程在判断一次是否为空。\n​\t\t虽然性能是提升了，但是真的线程安全吗？并发下的指令重排是会出问题的，分析： singleton4 = new LazySingleton() 不是原子性操作，有三个步骤： ①分配内存空间 ②执行构造方法并实例化对象 ③ 分配内存地址，把这个对象指向这个空间。CPU执行时不一定是按照123执行的，如果按照执行顺序是132，第3步先执行的话，还没有完成实例化，就指向这个空间了，此时的 singleton4 不为空，下一个线程进入方法的第一个if判断走false，直接返回这个对象，此时的这个 singleton4 并没有完成实例化！所以就会导致数据不一致的问题。\n\n​\tvolatile 有三大特性：1、可见性；2、禁止指令重排；3、不保证原子性。所以使用volatile 关键字修饰即可。\n\n```java\nprivate volatile static LazySingleton singleton4;\n\nprivate static LazySingleton lazy2() throws InterruptedException {\n    if (singleton4 == null) {\n        synchronized (LazySingleton.class) {\n            if (singleton4 == null) {\n                singleton4 = new LazySingleton();\n            }\n            return singleton4;\n        }\n    }\n    return singleton4;\n}\n```\n\n4、单例模式被破坏的情况\n\n破坏单例模式的意思就是：一个单例对象存在多个。\n\n反射、序列化、克隆都会破坏单例模式。\n\n解决方案：枚举单例模式、容器式单例模式（ConcurrentHashMap）、线程隔离式单例模式（ThreadLocal）\n\n尝试破坏枚举单例模式：\n\n```java\nprivate enum Lazy4 {\n    INSTANCE;\n\n    public static Lazy4 getInstance() {\n        return INSTANCE;\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n        Lazy4 instance1 = Lazy4.INSTANCE;\n        Constructor<Lazy4> declaredConstructor = Lazy4.class.getDeclaredConstructor(String.class, int.class);\n        declaredConstructor.setAccessible(true);\n        Lazy4 instance2 = declaredConstructor.newInstance(); \n        System.out.println(instance1); System.out.println(instance2);\n    }\n```\n\n","source":"_posts/Java并发 - JUC 单例模式.md","raw":"---\ntitle: 四种单例模式\ndate: 2021-08-22 12:57:00\ntags:\n- JUC并发包\ncomments: false\n---\n\n其实在学Spring5源码的时候，就已经罗列了各种单例模式。在此，学习过 java.util.concurrent 包后，站在多线程的角度上分析比较经典的懒汉模式的双重锁校验，又称为DCL懒汉式（Double Check Lock）。\n\n1、逐步进阶，基础版本：\n\n```java\nprivate static LazySingleton singleton4;\n\nprivate static LazySingleton lazy() {\n    if (singleton4 == null) {\n        singleton4 = new LazySingleton();\n    }\n    return singleton4;\n}\n```\n\n存在问题分析：多线程进行访问时，可能多个线程会同时进入if 的作用域中，那么就会创建多个 LazySingleton() 对象，导致这些线程返回的对象地址不一致。\n\n2、普通加锁版本\n\n直接方法加锁，确实能够解决问题，但是性能十分低下。\n\n```java\nprivate static LazySingleton singleton4;\n\nprivate synchronized static LazySingleton lazy() {\n    if (singleton4 == null) {\n        singleton4 = new LazySingleton();\n    }\n    return singleton4;\n}\n```\n\n3、双重校验加锁版本\n\n​\t\t多线程都可以进入方法和第一个 if 的作用域，锁类的目的是保证只能有一个线程进入当前类后进入第二个if作用域创建实例对象，随后解锁，让其它进入第一个if作用域的阻塞线程在判断一次是否为空。\n​\t\t虽然性能是提升了，但是真的线程安全吗？并发下的指令重排是会出问题的，分析： singleton4 = new LazySingleton() 不是原子性操作，有三个步骤： ①分配内存空间 ②执行构造方法并实例化对象 ③ 分配内存地址，把这个对象指向这个空间。CPU执行时不一定是按照123执行的，如果按照执行顺序是132，第3步先执行的话，还没有完成实例化，就指向这个空间了，此时的 singleton4 不为空，下一个线程进入方法的第一个if判断走false，直接返回这个对象，此时的这个 singleton4 并没有完成实例化！所以就会导致数据不一致的问题。\n\n​\tvolatile 有三大特性：1、可见性；2、禁止指令重排；3、不保证原子性。所以使用volatile 关键字修饰即可。\n\n```java\nprivate volatile static LazySingleton singleton4;\n\nprivate static LazySingleton lazy2() throws InterruptedException {\n    if (singleton4 == null) {\n        synchronized (LazySingleton.class) {\n            if (singleton4 == null) {\n                singleton4 = new LazySingleton();\n            }\n            return singleton4;\n        }\n    }\n    return singleton4;\n}\n```\n\n4、单例模式被破坏的情况\n\n破坏单例模式的意思就是：一个单例对象存在多个。\n\n反射、序列化、克隆都会破坏单例模式。\n\n解决方案：枚举单例模式、容器式单例模式（ConcurrentHashMap）、线程隔离式单例模式（ThreadLocal）\n\n尝试破坏枚举单例模式：\n\n```java\nprivate enum Lazy4 {\n    INSTANCE;\n\n    public static Lazy4 getInstance() {\n        return INSTANCE;\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n        Lazy4 instance1 = Lazy4.INSTANCE;\n        Constructor<Lazy4> declaredConstructor = Lazy4.class.getDeclaredConstructor(String.class, int.class);\n        declaredConstructor.setAccessible(true);\n        Lazy4 instance2 = declaredConstructor.newInstance(); \n        System.out.println(instance1); System.out.println(instance2);\n    }\n```\n\n","slug":"Java并发 - JUC 单例模式","published":1,"updated":"2022-02-28T10:55:46.153Z","layout":"post","photos":[],"link":"","_id":"cl0atbcoy000a7cu56rehhlvz","content":"<p>其实在学Spring5源码的时候，就已经罗列了各种单例模式。在此，学习过 java.util.concurrent 包后，站在多线程的角度上分析比较经典的懒汉模式的双重锁校验，又称为DCL懒汉式（Double Check Lock）。</p>\n<p>1、逐步进阶，基础版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>存在问题分析：多线程进行访问时，可能多个线程会同时进入if 的作用域中，那么就会创建多个 LazySingleton() 对象，导致这些线程返回的对象地址不一致。</p>\n<p>2、普通加锁版本</p>\n<p>直接方法加锁，确实能够解决问题，但是性能十分低下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、双重校验加锁版本</p>\n<p>​        多线程都可以进入方法和第一个 if 的作用域，锁类的目的是保证只能有一个线程进入当前类后进入第二个if作用域创建实例对象，随后解锁，让其它进入第一个if作用域的阻塞线程在判断一次是否为空。<br>​        虽然性能是提升了，但是真的线程安全吗？并发下的指令重排是会出问题的，分析： singleton4 = new LazySingleton() 不是原子性操作，有三个步骤： ①分配内存空间 ②执行构造方法并实例化对象 ③ 分配内存地址，把这个对象指向这个空间。CPU执行时不一定是按照123执行的，如果按照执行顺序是132，第3步先执行的话，还没有完成实例化，就指向这个空间了，此时的 singleton4 不为空，下一个线程进入方法的第一个if判断走false，直接返回这个对象，此时的这个 singleton4 并没有完成实例化！所以就会导致数据不一致的问题。</p>\n<p>​    volatile 有三大特性：1、可见性；2、禁止指令重排；3、不保证原子性。所以使用volatile 关键字修饰即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (LazySingleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、单例模式被破坏的情况</p>\n<p>破坏单例模式的意思就是：一个单例对象存在多个。</p>\n<p>反射、序列化、克隆都会破坏单例模式。</p>\n<p>解决方案：枚举单例模式、容器式单例模式（ConcurrentHashMap）、线程隔离式单例模式（ThreadLocal）</p>\n<p>尝试破坏枚举单例模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Lazy4</span> &#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Lazy4 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Lazy4</span> <span class=\"variable\">instance1</span> <span class=\"operator\">=</span> Lazy4.INSTANCE;</span><br><span class=\"line\">        Constructor&lt;Lazy4&gt; declaredConstructor = Lazy4.class.getDeclaredConstructor(String.class, <span class=\"type\">int</span>.class);</span><br><span class=\"line\">        declaredConstructor.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"type\">Lazy4</span> <span class=\"variable\">instance2</span> <span class=\"operator\">=</span> declaredConstructor.newInstance(); </span><br><span class=\"line\">        System.out.println(instance1); System.out.println(instance2);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>其实在学Spring5源码的时候，就已经罗列了各种单例模式。在此，学习过 java.util.concurrent 包后，站在多线程的角度上分析比较经典的懒汉模式的双重锁校验，又称为DCL懒汉式（Double Check Lock）。</p>\n<p>1、逐步进阶，基础版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>存在问题分析：多线程进行访问时，可能多个线程会同时进入if 的作用域中，那么就会创建多个 LazySingleton() 对象，导致这些线程返回的对象地址不一致。</p>\n<p>2、普通加锁版本</p>\n<p>直接方法加锁，确实能够解决问题，但是性能十分低下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、双重校验加锁版本</p>\n<p>​        多线程都可以进入方法和第一个 if 的作用域，锁类的目的是保证只能有一个线程进入当前类后进入第二个if作用域创建实例对象，随后解锁，让其它进入第一个if作用域的阻塞线程在判断一次是否为空。<br>​        虽然性能是提升了，但是真的线程安全吗？并发下的指令重排是会出问题的，分析： singleton4 = new LazySingleton() 不是原子性操作，有三个步骤： ①分配内存空间 ②执行构造方法并实例化对象 ③ 分配内存地址，把这个对象指向这个空间。CPU执行时不一定是按照123执行的，如果按照执行顺序是132，第3步先执行的话，还没有完成实例化，就指向这个空间了，此时的 singleton4 不为空，下一个线程进入方法的第一个if判断走false，直接返回这个对象，此时的这个 singleton4 并没有完成实例化！所以就会导致数据不一致的问题。</p>\n<p>​    volatile 有三大特性：1、可见性；2、禁止指令重排；3、不保证原子性。所以使用volatile 关键字修饰即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (LazySingleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、单例模式被破坏的情况</p>\n<p>破坏单例模式的意思就是：一个单例对象存在多个。</p>\n<p>反射、序列化、克隆都会破坏单例模式。</p>\n<p>解决方案：枚举单例模式、容器式单例模式（ConcurrentHashMap）、线程隔离式单例模式（ThreadLocal）</p>\n<p>尝试破坏枚举单例模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Lazy4</span> &#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Lazy4 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Lazy4</span> <span class=\"variable\">instance1</span> <span class=\"operator\">=</span> Lazy4.INSTANCE;</span><br><span class=\"line\">        Constructor&lt;Lazy4&gt; declaredConstructor = Lazy4.class.getDeclaredConstructor(String.class, <span class=\"type\">int</span>.class);</span><br><span class=\"line\">        declaredConstructor.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"type\">Lazy4</span> <span class=\"variable\">instance2</span> <span class=\"operator\">=</span> declaredConstructor.newInstance(); </span><br><span class=\"line\">        System.out.println(instance1); System.out.println(instance2);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Queue接口及其实现类","date":"2021-06-03T00:33:00.000Z","comments":0,"_content":"\n​\t\t队列的特点是先进先出，栈的特点是后进先出。Queue继承Collection接口，Stack继承Vector容器类，最顶层接口也是Collection。在Java中容器分为Collection和Map两大类。 Collection家族中除了常见的List、Set，现在又新增一个Queue、Stack。\n\n```java\npublic interface Queue<E> extends Collection<E> {}\n```\n\n### BlockingQueue 的四组API\n\n| 方式         | 抛出异常 | 不抛异常，有返回值 | 阻塞等待 | 超时等待                     |\n| ------------ | -------- | ------------------ | -------- | ---------------------------- |\n| 入队列       | add      | offer              | put      | offer(Element,Time,TimeUnit) |\n| 出队列       | remove   | poll               | take     | poll(,)                      |\n| 返回头部元素 | element  | peek               | -        | -                            |\n\nBlockingQueue主要有两个实现：ArrayBlockingQueue、LinkedBlockingQueue。\n\nBlockingQueue的其中一组核心方法（只介绍其中一组，其它三组类似）：\n\n| 方法名                                  | 描述                                                         |\n| --------------------------------------- | ------------------------------------------------------------ |\n| offer(anObject)                         | 表示如果可以的话，将anObject加到BlockingQueue里，放入成功返回true，否则返回false。 |\n| offer(E o, long timeout, TimeUnit unit) | 可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。 |\n| put(anObject)                           | 把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续。 |\n| poll(time)                              | 取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null。 |\n| poll(long timeout, TimeUnit unit)       | 从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。 |\n| take()                                  | 取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入;。 |\n| drainTo()                               | 一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。 |\n\n在ArrayBlockingQueue中对poll(long timeout, TimeUnit unit) 方法的具体实现：\n\n```java\npublic E poll(long timeout, TimeUnit unit) throws InterruptedException {\n    // 底层统一是以纳秒作为时间的计算单位的\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        // 轮询获取元素出队列\n        while (count == 0) {\n            if (nanos <= 0)\n                return null;\n            nanos = notEmpty.awaitNanos(nanos);\n        }\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n**应用示例**\n\n```java\nBlockingQueue<String> queue = new ArrayBlockingQueue<>(3);\n// 同步队列不存储元素：一个元素进出完成后，下一个元素才能进出。\nBlockingQueue<String> syncQueue = new SynchronousQueue<>();\n/**\n * 抛异常:\n * add()、remove()、element()\n */\npublic void test1() {\n    // ============== add ============= //\n    queue.add(\"1\");\n    queue.add(\"2\");\n    queue.add(\"3\");\n    // 再进一个元素则报错\n    queue.add(\"4\");\n\n    // ============== element ============= //\n    // 检查队首元素（该操作不会出队列）\n    System.out.println(queue.element());\n\n    // ============== remove ============= //\n    System.out.println(queue.remove());\n    System.out.println(queue.remove());\n    System.out.println(queue.remove());\n    // 再取一个\n    System.out.println(queue.remove());\n}\n```\n\n```java\n/**\n * 不抛异常，有返回值\n * offer()、poll()、peek()\n */\npublic void test2() {\n    // ============== offer ============= //\n    queue.offer(\"1\");\n    queue.offer(\"2\");\n    queue.offer(\"3\");\n    // 再添加一个\n    System.out.println(queue.offer(\"4\"));\n\n    // ============== poll ============= //\n    // 检查队首元素（该操作不会出队列）\n    System.out.println(queue.peek());\n\n    // ============== peek ============= //\n    queue.poll();\n    queue.poll();\n    queue.poll();\n    System.out.println(queue.size());\n    // 再取一个\n    System.out.println(queue.poll());\n}\n```\n\n```java\n/**\n * 阻塞等待\n * put、take\n */\npublic void test3() throws InterruptedException {\n    // ============== put ============= //\n    queue.put(\"1\");\n    queue.put(\"2\");\n    queue.put(\"3\");\n    // 再添加一个，阻塞\n    queue.put(\"4\");\n\n    // ============== take ============= //\n    queue.take();\n    queue.take();\n    queue.take();\n    System.out.println(queue.size());\n    // 再取一个，阻塞\n    queue.take();\n}\n```\n\n```java\n/**\n * 超时等待\n * offer、poll\n */\npublic void test4() throws InterruptedException {\n    queue.offer(\"1\");\n    queue.offer(\"2\");\n    queue.offer(\"3\");\n    // 2s后入队列失败\n    System.out.println(queue.offer(\"4\", 2, TimeUnit.SECONDS));\n\n    queue.poll();\n    queue.poll();\n    queue.poll();\n    System.out.println(queue.size());\n    // 2s后出队列失败\n    System.out.println(queue.poll(2, TimeUnit.SECONDS));\n}\n```\n\n### SynchronousQueue\n\n同步队列，不存储元素，一个元素进出完成后，下一个元素才能进出。\n\n```java\n/**\n * 同步队列\n * 创建两个线程：线程一存取三个元素，线程二读取三个元素\n */\npublic void test5() {\n    new Thread(() -> {\n        try {\n            System.out.println(Thread.currentThread().getName() + \" put 1\");\n            syncQueue.put(\"1\");\n            System.out.println(Thread.currentThread().getName() + \" put 2\");\n            syncQueue.put(\"2\");\n            System.out.println(Thread.currentThread().getName() + \" put 3\");\n            syncQueue.put(\"3\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }, \"A\").start();\n\t\n    new Thread(() -> {\n        try {\n            // 等待两秒再取，确保线程1入队列成功\n            TimeUnit.SECONDS.sleep(2);\n            System.out.println(Thread.currentThread().getName() + \"=>\" + syncQueue.take());\n            TimeUnit.SECONDS.sleep(2);\n            System.out.println(Thread.currentThread().getName() + \"=>\" + syncQueue.take());\n            TimeUnit.SECONDS.sleep(2);\n            System.out.println(Thread.currentThread().getName() + \"=>\" + syncQueue.take());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }, \"B\").start();\n}\n```\n\n### PriorityQueue 优先级队列\n\nPriorityQueue是一个带有优先级的队列，而不是先进先出队列，元素按优先级顺序被移除，该队列也没有上限（即 Integer.MAX_VALUE），无容量限制，自动扩容。\n\n此队列虽然没有容量限制，但是会由于服务器资源耗尽抛OutOfMemoryError异常。\n\n如果队列为空，那么取元素的操作take就会阻塞，所以检索操作take是受阻的。\n\n放入PriorityQueue中的元素需要具有比较能力。\n\n```java\npublic class PriorityQueueDemo {\n    public static void main(String[] args) {\n        // 设置比对方式\n        PriorityQueue<String> priorityQueue = new PriorityQueue<>(new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                return 0;\n            }\n        });\n        priorityQueue.add(\"c\");\n        priorityQueue.add(\"a\");\n        priorityQueue.add(\"b\");\n\n        System.out.println(priorityQueue.poll());\n        System.out.println(priorityQueue.poll());\n        System.out.println(priorityQueue.poll());\n\n\t\t// 定义MessageObject存放的优先级\n        PriorityQueue<MessageObject> MessageObjectQueue = new PriorityQueue<>(new Comparator<MessageObject>() {\n            @Override\n            public int compare(MessageObject o1, MessageObject o2) {\n                // Order比较大的MessageObject放后面\n                return o1.order > o2.order ? -1 : 1;\n            }\n        });\n    }\n\n    static class MessageObject {\n        String content;\n        int order;\n    }\n}\n```\n\n下面探寻一下延时队列的实现原理。\n\n```java\npublic class DelayQueue<E extends Delayed> extends AbstractQueue<E>\n    implements BlockingQueue<E> {\n    // 基于PriorityQueue来实现的延时队列\n    private final PriorityQueue<E> q = new PriorityQueue<E>();\n    ...\n}\n```\n\nDelayQueue的泛型必须实现Delayed接口。\n\n```java\npublic interface Delayed extends Comparable<Delayed> {\n    /**\n     * Returns the remaining delay associated with this object, in the\n     * given time unit.\n     * 这个元素需要在队列中待多久时间\n     \n     * @param unit the time unit\n     * @return the remaining delay; zero or negative values indicate\n     * that the delay has already elapsed\n     */\n    long getDelay(TimeUnit unit);\n}\n```\n\n**应用示例**\n\n线程池中的定时调度就是使用这样的方法实现的。\n\n```java\npublic class DelayQueueDemo {\n    public static void main(String[] args) throws InterruptedException {\n        DelayQueue<Message> delayQueue = new DelayQueue<Message>();\n        // 这条消息5秒后发送\n        Message message = new Message(\"message - 00001\", new Date(System.currentTimeMillis() + 5000L));\n        delayQueue.add(message);\n\n        while (true) {\n            System.out.println(delayQueue.poll());\n            Thread.sleep(1000L);\n        }\n    }\n\n    // 实现Delayed接口的元素才能存到DelayQueue\n    static class Message implements Delayed {\n        String content;\n        Date sendTime;\n\n        /**\n         * @param content  消息内容\n         * @param sendTime 定时发送\n         */\n        public Message(String content, Date sendTime) {\n            this.content = content;\n            this.sendTime = sendTime;\n        }\n\n        /**\n         * 判断当前这个元素是不是已经到了需要被拿出来的时间\n         */\n        @Override\n        public long getDelay(TimeUnit unit) {\n            long duration = sendTime.getTime() - System.currentTimeMillis();\n            return TimeUnit.NANOSECONDS.convert(duration, TimeUnit.MILLISECONDS);\n        }\n\n        @Override\n        public int compareTo(Delayed o) {\n            return o.getDelay(TimeUnit.NANOSECONDS) > this.getDelay(TimeUnit.NANOSECONDS) ? 1 : -1;\n        }\n    }\n}\n```\n\n","source":"_posts/Java并发 - Queue.md","raw":"---\ntitle: Queue接口及其实现类\ndate: 2021-06-03 8:33:00\ntags:\n  - JUC并发包\ncomments: false\n---\n\n​\t\t队列的特点是先进先出，栈的特点是后进先出。Queue继承Collection接口，Stack继承Vector容器类，最顶层接口也是Collection。在Java中容器分为Collection和Map两大类。 Collection家族中除了常见的List、Set，现在又新增一个Queue、Stack。\n\n```java\npublic interface Queue<E> extends Collection<E> {}\n```\n\n### BlockingQueue 的四组API\n\n| 方式         | 抛出异常 | 不抛异常，有返回值 | 阻塞等待 | 超时等待                     |\n| ------------ | -------- | ------------------ | -------- | ---------------------------- |\n| 入队列       | add      | offer              | put      | offer(Element,Time,TimeUnit) |\n| 出队列       | remove   | poll               | take     | poll(,)                      |\n| 返回头部元素 | element  | peek               | -        | -                            |\n\nBlockingQueue主要有两个实现：ArrayBlockingQueue、LinkedBlockingQueue。\n\nBlockingQueue的其中一组核心方法（只介绍其中一组，其它三组类似）：\n\n| 方法名                                  | 描述                                                         |\n| --------------------------------------- | ------------------------------------------------------------ |\n| offer(anObject)                         | 表示如果可以的话，将anObject加到BlockingQueue里，放入成功返回true，否则返回false。 |\n| offer(E o, long timeout, TimeUnit unit) | 可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。 |\n| put(anObject)                           | 把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续。 |\n| poll(time)                              | 取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null。 |\n| poll(long timeout, TimeUnit unit)       | 从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。 |\n| take()                                  | 取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入;。 |\n| drainTo()                               | 一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。 |\n\n在ArrayBlockingQueue中对poll(long timeout, TimeUnit unit) 方法的具体实现：\n\n```java\npublic E poll(long timeout, TimeUnit unit) throws InterruptedException {\n    // 底层统一是以纳秒作为时间的计算单位的\n    long nanos = unit.toNanos(timeout);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        // 轮询获取元素出队列\n        while (count == 0) {\n            if (nanos <= 0)\n                return null;\n            nanos = notEmpty.awaitNanos(nanos);\n        }\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n**应用示例**\n\n```java\nBlockingQueue<String> queue = new ArrayBlockingQueue<>(3);\n// 同步队列不存储元素：一个元素进出完成后，下一个元素才能进出。\nBlockingQueue<String> syncQueue = new SynchronousQueue<>();\n/**\n * 抛异常:\n * add()、remove()、element()\n */\npublic void test1() {\n    // ============== add ============= //\n    queue.add(\"1\");\n    queue.add(\"2\");\n    queue.add(\"3\");\n    // 再进一个元素则报错\n    queue.add(\"4\");\n\n    // ============== element ============= //\n    // 检查队首元素（该操作不会出队列）\n    System.out.println(queue.element());\n\n    // ============== remove ============= //\n    System.out.println(queue.remove());\n    System.out.println(queue.remove());\n    System.out.println(queue.remove());\n    // 再取一个\n    System.out.println(queue.remove());\n}\n```\n\n```java\n/**\n * 不抛异常，有返回值\n * offer()、poll()、peek()\n */\npublic void test2() {\n    // ============== offer ============= //\n    queue.offer(\"1\");\n    queue.offer(\"2\");\n    queue.offer(\"3\");\n    // 再添加一个\n    System.out.println(queue.offer(\"4\"));\n\n    // ============== poll ============= //\n    // 检查队首元素（该操作不会出队列）\n    System.out.println(queue.peek());\n\n    // ============== peek ============= //\n    queue.poll();\n    queue.poll();\n    queue.poll();\n    System.out.println(queue.size());\n    // 再取一个\n    System.out.println(queue.poll());\n}\n```\n\n```java\n/**\n * 阻塞等待\n * put、take\n */\npublic void test3() throws InterruptedException {\n    // ============== put ============= //\n    queue.put(\"1\");\n    queue.put(\"2\");\n    queue.put(\"3\");\n    // 再添加一个，阻塞\n    queue.put(\"4\");\n\n    // ============== take ============= //\n    queue.take();\n    queue.take();\n    queue.take();\n    System.out.println(queue.size());\n    // 再取一个，阻塞\n    queue.take();\n}\n```\n\n```java\n/**\n * 超时等待\n * offer、poll\n */\npublic void test4() throws InterruptedException {\n    queue.offer(\"1\");\n    queue.offer(\"2\");\n    queue.offer(\"3\");\n    // 2s后入队列失败\n    System.out.println(queue.offer(\"4\", 2, TimeUnit.SECONDS));\n\n    queue.poll();\n    queue.poll();\n    queue.poll();\n    System.out.println(queue.size());\n    // 2s后出队列失败\n    System.out.println(queue.poll(2, TimeUnit.SECONDS));\n}\n```\n\n### SynchronousQueue\n\n同步队列，不存储元素，一个元素进出完成后，下一个元素才能进出。\n\n```java\n/**\n * 同步队列\n * 创建两个线程：线程一存取三个元素，线程二读取三个元素\n */\npublic void test5() {\n    new Thread(() -> {\n        try {\n            System.out.println(Thread.currentThread().getName() + \" put 1\");\n            syncQueue.put(\"1\");\n            System.out.println(Thread.currentThread().getName() + \" put 2\");\n            syncQueue.put(\"2\");\n            System.out.println(Thread.currentThread().getName() + \" put 3\");\n            syncQueue.put(\"3\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }, \"A\").start();\n\t\n    new Thread(() -> {\n        try {\n            // 等待两秒再取，确保线程1入队列成功\n            TimeUnit.SECONDS.sleep(2);\n            System.out.println(Thread.currentThread().getName() + \"=>\" + syncQueue.take());\n            TimeUnit.SECONDS.sleep(2);\n            System.out.println(Thread.currentThread().getName() + \"=>\" + syncQueue.take());\n            TimeUnit.SECONDS.sleep(2);\n            System.out.println(Thread.currentThread().getName() + \"=>\" + syncQueue.take());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }, \"B\").start();\n}\n```\n\n### PriorityQueue 优先级队列\n\nPriorityQueue是一个带有优先级的队列，而不是先进先出队列，元素按优先级顺序被移除，该队列也没有上限（即 Integer.MAX_VALUE），无容量限制，自动扩容。\n\n此队列虽然没有容量限制，但是会由于服务器资源耗尽抛OutOfMemoryError异常。\n\n如果队列为空，那么取元素的操作take就会阻塞，所以检索操作take是受阻的。\n\n放入PriorityQueue中的元素需要具有比较能力。\n\n```java\npublic class PriorityQueueDemo {\n    public static void main(String[] args) {\n        // 设置比对方式\n        PriorityQueue<String> priorityQueue = new PriorityQueue<>(new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                return 0;\n            }\n        });\n        priorityQueue.add(\"c\");\n        priorityQueue.add(\"a\");\n        priorityQueue.add(\"b\");\n\n        System.out.println(priorityQueue.poll());\n        System.out.println(priorityQueue.poll());\n        System.out.println(priorityQueue.poll());\n\n\t\t// 定义MessageObject存放的优先级\n        PriorityQueue<MessageObject> MessageObjectQueue = new PriorityQueue<>(new Comparator<MessageObject>() {\n            @Override\n            public int compare(MessageObject o1, MessageObject o2) {\n                // Order比较大的MessageObject放后面\n                return o1.order > o2.order ? -1 : 1;\n            }\n        });\n    }\n\n    static class MessageObject {\n        String content;\n        int order;\n    }\n}\n```\n\n下面探寻一下延时队列的实现原理。\n\n```java\npublic class DelayQueue<E extends Delayed> extends AbstractQueue<E>\n    implements BlockingQueue<E> {\n    // 基于PriorityQueue来实现的延时队列\n    private final PriorityQueue<E> q = new PriorityQueue<E>();\n    ...\n}\n```\n\nDelayQueue的泛型必须实现Delayed接口。\n\n```java\npublic interface Delayed extends Comparable<Delayed> {\n    /**\n     * Returns the remaining delay associated with this object, in the\n     * given time unit.\n     * 这个元素需要在队列中待多久时间\n     \n     * @param unit the time unit\n     * @return the remaining delay; zero or negative values indicate\n     * that the delay has already elapsed\n     */\n    long getDelay(TimeUnit unit);\n}\n```\n\n**应用示例**\n\n线程池中的定时调度就是使用这样的方法实现的。\n\n```java\npublic class DelayQueueDemo {\n    public static void main(String[] args) throws InterruptedException {\n        DelayQueue<Message> delayQueue = new DelayQueue<Message>();\n        // 这条消息5秒后发送\n        Message message = new Message(\"message - 00001\", new Date(System.currentTimeMillis() + 5000L));\n        delayQueue.add(message);\n\n        while (true) {\n            System.out.println(delayQueue.poll());\n            Thread.sleep(1000L);\n        }\n    }\n\n    // 实现Delayed接口的元素才能存到DelayQueue\n    static class Message implements Delayed {\n        String content;\n        Date sendTime;\n\n        /**\n         * @param content  消息内容\n         * @param sendTime 定时发送\n         */\n        public Message(String content, Date sendTime) {\n            this.content = content;\n            this.sendTime = sendTime;\n        }\n\n        /**\n         * 判断当前这个元素是不是已经到了需要被拿出来的时间\n         */\n        @Override\n        public long getDelay(TimeUnit unit) {\n            long duration = sendTime.getTime() - System.currentTimeMillis();\n            return TimeUnit.NANOSECONDS.convert(duration, TimeUnit.MILLISECONDS);\n        }\n\n        @Override\n        public int compareTo(Delayed o) {\n            return o.getDelay(TimeUnit.NANOSECONDS) > this.getDelay(TimeUnit.NANOSECONDS) ? 1 : -1;\n        }\n    }\n}\n```\n\n","slug":"Java并发 - Queue","published":1,"updated":"2022-02-28T10:50:19.795Z","layout":"post","photos":[],"link":"","_id":"cl0atbcoz000c7cu533rz77ld","content":"<p>​        队列的特点是先进先出，栈的特点是后进先出。Queue继承Collection接口，Stack继承Vector容器类，最顶层接口也是Collection。在Java中容器分为Collection和Map两大类。 Collection家族中除了常见的List、Set，现在又新增一个Queue、Stack。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Queue</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Collection</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BlockingQueue-的四组API\"><a href=\"#BlockingQueue-的四组API\" class=\"headerlink\" title=\"BlockingQueue 的四组API\"></a>BlockingQueue 的四组API</h3><table>\n<thead>\n<tr>\n<th>方式</th>\n<th>抛出异常</th>\n<th>不抛异常，有返回值</th>\n<th>阻塞等待</th>\n<th>超时等待</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>入队列</td>\n<td>add</td>\n<td>offer</td>\n<td>put</td>\n<td>offer(Element,Time,TimeUnit)</td>\n</tr>\n<tr>\n<td>出队列</td>\n<td>remove</td>\n<td>poll</td>\n<td>take</td>\n<td>poll(,)</td>\n</tr>\n<tr>\n<td>返回头部元素</td>\n<td>element</td>\n<td>peek</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<p>BlockingQueue主要有两个实现：ArrayBlockingQueue、LinkedBlockingQueue。</p>\n<p>BlockingQueue的其中一组核心方法（只介绍其中一组，其它三组类似）：</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>offer(anObject)</td>\n<td>表示如果可以的话，将anObject加到BlockingQueue里，放入成功返回true，否则返回false。</td>\n</tr>\n<tr>\n<td>offer(E o, long timeout, TimeUnit unit)</td>\n<td>可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。</td>\n</tr>\n<tr>\n<td>put(anObject)</td>\n<td>把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续。</td>\n</tr>\n<tr>\n<td>poll(time)</td>\n<td>取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null。</td>\n</tr>\n<tr>\n<td>poll(long timeout, TimeUnit unit)</td>\n<td>从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。</td>\n</tr>\n<tr>\n<td>take()</td>\n<td>取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入;。</td>\n</tr>\n<tr>\n<td>drainTo()</td>\n<td>一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</td>\n</tr>\n</tbody></table>\n<p>在ArrayBlockingQueue中对poll(long timeout, TimeUnit unit) 方法的具体实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">poll</span><span class=\"params\">(<span class=\"type\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 底层统一是以纳秒作为时间的计算单位的</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">nanos</span> <span class=\"operator\">=</span> unit.toNanos(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.lock;</span><br><span class=\"line\">    lock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 轮询获取元素出队列</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dequeue();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>应用示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlockingQueue&lt;String&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBlockingQueue</span>&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 同步队列不存储元素：一个元素进出完成后，下一个元素才能进出。</span></span><br><span class=\"line\">BlockingQueue&lt;String&gt; syncQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">SynchronousQueue</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 抛异常:</span></span><br><span class=\"line\"><span class=\"comment\"> * add()、remove()、element()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ============== add ============= //</span></span><br><span class=\"line\">    queue.add(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    queue.add(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    queue.add(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 再进一个元素则报错</span></span><br><span class=\"line\">    queue.add(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============== element ============= //</span></span><br><span class=\"line\">    <span class=\"comment\">// 检查队首元素（该操作不会出队列）</span></span><br><span class=\"line\">    System.out.println(queue.element());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============== remove ============= //</span></span><br><span class=\"line\">    System.out.println(queue.remove());</span><br><span class=\"line\">    System.out.println(queue.remove());</span><br><span class=\"line\">    System.out.println(queue.remove());</span><br><span class=\"line\">    <span class=\"comment\">// 再取一个</span></span><br><span class=\"line\">    System.out.println(queue.remove());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 不抛异常，有返回值</span></span><br><span class=\"line\"><span class=\"comment\"> * offer()、poll()、peek()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ============== offer ============= //</span></span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 再添加一个</span></span><br><span class=\"line\">    System.out.println(queue.offer(<span class=\"string\">&quot;4&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============== poll ============= //</span></span><br><span class=\"line\">    <span class=\"comment\">// 检查队首元素（该操作不会出队列）</span></span><br><span class=\"line\">    System.out.println(queue.peek());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============== peek ============= //</span></span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    System.out.println(queue.size());</span><br><span class=\"line\">    <span class=\"comment\">// 再取一个</span></span><br><span class=\"line\">    System.out.println(queue.poll());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 阻塞等待</span></span><br><span class=\"line\"><span class=\"comment\"> * put、take</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ============== put ============= //</span></span><br><span class=\"line\">    queue.put(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    queue.put(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    queue.put(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 再添加一个，阻塞</span></span><br><span class=\"line\">    queue.put(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============== take ============= //</span></span><br><span class=\"line\">    queue.take();</span><br><span class=\"line\">    queue.take();</span><br><span class=\"line\">    queue.take();</span><br><span class=\"line\">    System.out.println(queue.size());</span><br><span class=\"line\">    <span class=\"comment\">// 再取一个，阻塞</span></span><br><span class=\"line\">    queue.take();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 超时等待</span></span><br><span class=\"line\"><span class=\"comment\"> * offer、poll</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2s后入队列失败</span></span><br><span class=\"line\">    System.out.println(queue.offer(<span class=\"string\">&quot;4&quot;</span>, <span class=\"number\">2</span>, TimeUnit.SECONDS));</span><br><span class=\"line\"></span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    System.out.println(queue.size());</span><br><span class=\"line\">    <span class=\"comment\">// 2s后出队列失败</span></span><br><span class=\"line\">    System.out.println(queue.poll(<span class=\"number\">2</span>, TimeUnit.SECONDS));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a>SynchronousQueue</h3><p>同步队列，不存储元素，一个元素进出完成后，下一个元素才能进出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 同步队列</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建两个线程：线程一存取三个元素，线程二读取三个元素</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; put 1&quot;</span>);</span><br><span class=\"line\">            syncQueue.put(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; put 2&quot;</span>);</span><br><span class=\"line\">            syncQueue.put(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; put 3&quot;</span>);</span><br><span class=\"line\">            syncQueue.put(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;A&quot;</span>).start();</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等待两秒再取，确保线程1入队列成功</span></span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;=&gt;&quot;</span> + syncQueue.take());</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;=&gt;&quot;</span> + syncQueue.take());</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;=&gt;&quot;</span> + syncQueue.take());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;B&quot;</span>).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PriorityQueue-优先级队列\"><a href=\"#PriorityQueue-优先级队列\" class=\"headerlink\" title=\"PriorityQueue 优先级队列\"></a>PriorityQueue 优先级队列</h3><p>PriorityQueue是一个带有优先级的队列，而不是先进先出队列，元素按优先级顺序被移除，该队列也没有上限（即 Integer.MAX_VALUE），无容量限制，自动扩容。</p>\n<p>此队列虽然没有容量限制，但是会由于服务器资源耗尽抛OutOfMemoryError异常。</p>\n<p>如果队列为空，那么取元素的操作take就会阻塞，所以检索操作take是受阻的。</p>\n<p>放入PriorityQueue中的元素需要具有比较能力。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PriorityQueueDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置比对方式</span></span><br><span class=\"line\">        PriorityQueue&lt;String&gt; priorityQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(String o1, String o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        priorityQueue.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">        priorityQueue.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        priorityQueue.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(priorityQueue.poll());</span><br><span class=\"line\">        System.out.println(priorityQueue.poll());</span><br><span class=\"line\">        System.out.println(priorityQueue.poll());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 定义MessageObject存放的优先级</span></span><br><span class=\"line\">        PriorityQueue&lt;MessageObject&gt; MessageObjectQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;MessageObject&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(MessageObject o1, MessageObject o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Order比较大的MessageObject放后面</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> o1.order &gt; o2.order ? -<span class=\"number\">1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageObject</span> &#123;</span><br><span class=\"line\">        String content;</span><br><span class=\"line\">        <span class=\"type\">int</span> order;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面探寻一下延时队列的实现原理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DelayQueue</span>&lt;E <span class=\"keyword\">extends</span> <span class=\"title class_\">Delayed</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractQueue</span>&lt;E&gt;</span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基于PriorityQueue来实现的延时队列</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityQueue&lt;E&gt; q = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;E&gt;();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>DelayQueue的泛型必须实现Delayed接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Delayed</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Comparable</span>&lt;Delayed&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the remaining delay associated with this object, in the</span></span><br><span class=\"line\"><span class=\"comment\">     * given time unit.</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个元素需要在队列中待多久时间</span></span><br><span class=\"line\"><span class=\"comment\">     </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit the time unit</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the remaining delay; zero or negative values indicate</span></span><br><span class=\"line\"><span class=\"comment\">     * that the delay has already elapsed</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">getDelay</span><span class=\"params\">(TimeUnit unit)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>应用示例</strong></p>\n<p>线程池中的定时调度就是使用这样的方法实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DelayQueueDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        DelayQueue&lt;Message&gt; delayQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">DelayQueue</span>&lt;Message&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 这条消息5秒后发送</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Message</span>(<span class=\"string\">&quot;message - 00001&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(System.currentTimeMillis() + <span class=\"number\">5000L</span>));</span><br><span class=\"line\">        delayQueue.add(message);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            System.out.println(delayQueue.poll());</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000L</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现Delayed接口的元素才能存到DelayQueue</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Delayed</span> &#123;</span><br><span class=\"line\">        String content;</span><br><span class=\"line\">        Date sendTime;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> content  消息内容</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> sendTime 定时发送</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Message</span><span class=\"params\">(String content, Date sendTime)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.content = content;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sendTime = sendTime;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 判断当前这个元素是不是已经到了需要被拿出来的时间</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getDelay</span><span class=\"params\">(TimeUnit unit)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">duration</span> <span class=\"operator\">=</span> sendTime.getTime() - System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> TimeUnit.NANOSECONDS.convert(duration, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compareTo</span><span class=\"params\">(Delayed o)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o.getDelay(TimeUnit.NANOSECONDS) &gt; <span class=\"built_in\">this</span>.getDelay(TimeUnit.NANOSECONDS) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>​        队列的特点是先进先出，栈的特点是后进先出。Queue继承Collection接口，Stack继承Vector容器类，最顶层接口也是Collection。在Java中容器分为Collection和Map两大类。 Collection家族中除了常见的List、Set，现在又新增一个Queue、Stack。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Queue</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Collection</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BlockingQueue-的四组API\"><a href=\"#BlockingQueue-的四组API\" class=\"headerlink\" title=\"BlockingQueue 的四组API\"></a>BlockingQueue 的四组API</h3><table>\n<thead>\n<tr>\n<th>方式</th>\n<th>抛出异常</th>\n<th>不抛异常，有返回值</th>\n<th>阻塞等待</th>\n<th>超时等待</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>入队列</td>\n<td>add</td>\n<td>offer</td>\n<td>put</td>\n<td>offer(Element,Time,TimeUnit)</td>\n</tr>\n<tr>\n<td>出队列</td>\n<td>remove</td>\n<td>poll</td>\n<td>take</td>\n<td>poll(,)</td>\n</tr>\n<tr>\n<td>返回头部元素</td>\n<td>element</td>\n<td>peek</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<p>BlockingQueue主要有两个实现：ArrayBlockingQueue、LinkedBlockingQueue。</p>\n<p>BlockingQueue的其中一组核心方法（只介绍其中一组，其它三组类似）：</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>offer(anObject)</td>\n<td>表示如果可以的话，将anObject加到BlockingQueue里，放入成功返回true，否则返回false。</td>\n</tr>\n<tr>\n<td>offer(E o, long timeout, TimeUnit unit)</td>\n<td>可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。</td>\n</tr>\n<tr>\n<td>put(anObject)</td>\n<td>把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续。</td>\n</tr>\n<tr>\n<td>poll(time)</td>\n<td>取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null。</td>\n</tr>\n<tr>\n<td>poll(long timeout, TimeUnit unit)</td>\n<td>从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。</td>\n</tr>\n<tr>\n<td>take()</td>\n<td>取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入;。</td>\n</tr>\n<tr>\n<td>drainTo()</td>\n<td>一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</td>\n</tr>\n</tbody></table>\n<p>在ArrayBlockingQueue中对poll(long timeout, TimeUnit unit) 方法的具体实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">poll</span><span class=\"params\">(<span class=\"type\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 底层统一是以纳秒作为时间的计算单位的</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">nanos</span> <span class=\"operator\">=</span> unit.toNanos(timeout);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.lock;</span><br><span class=\"line\">    lock.lockInterruptibly();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 轮询获取元素出队列</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dequeue();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>应用示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BlockingQueue&lt;String&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBlockingQueue</span>&lt;&gt;(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 同步队列不存储元素：一个元素进出完成后，下一个元素才能进出。</span></span><br><span class=\"line\">BlockingQueue&lt;String&gt; syncQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">SynchronousQueue</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 抛异常:</span></span><br><span class=\"line\"><span class=\"comment\"> * add()、remove()、element()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ============== add ============= //</span></span><br><span class=\"line\">    queue.add(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    queue.add(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    queue.add(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 再进一个元素则报错</span></span><br><span class=\"line\">    queue.add(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============== element ============= //</span></span><br><span class=\"line\">    <span class=\"comment\">// 检查队首元素（该操作不会出队列）</span></span><br><span class=\"line\">    System.out.println(queue.element());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============== remove ============= //</span></span><br><span class=\"line\">    System.out.println(queue.remove());</span><br><span class=\"line\">    System.out.println(queue.remove());</span><br><span class=\"line\">    System.out.println(queue.remove());</span><br><span class=\"line\">    <span class=\"comment\">// 再取一个</span></span><br><span class=\"line\">    System.out.println(queue.remove());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 不抛异常，有返回值</span></span><br><span class=\"line\"><span class=\"comment\"> * offer()、poll()、peek()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ============== offer ============= //</span></span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 再添加一个</span></span><br><span class=\"line\">    System.out.println(queue.offer(<span class=\"string\">&quot;4&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============== poll ============= //</span></span><br><span class=\"line\">    <span class=\"comment\">// 检查队首元素（该操作不会出队列）</span></span><br><span class=\"line\">    System.out.println(queue.peek());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============== peek ============= //</span></span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    System.out.println(queue.size());</span><br><span class=\"line\">    <span class=\"comment\">// 再取一个</span></span><br><span class=\"line\">    System.out.println(queue.poll());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 阻塞等待</span></span><br><span class=\"line\"><span class=\"comment\"> * put、take</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ============== put ============= //</span></span><br><span class=\"line\">    queue.put(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    queue.put(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    queue.put(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 再添加一个，阻塞</span></span><br><span class=\"line\">    queue.put(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ============== take ============= //</span></span><br><span class=\"line\">    queue.take();</span><br><span class=\"line\">    queue.take();</span><br><span class=\"line\">    queue.take();</span><br><span class=\"line\">    System.out.println(queue.size());</span><br><span class=\"line\">    <span class=\"comment\">// 再取一个，阻塞</span></span><br><span class=\"line\">    queue.take();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 超时等待</span></span><br><span class=\"line\"><span class=\"comment\"> * offer、poll</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test4</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">    queue.offer(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2s后入队列失败</span></span><br><span class=\"line\">    System.out.println(queue.offer(<span class=\"string\">&quot;4&quot;</span>, <span class=\"number\">2</span>, TimeUnit.SECONDS));</span><br><span class=\"line\"></span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    queue.poll();</span><br><span class=\"line\">    System.out.println(queue.size());</span><br><span class=\"line\">    <span class=\"comment\">// 2s后出队列失败</span></span><br><span class=\"line\">    System.out.println(queue.poll(<span class=\"number\">2</span>, TimeUnit.SECONDS));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a>SynchronousQueue</h3><p>同步队列，不存储元素，一个元素进出完成后，下一个元素才能进出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 同步队列</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建两个线程：线程一存取三个元素，线程二读取三个元素</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test5</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; put 1&quot;</span>);</span><br><span class=\"line\">            syncQueue.put(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; put 2&quot;</span>);</span><br><span class=\"line\">            syncQueue.put(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; put 3&quot;</span>);</span><br><span class=\"line\">            syncQueue.put(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;A&quot;</span>).start();</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等待两秒再取，确保线程1入队列成功</span></span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;=&gt;&quot;</span> + syncQueue.take());</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;=&gt;&quot;</span> + syncQueue.take());</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;=&gt;&quot;</span> + syncQueue.take());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;B&quot;</span>).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PriorityQueue-优先级队列\"><a href=\"#PriorityQueue-优先级队列\" class=\"headerlink\" title=\"PriorityQueue 优先级队列\"></a>PriorityQueue 优先级队列</h3><p>PriorityQueue是一个带有优先级的队列，而不是先进先出队列，元素按优先级顺序被移除，该队列也没有上限（即 Integer.MAX_VALUE），无容量限制，自动扩容。</p>\n<p>此队列虽然没有容量限制，但是会由于服务器资源耗尽抛OutOfMemoryError异常。</p>\n<p>如果队列为空，那么取元素的操作take就会阻塞，所以检索操作take是受阻的。</p>\n<p>放入PriorityQueue中的元素需要具有比较能力。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PriorityQueueDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置比对方式</span></span><br><span class=\"line\">        PriorityQueue&lt;String&gt; priorityQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(String o1, String o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        priorityQueue.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">        priorityQueue.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        priorityQueue.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(priorityQueue.poll());</span><br><span class=\"line\">        System.out.println(priorityQueue.poll());</span><br><span class=\"line\">        System.out.println(priorityQueue.poll());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 定义MessageObject存放的优先级</span></span><br><span class=\"line\">        PriorityQueue&lt;MessageObject&gt; MessageObjectQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;MessageObject&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(MessageObject o1, MessageObject o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Order比较大的MessageObject放后面</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> o1.order &gt; o2.order ? -<span class=\"number\">1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageObject</span> &#123;</span><br><span class=\"line\">        String content;</span><br><span class=\"line\">        <span class=\"type\">int</span> order;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面探寻一下延时队列的实现原理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DelayQueue</span>&lt;E <span class=\"keyword\">extends</span> <span class=\"title class_\">Delayed</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractQueue</span>&lt;E&gt;</span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 基于PriorityQueue来实现的延时队列</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityQueue&lt;E&gt; q = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;E&gt;();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>DelayQueue的泛型必须实现Delayed接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Delayed</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Comparable</span>&lt;Delayed&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the remaining delay associated with this object, in the</span></span><br><span class=\"line\"><span class=\"comment\">     * given time unit.</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个元素需要在队列中待多久时间</span></span><br><span class=\"line\"><span class=\"comment\">     </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit the time unit</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the remaining delay; zero or negative values indicate</span></span><br><span class=\"line\"><span class=\"comment\">     * that the delay has already elapsed</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">getDelay</span><span class=\"params\">(TimeUnit unit)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>应用示例</strong></p>\n<p>线程池中的定时调度就是使用这样的方法实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DelayQueueDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        DelayQueue&lt;Message&gt; delayQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">DelayQueue</span>&lt;Message&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 这条消息5秒后发送</span></span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Message</span>(<span class=\"string\">&quot;message - 00001&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(System.currentTimeMillis() + <span class=\"number\">5000L</span>));</span><br><span class=\"line\">        delayQueue.add(message);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            System.out.println(delayQueue.poll());</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000L</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现Delayed接口的元素才能存到DelayQueue</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Delayed</span> &#123;</span><br><span class=\"line\">        String content;</span><br><span class=\"line\">        Date sendTime;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> content  消息内容</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> sendTime 定时发送</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Message</span><span class=\"params\">(String content, Date sendTime)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.content = content;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sendTime = sendTime;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 判断当前这个元素是不是已经到了需要被拿出来的时间</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getDelay</span><span class=\"params\">(TimeUnit unit)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">duration</span> <span class=\"operator\">=</span> sendTime.getTime() - System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> TimeUnit.NANOSECONDS.convert(duration, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compareTo</span><span class=\"params\">(Delayed o)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o.getDelay(TimeUnit.NANOSECONDS) &gt; <span class=\"built_in\">this</span>.getDelay(TimeUnit.NANOSECONDS) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"ReentrantLock和ReadWriteLock","date":"2021-04-29T09:19:00.000Z","comments":0,"_content":"\n主要有读写锁和可重入锁两个重要的实现。\n\n```java\npublic interface Lock {\n    void lock();\n    // 在获取锁的过程中可以中断当前线程\n    void lockInterruptibly() throws InterruptedException;\n    // 尝试非阻塞地获取锁，立即返回\n    boolean tryLock();\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n    void unlock();\n    Condition newCondition();\n}\n```\n\n## ReentrantLock\n\n独享锁、支持公平锁和非公平锁两种模式，可重入锁。\n\n![image-20210429135322710](.\\images\\Lock - ReetrantLock锁执行原理.png)\n\n初始时持有者为null，计数是当前调用lock()方法加锁的次数，unlock()会将计数减1，当计数为0时，则表示当前锁被释放。（获取当前锁的次数 getHoldCount()）\n\n可重入锁的话，做了一次加锁就一定要有对应的一次解锁，否则产生死锁。\t\n\n## ReadWriteLock（注：不是Lock锁的子类）\n\n维护一对关联锁，一个用于只读操作，一个用于写入;读锁可以由多个读线程同时持有，写锁是排他的。\n\n读锁拒绝其他线程获得写锁，读锁不拒绝其他线程获得读锁，多个上了读锁的线程可以并发读不会阻塞。多个读锁同时作用期间，其他想上写锁的线程都处在等待状态，当最后一个读锁释放后，才有可能上锁。\n\n适合读取线程比写入线程多的场景，改进互斥锁的性能，示例场景:缓存组件、集合的并发线程安全性改造。\n\n```java\n// 读写锁案例\npublic class LockDemo2 {\n    ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    public static void main(String[] args) {\n        LockDemo2 lockDemo2 = new LockDemo2();\n\n        for (int i = 0; i < 2; i++) {\n            new Thread(() -> {\n                lockDemo2.read(Thread.currentThread());\n            }, \"A\" + i).start();\n        }\n\n        new Thread(() -> {\n            lockDemo2.write(Thread.currentThread());\n        }, \"C\").start();\n    }\n\n    // 多线程读，共享锁\n    public void read(Thread t) {\n        lock.readLock().lock();\n        try {\n            long start = System.currentTimeMillis();\n            while (System.currentTimeMillis() - start <= 1) {\n                System.out.println(t.getName() + \"正在【读】操作\");\n            }\n            System.out.println(t.getName() + \"【读】操作完成\");\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n\n    // 独享锁\n    public void write(Thread t) {\n        lock.writeLock().lock();\n        try {\n            long start = System.currentTimeMillis();\n            while (System.currentTimeMillis() - start <= 1) {\n                System.out.println(t.getName() + \"正在【写】操作\");\n            }\n            System.out.println(t.getName() + \"【写】操作完成\");\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n}\n```\n\n## ReadWriteLock锁降级\n\n锁降级指的是写锁降级成为读锁。把持住当前拥有的写锁的同时，再获取到读锁,随后释放写锁的过程。\n\n写锁是线程独占，读锁是共享，所以写->读是升级。(读~>写, 是不能实现的)\n\n```java\n/**\n * 一个缓存demo，读写锁例子，实现读和写互斥、写和写互斥，但有可以多个并发的读，可提高系统性能\n * ReentrantReadWriteLock的应用场景中，使用写锁可能没有注意到缓存问题（击穿、雪崩、穿透）\n *\n * @author DengJun 2021/4/29\n */\npublic class LockDemo3 {\n    // 数据\n    private Map<String, Object> cache = new HashMap<>();\n    // 读写锁\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n\n    public Object getData(String key) {\n        // 上读锁，多个读时可以并发，不会造成对数据的破坏\n        rwl.readLock().lock();\n        Object value = null;\n        try {\n            value = cache.get(key);\n            // 如果数据为空\n            if (value == null) {\n                // 释放读锁上写锁，上写锁后，数据不能被读\n                rwl.readLock().unlock();\n                rwl.writeLock().lock();\n                try {\n                    // 此处判断是为防止多个线程同时进入到这里时，多个线程对数据进行重复写\n                    if (value == null) {\n                        // 如果没有数据，则去查DB获取数据\n                        value = \"XXX\";\n                    }\n                } finally {\n                    // 读取数据后释放写锁\n                    rwl.writeLock().unlock();\n                }\n                // 获取完数据后，恢复读锁，重新读取数据\n                rwl.readLock().lock();\n            }\n        } finally {\n            // 重新读取数据释放读锁\n            value = cache.get(key);\n            rwl.readLock().unlock();\n        }\n        return value;\n    }\n}\n```\n\n## Condition\n\n![image-20210429171248960](.\\images\\Lock-ReentrantLock-Condition原理.png)\n\n","source":"_posts/Java并发 - ReetrantLock、读写锁.md","raw":"---\ntitle: ReentrantLock和ReadWriteLock\ndate: 2021-04-29 17:19:00\ntags:\n  - JUC并发包\ncomments: false\n---\n\n主要有读写锁和可重入锁两个重要的实现。\n\n```java\npublic interface Lock {\n    void lock();\n    // 在获取锁的过程中可以中断当前线程\n    void lockInterruptibly() throws InterruptedException;\n    // 尝试非阻塞地获取锁，立即返回\n    boolean tryLock();\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n    void unlock();\n    Condition newCondition();\n}\n```\n\n## ReentrantLock\n\n独享锁、支持公平锁和非公平锁两种模式，可重入锁。\n\n![image-20210429135322710](.\\images\\Lock - ReetrantLock锁执行原理.png)\n\n初始时持有者为null，计数是当前调用lock()方法加锁的次数，unlock()会将计数减1，当计数为0时，则表示当前锁被释放。（获取当前锁的次数 getHoldCount()）\n\n可重入锁的话，做了一次加锁就一定要有对应的一次解锁，否则产生死锁。\t\n\n## ReadWriteLock（注：不是Lock锁的子类）\n\n维护一对关联锁，一个用于只读操作，一个用于写入;读锁可以由多个读线程同时持有，写锁是排他的。\n\n读锁拒绝其他线程获得写锁，读锁不拒绝其他线程获得读锁，多个上了读锁的线程可以并发读不会阻塞。多个读锁同时作用期间，其他想上写锁的线程都处在等待状态，当最后一个读锁释放后，才有可能上锁。\n\n适合读取线程比写入线程多的场景，改进互斥锁的性能，示例场景:缓存组件、集合的并发线程安全性改造。\n\n```java\n// 读写锁案例\npublic class LockDemo2 {\n    ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    public static void main(String[] args) {\n        LockDemo2 lockDemo2 = new LockDemo2();\n\n        for (int i = 0; i < 2; i++) {\n            new Thread(() -> {\n                lockDemo2.read(Thread.currentThread());\n            }, \"A\" + i).start();\n        }\n\n        new Thread(() -> {\n            lockDemo2.write(Thread.currentThread());\n        }, \"C\").start();\n    }\n\n    // 多线程读，共享锁\n    public void read(Thread t) {\n        lock.readLock().lock();\n        try {\n            long start = System.currentTimeMillis();\n            while (System.currentTimeMillis() - start <= 1) {\n                System.out.println(t.getName() + \"正在【读】操作\");\n            }\n            System.out.println(t.getName() + \"【读】操作完成\");\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n\n    // 独享锁\n    public void write(Thread t) {\n        lock.writeLock().lock();\n        try {\n            long start = System.currentTimeMillis();\n            while (System.currentTimeMillis() - start <= 1) {\n                System.out.println(t.getName() + \"正在【写】操作\");\n            }\n            System.out.println(t.getName() + \"【写】操作完成\");\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n}\n```\n\n## ReadWriteLock锁降级\n\n锁降级指的是写锁降级成为读锁。把持住当前拥有的写锁的同时，再获取到读锁,随后释放写锁的过程。\n\n写锁是线程独占，读锁是共享，所以写->读是升级。(读~>写, 是不能实现的)\n\n```java\n/**\n * 一个缓存demo，读写锁例子，实现读和写互斥、写和写互斥，但有可以多个并发的读，可提高系统性能\n * ReentrantReadWriteLock的应用场景中，使用写锁可能没有注意到缓存问题（击穿、雪崩、穿透）\n *\n * @author DengJun 2021/4/29\n */\npublic class LockDemo3 {\n    // 数据\n    private Map<String, Object> cache = new HashMap<>();\n    // 读写锁\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n\n    public Object getData(String key) {\n        // 上读锁，多个读时可以并发，不会造成对数据的破坏\n        rwl.readLock().lock();\n        Object value = null;\n        try {\n            value = cache.get(key);\n            // 如果数据为空\n            if (value == null) {\n                // 释放读锁上写锁，上写锁后，数据不能被读\n                rwl.readLock().unlock();\n                rwl.writeLock().lock();\n                try {\n                    // 此处判断是为防止多个线程同时进入到这里时，多个线程对数据进行重复写\n                    if (value == null) {\n                        // 如果没有数据，则去查DB获取数据\n                        value = \"XXX\";\n                    }\n                } finally {\n                    // 读取数据后释放写锁\n                    rwl.writeLock().unlock();\n                }\n                // 获取完数据后，恢复读锁，重新读取数据\n                rwl.readLock().lock();\n            }\n        } finally {\n            // 重新读取数据释放读锁\n            value = cache.get(key);\n            rwl.readLock().unlock();\n        }\n        return value;\n    }\n}\n```\n\n## Condition\n\n![image-20210429171248960](.\\images\\Lock-ReentrantLock-Condition原理.png)\n\n","slug":"Java并发 - ReetrantLock、读写锁","published":1,"updated":"2022-03-02T11:28:16.185Z","layout":"post","photos":[],"link":"","_id":"cl0atbcp0000f7cu5hb651w7b","content":"<p>主要有读写锁和可重入锁两个重要的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Lock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 在获取锁的过程中可以中断当前线程</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试非阻塞地获取锁，立即返回</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Condition <span class=\"title function_\">newCondition</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h2><p>独享锁、支持公平锁和非公平锁两种模式，可重入锁。</p>\n<p>![image-20210429135322710](.\\images\\Lock - ReetrantLock锁执行原理.png)</p>\n<p>初始时持有者为null，计数是当前调用lock()方法加锁的次数，unlock()会将计数减1，当计数为0时，则表示当前锁被释放。（获取当前锁的次数 getHoldCount()）</p>\n<p>可重入锁的话，做了一次加锁就一定要有对应的一次解锁，否则产生死锁。    </p>\n<h2 id=\"ReadWriteLock（注：不是Lock锁的子类）\"><a href=\"#ReadWriteLock（注：不是Lock锁的子类）\" class=\"headerlink\" title=\"ReadWriteLock（注：不是Lock锁的子类）\"></a>ReadWriteLock（注：不是Lock锁的子类）</h2><p>维护一对关联锁，一个用于只读操作，一个用于写入;读锁可以由多个读线程同时持有，写锁是排他的。</p>\n<p>读锁拒绝其他线程获得写锁，读锁不拒绝其他线程获得读锁，多个上了读锁的线程可以并发读不会阻塞。多个读锁同时作用期间，其他想上写锁的线程都处在等待状态，当最后一个读锁释放后，才有可能上锁。</p>\n<p>适合读取线程比写入线程多的场景，改进互斥锁的性能，示例场景:缓存组件、集合的并发线程安全性改造。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读写锁案例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockDemo2</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ReadWriteLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantReadWriteLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">LockDemo2</span> <span class=\"variable\">lockDemo2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockDemo2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                lockDemo2.read(Thread.currentThread());</span><br><span class=\"line\">            &#125;, <span class=\"string\">&quot;A&quot;</span> + i).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            lockDemo2.write(Thread.currentThread());</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;C&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多线程读，共享锁</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">(Thread t)</span> &#123;</span><br><span class=\"line\">        lock.readLock().lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (System.currentTimeMillis() - start &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.println(t.getName() + <span class=\"string\">&quot;正在【读】操作&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(t.getName() + <span class=\"string\">&quot;【读】操作完成&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.readLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 独享锁</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(Thread t)</span> &#123;</span><br><span class=\"line\">        lock.writeLock().lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (System.currentTimeMillis() - start &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.println(t.getName() + <span class=\"string\">&quot;正在【写】操作&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(t.getName() + <span class=\"string\">&quot;【写】操作完成&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.writeLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ReadWriteLock锁降级\"><a href=\"#ReadWriteLock锁降级\" class=\"headerlink\" title=\"ReadWriteLock锁降级\"></a>ReadWriteLock锁降级</h2><p>锁降级指的是写锁降级成为读锁。把持住当前拥有的写锁的同时，再获取到读锁,随后释放写锁的过程。</p>\n<p>写锁是线程独占，读锁是共享，所以写-&gt;读是升级。(读~&gt;写, 是不能实现的)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 一个缓存demo，读写锁例子，实现读和写互斥、写和写互斥，但有可以多个并发的读，可提高系统性能</span></span><br><span class=\"line\"><span class=\"comment\"> * ReentrantReadWriteLock的应用场景中，使用写锁可能没有注意到缓存问题（击穿、雪崩、穿透）</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> DengJun 2021/4/29</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockDemo3</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 数据</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Object&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 读写锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">ReadWriteLock</span> <span class=\"variable\">rwl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantReadWriteLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getData</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 上读锁，多个读时可以并发，不会造成对数据的破坏</span></span><br><span class=\"line\">        rwl.readLock().lock();</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            value = cache.get(key);</span><br><span class=\"line\">            <span class=\"comment\">// 如果数据为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 释放读锁上写锁，上写锁后，数据不能被读</span></span><br><span class=\"line\">                rwl.readLock().unlock();</span><br><span class=\"line\">                rwl.writeLock().lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 此处判断是为防止多个线程同时进入到这里时，多个线程对数据进行重复写</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果没有数据，则去查DB获取数据</span></span><br><span class=\"line\">                        value = <span class=\"string\">&quot;XXX&quot;</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 读取数据后释放写锁</span></span><br><span class=\"line\">                    rwl.writeLock().unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 获取完数据后，恢复读锁，重新读取数据</span></span><br><span class=\"line\">                rwl.readLock().lock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 重新读取数据释放读锁</span></span><br><span class=\"line\">            value = cache.get(key);</span><br><span class=\"line\">            rwl.readLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h2><p><img src=\"/.%5Cimages%5CLock-ReentrantLock-Condition%E5%8E%9F%E7%90%86.png\" alt=\"image-20210429171248960\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>主要有读写锁和可重入锁两个重要的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Lock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 在获取锁的过程中可以中断当前线程</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试非阻塞地获取锁，立即返回</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Condition <span class=\"title function_\">newCondition</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h2><p>独享锁、支持公平锁和非公平锁两种模式，可重入锁。</p>\n<p>![image-20210429135322710](.\\images\\Lock - ReetrantLock锁执行原理.png)</p>\n<p>初始时持有者为null，计数是当前调用lock()方法加锁的次数，unlock()会将计数减1，当计数为0时，则表示当前锁被释放。（获取当前锁的次数 getHoldCount()）</p>\n<p>可重入锁的话，做了一次加锁就一定要有对应的一次解锁，否则产生死锁。    </p>\n<h2 id=\"ReadWriteLock（注：不是Lock锁的子类）\"><a href=\"#ReadWriteLock（注：不是Lock锁的子类）\" class=\"headerlink\" title=\"ReadWriteLock（注：不是Lock锁的子类）\"></a>ReadWriteLock（注：不是Lock锁的子类）</h2><p>维护一对关联锁，一个用于只读操作，一个用于写入;读锁可以由多个读线程同时持有，写锁是排他的。</p>\n<p>读锁拒绝其他线程获得写锁，读锁不拒绝其他线程获得读锁，多个上了读锁的线程可以并发读不会阻塞。多个读锁同时作用期间，其他想上写锁的线程都处在等待状态，当最后一个读锁释放后，才有可能上锁。</p>\n<p>适合读取线程比写入线程多的场景，改进互斥锁的性能，示例场景:缓存组件、集合的并发线程安全性改造。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读写锁案例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockDemo2</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ReadWriteLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantReadWriteLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">LockDemo2</span> <span class=\"variable\">lockDemo2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LockDemo2</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                lockDemo2.read(Thread.currentThread());</span><br><span class=\"line\">            &#125;, <span class=\"string\">&quot;A&quot;</span> + i).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            lockDemo2.write(Thread.currentThread());</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;C&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多线程读，共享锁</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">(Thread t)</span> &#123;</span><br><span class=\"line\">        lock.readLock().lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (System.currentTimeMillis() - start &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.println(t.getName() + <span class=\"string\">&quot;正在【读】操作&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(t.getName() + <span class=\"string\">&quot;【读】操作完成&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.readLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 独享锁</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(Thread t)</span> &#123;</span><br><span class=\"line\">        lock.writeLock().lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (System.currentTimeMillis() - start &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.println(t.getName() + <span class=\"string\">&quot;正在【写】操作&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(t.getName() + <span class=\"string\">&quot;【写】操作完成&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.writeLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ReadWriteLock锁降级\"><a href=\"#ReadWriteLock锁降级\" class=\"headerlink\" title=\"ReadWriteLock锁降级\"></a>ReadWriteLock锁降级</h2><p>锁降级指的是写锁降级成为读锁。把持住当前拥有的写锁的同时，再获取到读锁,随后释放写锁的过程。</p>\n<p>写锁是线程独占，读锁是共享，所以写-&gt;读是升级。(读~&gt;写, 是不能实现的)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 一个缓存demo，读写锁例子，实现读和写互斥、写和写互斥，但有可以多个并发的读，可提高系统性能</span></span><br><span class=\"line\"><span class=\"comment\"> * ReentrantReadWriteLock的应用场景中，使用写锁可能没有注意到缓存问题（击穿、雪崩、穿透）</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> DengJun 2021/4/29</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockDemo3</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 数据</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Object&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 读写锁</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">ReadWriteLock</span> <span class=\"variable\">rwl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantReadWriteLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getData</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 上读锁，多个读时可以并发，不会造成对数据的破坏</span></span><br><span class=\"line\">        rwl.readLock().lock();</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            value = cache.get(key);</span><br><span class=\"line\">            <span class=\"comment\">// 如果数据为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 释放读锁上写锁，上写锁后，数据不能被读</span></span><br><span class=\"line\">                rwl.readLock().unlock();</span><br><span class=\"line\">                rwl.writeLock().lock();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 此处判断是为防止多个线程同时进入到这里时，多个线程对数据进行重复写</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果没有数据，则去查DB获取数据</span></span><br><span class=\"line\">                        value = <span class=\"string\">&quot;XXX&quot;</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 读取数据后释放写锁</span></span><br><span class=\"line\">                    rwl.writeLock().unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 获取完数据后，恢复读锁，重新读取数据</span></span><br><span class=\"line\">                rwl.readLock().lock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 重新读取数据释放读锁</span></span><br><span class=\"line\">            value = cache.get(key);</span><br><span class=\"line\">            rwl.readLock().unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h2><p><img src=\"/.%5Cimages%5CLock-ReentrantLock-Condition%E5%8E%9F%E7%90%86.png\" alt=\"image-20210429171248960\"></p>\n"},{"title":"信号量 Semaphore","date":"2021-05-14T09:18:00.000Z","comments":0,"description":"应用场景：多个共享资源互斥、并发限流（如Hystrix）。信号量是操作系统中，实现进程间资源的互斥与同步。信号量维护了一组许可证，以约束访问被限制资源的线程数。","_content":"\n# Java并发 - 信号量 Semaphore\n\n应用场景：多个共享资源互斥、并发限流（如Hystrix）。\n\n信号量是操作系统中，实现进程间资源的互斥与同步。信号量维护了一组许可证，以约束访问被限制资源的线程数。\n\nJava并发包中的 Semaphore 可以控制某个资源被同时访问的任务数，它通过acquire（）获取一个许可，release（）释放一个许可。可以通过availablePermits() 方法得到可用的许可数量。\n\n如果被同时访问的任务数已满，则其他acquire的任务进入等待状态，直到有一个任务被release掉，它才能得到许可。\n\n## 一、应用示例\n\n```java\npublic void testSemaphore() {\n    // 允许量为3，假设为3个停车位\n    Semaphore semaphore = new Semaphore(3);\n\n    for (int i = 0; i < 6; i++) {\n        new Thread(() -> {\n            try {\n                semaphore.acquire();\n                System.out.println(Thread.currentThread().getName() + \"抢到车位\");\n                TimeUnit.SECONDS.sleep(2);\n                System.out.println(Thread.currentThread().getName() + \"离开车位\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                semaphore.release();\n            }\n\n        }, \"\" + i).start();\n    }\n}\n```\n\n运行结果\n\n```\n0抢到车位\n1抢到车位\n2抢到车位\n1离开车位\n2离开车位\n0离开车位\n4抢到车位\n3抢到车位\n5抢到车位\n3离开车位\n5离开车位\n4离开车位\n```\n\n## 二、源码阅读\n\nSemaphore使用的是AQS的机制\n\n```java\npublic class Semaphore implements java.io.Serializable {\n     private final Sync sync;\n     abstract static class Sync extends AbstractQueuedSynchronizer {...}\n    ...\n}\n```\n\nSemaphore是如何获取信号量的？\n\n```java\npublic final void acquireSharedInterruptibly(int arg)\n    throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // 信号量是非独占资源，使用共享锁来获取信号量\n    if (tryAcquireShared(arg) < 0)\n        doAcquireSharedInterruptibly(arg);\n}\n```\n\n","source":"_posts/Java并发 - Semaphore信号量.md","raw":"---\ntitle: 信号量 Semaphore\ndate: 2021-05-14 17:18:00\ntags:\n  - JUC并发包\ncomments: false\ndescription: 应用场景：多个共享资源互斥、并发限流（如Hystrix）。信号量是操作系统中，实现进程间资源的互斥与同步。信号量维护了一组许可证，以约束访问被限制资源的线程数。\n---\n\n# Java并发 - 信号量 Semaphore\n\n应用场景：多个共享资源互斥、并发限流（如Hystrix）。\n\n信号量是操作系统中，实现进程间资源的互斥与同步。信号量维护了一组许可证，以约束访问被限制资源的线程数。\n\nJava并发包中的 Semaphore 可以控制某个资源被同时访问的任务数，它通过acquire（）获取一个许可，release（）释放一个许可。可以通过availablePermits() 方法得到可用的许可数量。\n\n如果被同时访问的任务数已满，则其他acquire的任务进入等待状态，直到有一个任务被release掉，它才能得到许可。\n\n## 一、应用示例\n\n```java\npublic void testSemaphore() {\n    // 允许量为3，假设为3个停车位\n    Semaphore semaphore = new Semaphore(3);\n\n    for (int i = 0; i < 6; i++) {\n        new Thread(() -> {\n            try {\n                semaphore.acquire();\n                System.out.println(Thread.currentThread().getName() + \"抢到车位\");\n                TimeUnit.SECONDS.sleep(2);\n                System.out.println(Thread.currentThread().getName() + \"离开车位\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                semaphore.release();\n            }\n\n        }, \"\" + i).start();\n    }\n}\n```\n\n运行结果\n\n```\n0抢到车位\n1抢到车位\n2抢到车位\n1离开车位\n2离开车位\n0离开车位\n4抢到车位\n3抢到车位\n5抢到车位\n3离开车位\n5离开车位\n4离开车位\n```\n\n## 二、源码阅读\n\nSemaphore使用的是AQS的机制\n\n```java\npublic class Semaphore implements java.io.Serializable {\n     private final Sync sync;\n     abstract static class Sync extends AbstractQueuedSynchronizer {...}\n    ...\n}\n```\n\nSemaphore是如何获取信号量的？\n\n```java\npublic final void acquireSharedInterruptibly(int arg)\n    throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // 信号量是非独占资源，使用共享锁来获取信号量\n    if (tryAcquireShared(arg) < 0)\n        doAcquireSharedInterruptibly(arg);\n}\n```\n\n","slug":"Java并发 - Semaphore信号量","published":1,"updated":"2022-02-28T10:56:41.123Z","layout":"post","photos":[],"link":"","_id":"cl0atbcp0000h7cu5dw0fbi7s","content":"<h1 id=\"Java并发-信号量-Semaphore\"><a href=\"#Java并发-信号量-Semaphore\" class=\"headerlink\" title=\"Java并发 - 信号量 Semaphore\"></a>Java并发 - 信号量 Semaphore</h1><p>应用场景：多个共享资源互斥、并发限流（如Hystrix）。</p>\n<p>信号量是操作系统中，实现进程间资源的互斥与同步。信号量维护了一组许可证，以约束访问被限制资源的线程数。</p>\n<p>Java并发包中的 Semaphore 可以控制某个资源被同时访问的任务数，它通过acquire（）获取一个许可，release（）释放一个许可。可以通过availablePermits() 方法得到可用的许可数量。</p>\n<p>如果被同时访问的任务数已满，则其他acquire的任务进入等待状态，直到有一个任务被release掉，它才能得到许可。</p>\n<h2 id=\"一、应用示例\"><a href=\"#一、应用示例\" class=\"headerlink\" title=\"一、应用示例\"></a>一、应用示例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testSemaphore</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 允许量为3，假设为3个停车位</span></span><br><span class=\"line\">    <span class=\"type\">Semaphore</span> <span class=\"variable\">semaphore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore.acquire();</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;抢到车位&quot;</span>);</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;离开车位&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;&quot;</span> + i).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0抢到车位</span><br><span class=\"line\">1抢到车位</span><br><span class=\"line\">2抢到车位</span><br><span class=\"line\">1离开车位</span><br><span class=\"line\">2离开车位</span><br><span class=\"line\">0离开车位</span><br><span class=\"line\">4抢到车位</span><br><span class=\"line\">3抢到车位</span><br><span class=\"line\">5抢到车位</span><br><span class=\"line\">3离开车位</span><br><span class=\"line\">5离开车位</span><br><span class=\"line\">4离开车位</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、源码阅读\"><a href=\"#二、源码阅读\" class=\"headerlink\" title=\"二、源码阅读\"></a>二、源码阅读</h2><p>Semaphore使用的是AQS的机制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Semaphore</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable &#123;</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\">     <span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractQueuedSynchronizer</span> &#123;...&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Semaphore是如何获取信号量的？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquireSharedInterruptibly</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span></span><br><span class=\"line\">    <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterruptedException</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 信号量是非独占资源，使用共享锁来获取信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java并发-信号量-Semaphore\"><a href=\"#Java并发-信号量-Semaphore\" class=\"headerlink\" title=\"Java并发 - 信号量 Semaphore\"></a>Java并发 - 信号量 Semaphore</h1><p>应用场景：多个共享资源互斥、并发限流（如Hystrix）。</p>\n<p>信号量是操作系统中，实现进程间资源的互斥与同步。信号量维护了一组许可证，以约束访问被限制资源的线程数。</p>\n<p>Java并发包中的 Semaphore 可以控制某个资源被同时访问的任务数，它通过acquire（）获取一个许可，release（）释放一个许可。可以通过availablePermits() 方法得到可用的许可数量。</p>\n<p>如果被同时访问的任务数已满，则其他acquire的任务进入等待状态，直到有一个任务被release掉，它才能得到许可。</p>\n<h2 id=\"一、应用示例\"><a href=\"#一、应用示例\" class=\"headerlink\" title=\"一、应用示例\"></a>一、应用示例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testSemaphore</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 允许量为3，假设为3个停车位</span></span><br><span class=\"line\">    <span class=\"type\">Semaphore</span> <span class=\"variable\">semaphore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore.acquire();</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;抢到车位&quot;</span>);</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;离开车位&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;&quot;</span> + i).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0抢到车位</span><br><span class=\"line\">1抢到车位</span><br><span class=\"line\">2抢到车位</span><br><span class=\"line\">1离开车位</span><br><span class=\"line\">2离开车位</span><br><span class=\"line\">0离开车位</span><br><span class=\"line\">4抢到车位</span><br><span class=\"line\">3抢到车位</span><br><span class=\"line\">5抢到车位</span><br><span class=\"line\">3离开车位</span><br><span class=\"line\">5离开车位</span><br><span class=\"line\">4离开车位</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、源码阅读\"><a href=\"#二、源码阅读\" class=\"headerlink\" title=\"二、源码阅读\"></a>二、源码阅读</h2><p>Semaphore使用的是AQS的机制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Semaphore</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable &#123;</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\">     <span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractQueuedSynchronizer</span> &#123;...&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Semaphore是如何获取信号量的？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquireSharedInterruptibly</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span></span><br><span class=\"line\">    <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterruptedException</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 信号量是非独占资源，使用共享锁来获取信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"优雅的停止线程","date":"2021-04-12T14:21:00.000Z","comments":0,"description":"stop、suspend、resume 这三个过期作废的方法是不推荐使用的，因为有可能会发生不可预料的结果而且出现错误后还难定位。","_content":"\n## 线程 - 停止\n\n### 一、 废弃的停止方法\n\n​\t\t看到这个标题就能想到：Thread.stop()。Java中的多线程可不像break语句那么干脆。\n\n​\t\tstop、suspend、resume 这三个过期作废的方法是不推荐使用的，因为有可能会发生不可预料的结果而且出现错误后还难定位。\n\n​\t\t不推荐使用 Thread.stop() 的原因。这个方法是从外面让线程**强制停止**，如果停止的线程持有一个临界锁， 把一个对象置于一个不一致的状态（包含临界、持久化、游离），说白了就是造成数据不一致的结果。\n\n​\t\t大多数情况下，停止一个线程使用  Thread.interrupt() 方法，但是这个方法不会终止一个正在运行状态的线程，还需要加入一些判断才能完成停止线程。\n\n​\t\t在Java中有3种方式停止正在运行的线程：\n\n​\t\t1、使用退出标志，正常退出；\n\n​\t\t2、使用 stop()， 强行终止；\n\n​\t\t3、使用 interrupt() 方法，中断线程；\n\n### 二、interrupt() 初体验\n\n​\t一上来就按照下面这种方式运行：\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n        myThread.interrupt();\n        System.out.println(\"mrdjun\");\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        for (int i = 0; i < 1000000; i++) {\n            System.out.println(\"i=\" + (i + 1));\n        }\n    }\n}\n```\n\n发现结果输出了 **1000000** 行，而且 mrdjun 还输出在了中间，说明 interrupt 并没有让线程停下来。\n\n### 三、判断线程是否为停止状态\n\n​\t下面Java提供了两个判断线程是否为停止状态的方法。\n\n​\tpublic static boolean interrupted() ：使用 Thread.interrupted() 测试当前线程是否已经中断，执行后清楚状态标志值为 false 的功能。\n\n​\tpublic boolean this.isInterrupted()： 测试 this 关键字所在类的对象是否已经中断，不清楚标志。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n        myThread.interrupt(); // 作用于 myThread 对象\n        // isInterrupted 测试当前线程是否已经中断\n        System.out.println(\"线程是否停止？\"+myThread.isInterrupted());\n        System.out.println(\"线程是否停止？\"+myThread.isInterrupted());\n    }\n}\n```\n\n​\t\t补充一点：也可以使用 Thread.interrupted() 来判断当前线程是否已经中断，因为在 Thread.java 这个类中调用静态static方法的时候，大多数是针对 currentThread() 线程进行操作的。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n      \tThread.currentThread().interrupt(); // 作用于 Thread\n        // isInterrupted 测试当前线程是否已经中断\n        System.out.println(\"线程是否停止？\"+ Thread.interrupted()); // 输出 true\n        System.out.println(\"线程是否停止？\"+ Thread.interrupted()); // 输出 false\n        System.out.println(\"END!\");\n    }\n}\n```\n\n出乎意料的是结果输出不一致，查看官方帮助文档中的 interrupted() 解释：\n\n> 测试当前线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。\n\nisInterrupted() 的方法声明如下：\n\n``` java\npublic boolean isInterrupted();\n```\n\n很显然，这个方法不是一个static方法，作用于这个方法的对象，如下。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n\t    myThread.interrupt();\n        System.out.println(\"线程是否停止？\" + myThread.isInterrupted()); // 输出 true\n        System.out.println(\"线程是否停止？\" + myThread.isInterrupted()); // 输出 true\n        System.out.println(\"END!\");\n    }\n}\n```\n\n综上所述，两者区别如下：\n\n（1）Thread.interrupted() 测试线程是否已经中断，执行后具有清除状态标志值为false的功能；\n\n（2）new Thread().isInterrupted() 测试线程Thread对象是否已经是中断状态，不清除状态标志；\n\n### 四、 能停止的线程——异常法\n\n​\t在main方法中两秒后调用 Thread 对象的 myThread.interrupt() 方法，在线程中的for循环中加入 if 判断后面的代码是否可以运行。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(500);\n        myThread.interrupt();\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        try {\n            for (int i = 0; i < 5000000; i++) {\n                if (interrupted()) {\n                    System.out.println(\"线程已经停止\");\n                    // 退出当前循环，如果为 return; 或 throw new InterruptedException() 则直接退出当前线程\n                    throw new InterruptedException();\n                }\n                System.out.println(\"i=\" + (i + 1));\n            }\n            System.out.println(\"for循环外面的语句\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n抛出异常方式详情：\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) {\n        try {\n            MyThread myThread = new MyThread();\n            myThread.start();\n            Thread.sleep(1000);\n            myThread.interrupt();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        try {\n            for (int i = 0; i < 5000000; i++) {\n                if (interrupted()) {\n                    System.out.println(\"线程已经停止\");\n                    throw new InterruptedException();\n                }\n                System.out.println(\"i=\" + (i + 1));\n            }\n            System.out.println(\"for循环外面的语句\");\n        } catch (Exception e) {\n            System.out.println(\"抛出异常\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n通过下面的运行结果可以看出，线程终于被正确的停止了。\n\n```java\ni=312961\ni=312962\n线程已经停止\n抛出异常\njava.lang.InterruptedException\n\tat com.fun.async.test.class03.MyThread.run(ThreadInterrupt.java:34)\n```\n\n### 五、在 sleep 状态下停止线程\n\n``` java\npublic class SleepThreadInterrupt {\n    public static void main(String[] args) {\n        try {\n            MyThread thread = new MyThread();\n            thread.start();\n            Thread.sleep(200); // 先sleep 在调用 interrupt\n            thread.interrupt();\n            System.out.println(\"complete!\");\n        } catch (InterruptedException e) {\n            System.out.println(\"main catch\");\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread extends Thread{\n        @Override\n        public void run() {\n            super.run();\n            try {\n                System.out.println(\"run start ...\");\n                Thread.sleep(200000);\n                System.out.println(\"run end!\");\n            } catch (InterruptedException e) {\n                System.out.println(\"在sleep中停止，进入catch！\"+this.isInterrupted());\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n从下面的输出结果来看，如果线程在 sleep 状态下停止，则该线程会进入 catch 语句，并且清除停止状态值，变成false。\n\n``` java\nrun start ...\ncomplete!\n在sleep中停止，进入catch！false\njava.lang.InterruptedException: sleep interrupted\n\tat java.lang.Thread.sleep(Native Method)\n\tat com.fun.async.test.class03.SleepThreadInterrupt$MyThread.run(SleepThreadInterrupt.java:26)\n\n```\n\n","source":"_posts/Java并发 - interrupt+isInterrupted.md","raw":"---\ntitle: 优雅的停止线程\ndate: 2021-04-12 22:21:00\ntags:\n- JUC并发包\ncomments: false\ndescription: stop、suspend、resume 这三个过期作废的方法是不推荐使用的，因为有可能会发生不可预料的结果而且出现错误后还难定位。\n---\n\n## 线程 - 停止\n\n### 一、 废弃的停止方法\n\n​\t\t看到这个标题就能想到：Thread.stop()。Java中的多线程可不像break语句那么干脆。\n\n​\t\tstop、suspend、resume 这三个过期作废的方法是不推荐使用的，因为有可能会发生不可预料的结果而且出现错误后还难定位。\n\n​\t\t不推荐使用 Thread.stop() 的原因。这个方法是从外面让线程**强制停止**，如果停止的线程持有一个临界锁， 把一个对象置于一个不一致的状态（包含临界、持久化、游离），说白了就是造成数据不一致的结果。\n\n​\t\t大多数情况下，停止一个线程使用  Thread.interrupt() 方法，但是这个方法不会终止一个正在运行状态的线程，还需要加入一些判断才能完成停止线程。\n\n​\t\t在Java中有3种方式停止正在运行的线程：\n\n​\t\t1、使用退出标志，正常退出；\n\n​\t\t2、使用 stop()， 强行终止；\n\n​\t\t3、使用 interrupt() 方法，中断线程；\n\n### 二、interrupt() 初体验\n\n​\t一上来就按照下面这种方式运行：\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n        myThread.interrupt();\n        System.out.println(\"mrdjun\");\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        for (int i = 0; i < 1000000; i++) {\n            System.out.println(\"i=\" + (i + 1));\n        }\n    }\n}\n```\n\n发现结果输出了 **1000000** 行，而且 mrdjun 还输出在了中间，说明 interrupt 并没有让线程停下来。\n\n### 三、判断线程是否为停止状态\n\n​\t下面Java提供了两个判断线程是否为停止状态的方法。\n\n​\tpublic static boolean interrupted() ：使用 Thread.interrupted() 测试当前线程是否已经中断，执行后清楚状态标志值为 false 的功能。\n\n​\tpublic boolean this.isInterrupted()： 测试 this 关键字所在类的对象是否已经中断，不清楚标志。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n        myThread.interrupt(); // 作用于 myThread 对象\n        // isInterrupted 测试当前线程是否已经中断\n        System.out.println(\"线程是否停止？\"+myThread.isInterrupted());\n        System.out.println(\"线程是否停止？\"+myThread.isInterrupted());\n    }\n}\n```\n\n​\t\t补充一点：也可以使用 Thread.interrupted() 来判断当前线程是否已经中断，因为在 Thread.java 这个类中调用静态static方法的时候，大多数是针对 currentThread() 线程进行操作的。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n      \tThread.currentThread().interrupt(); // 作用于 Thread\n        // isInterrupted 测试当前线程是否已经中断\n        System.out.println(\"线程是否停止？\"+ Thread.interrupted()); // 输出 true\n        System.out.println(\"线程是否停止？\"+ Thread.interrupted()); // 输出 false\n        System.out.println(\"END!\");\n    }\n}\n```\n\n出乎意料的是结果输出不一致，查看官方帮助文档中的 interrupted() 解释：\n\n> 测试当前线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。\n\nisInterrupted() 的方法声明如下：\n\n``` java\npublic boolean isInterrupted();\n```\n\n很显然，这个方法不是一个static方法，作用于这个方法的对象，如下。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n\t    myThread.interrupt();\n        System.out.println(\"线程是否停止？\" + myThread.isInterrupted()); // 输出 true\n        System.out.println(\"线程是否停止？\" + myThread.isInterrupted()); // 输出 true\n        System.out.println(\"END!\");\n    }\n}\n```\n\n综上所述，两者区别如下：\n\n（1）Thread.interrupted() 测试线程是否已经中断，执行后具有清除状态标志值为false的功能；\n\n（2）new Thread().isInterrupted() 测试线程Thread对象是否已经是中断状态，不清除状态标志；\n\n### 四、 能停止的线程——异常法\n\n​\t在main方法中两秒后调用 Thread 对象的 myThread.interrupt() 方法，在线程中的for循环中加入 if 判断后面的代码是否可以运行。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(500);\n        myThread.interrupt();\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        try {\n            for (int i = 0; i < 5000000; i++) {\n                if (interrupted()) {\n                    System.out.println(\"线程已经停止\");\n                    // 退出当前循环，如果为 return; 或 throw new InterruptedException() 则直接退出当前线程\n                    throw new InterruptedException();\n                }\n                System.out.println(\"i=\" + (i + 1));\n            }\n            System.out.println(\"for循环外面的语句\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n抛出异常方式详情：\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) {\n        try {\n            MyThread myThread = new MyThread();\n            myThread.start();\n            Thread.sleep(1000);\n            myThread.interrupt();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        try {\n            for (int i = 0; i < 5000000; i++) {\n                if (interrupted()) {\n                    System.out.println(\"线程已经停止\");\n                    throw new InterruptedException();\n                }\n                System.out.println(\"i=\" + (i + 1));\n            }\n            System.out.println(\"for循环外面的语句\");\n        } catch (Exception e) {\n            System.out.println(\"抛出异常\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n通过下面的运行结果可以看出，线程终于被正确的停止了。\n\n```java\ni=312961\ni=312962\n线程已经停止\n抛出异常\njava.lang.InterruptedException\n\tat com.fun.async.test.class03.MyThread.run(ThreadInterrupt.java:34)\n```\n\n### 五、在 sleep 状态下停止线程\n\n``` java\npublic class SleepThreadInterrupt {\n    public static void main(String[] args) {\n        try {\n            MyThread thread = new MyThread();\n            thread.start();\n            Thread.sleep(200); // 先sleep 在调用 interrupt\n            thread.interrupt();\n            System.out.println(\"complete!\");\n        } catch (InterruptedException e) {\n            System.out.println(\"main catch\");\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread extends Thread{\n        @Override\n        public void run() {\n            super.run();\n            try {\n                System.out.println(\"run start ...\");\n                Thread.sleep(200000);\n                System.out.println(\"run end!\");\n            } catch (InterruptedException e) {\n                System.out.println(\"在sleep中停止，进入catch！\"+this.isInterrupted());\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n从下面的输出结果来看，如果线程在 sleep 状态下停止，则该线程会进入 catch 语句，并且清除停止状态值，变成false。\n\n``` java\nrun start ...\ncomplete!\n在sleep中停止，进入catch！false\njava.lang.InterruptedException: sleep interrupted\n\tat java.lang.Thread.sleep(Native Method)\n\tat com.fun.async.test.class03.SleepThreadInterrupt$MyThread.run(SleepThreadInterrupt.java:26)\n\n```\n\n","slug":"Java并发 - interrupt+isInterrupted","published":1,"updated":"2022-02-28T10:55:00.713Z","layout":"post","photos":[],"link":"","_id":"cl0atbcp1000j7cu58kr47skc","content":"<h2 id=\"线程-停止\"><a href=\"#线程-停止\" class=\"headerlink\" title=\"线程 - 停止\"></a>线程 - 停止</h2><h3 id=\"一、-废弃的停止方法\"><a href=\"#一、-废弃的停止方法\" class=\"headerlink\" title=\"一、 废弃的停止方法\"></a>一、 废弃的停止方法</h3><p>​        看到这个标题就能想到：Thread.stop()。Java中的多线程可不像break语句那么干脆。</p>\n<p>​        stop、suspend、resume 这三个过期作废的方法是不推荐使用的，因为有可能会发生不可预料的结果而且出现错误后还难定位。</p>\n<p>​        不推荐使用 Thread.stop() 的原因。这个方法是从外面让线程<strong>强制停止</strong>，如果停止的线程持有一个临界锁， 把一个对象置于一个不一致的状态（包含临界、持久化、游离），说白了就是造成数据不一致的结果。</p>\n<p>​        大多数情况下，停止一个线程使用  Thread.interrupt() 方法，但是这个方法不会终止一个正在运行状态的线程，还需要加入一些判断才能完成停止线程。</p>\n<p>​        在Java中有3种方式停止正在运行的线程：</p>\n<p>​        1、使用退出标志，正常退出；</p>\n<p>​        2、使用 stop()， 强行终止；</p>\n<p>​        3、使用 interrupt() 方法，中断线程；</p>\n<h3 id=\"二、interrupt-初体验\"><a href=\"#二、interrupt-初体验\" class=\"headerlink\" title=\"二、interrupt() 初体验\"></a>二、interrupt() 初体验</h3><p>​    一上来就按照下面这种方式运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        myThread.interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;mrdjun&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现结果输出了 <strong>1000000</strong> 行，而且 mrdjun 还输出在了中间，说明 interrupt 并没有让线程停下来。</p>\n<h3 id=\"三、判断线程是否为停止状态\"><a href=\"#三、判断线程是否为停止状态\" class=\"headerlink\" title=\"三、判断线程是否为停止状态\"></a>三、判断线程是否为停止状态</h3><p>​    下面Java提供了两个判断线程是否为停止状态的方法。</p>\n<p>​    public static boolean interrupted() ：使用 Thread.interrupted() 测试当前线程是否已经中断，执行后清楚状态标志值为 false 的功能。</p>\n<p>​    public boolean this.isInterrupted()： 测试 this 关键字所在类的对象是否已经中断，不清楚标志。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        myThread.interrupt(); <span class=\"comment\">// 作用于 myThread 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// isInterrupted 测试当前线程是否已经中断</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+myThread.isInterrupted());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+myThread.isInterrupted());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        补充一点：也可以使用 Thread.interrupted() 来判断当前线程是否已经中断，因为在 Thread.java 这个类中调用静态static方法的时候，大多数是针对 currentThread() 线程进行操作的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">      \tThread.currentThread().interrupt(); <span class=\"comment\">// 作用于 Thread</span></span><br><span class=\"line\">        <span class=\"comment\">// isInterrupted 测试当前线程是否已经中断</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+ Thread.interrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+ Thread.interrupted()); <span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;END!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>出乎意料的是结果输出不一致，查看官方帮助文档中的 interrupted() 解释：</p>\n<blockquote>\n<p>测试当前线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。</p>\n</blockquote>\n<p>isInterrupted() 的方法声明如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isInterrupted</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>很显然，这个方法不是一个static方法，作用于这个方法的对象，如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t    myThread.interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span> + myThread.isInterrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span> + myThread.isInterrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;END!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>综上所述，两者区别如下：</p>\n<p>（1）Thread.interrupted() 测试线程是否已经中断，执行后具有清除状态标志值为false的功能；</p>\n<p>（2）new Thread().isInterrupted() 测试线程Thread对象是否已经是中断状态，不清除状态标志；</p>\n<h3 id=\"四、-能停止的线程——异常法\"><a href=\"#四、-能停止的线程——异常法\" class=\"headerlink\" title=\"四、 能停止的线程——异常法\"></a>四、 能停止的线程——异常法</h3><p>​    在main方法中两秒后调用 Thread 对象的 myThread.interrupt() 方法，在线程中的for循环中加入 if 判断后面的代码是否可以运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        myThread.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000000</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (interrupted()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;线程已经停止&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 退出当前循环，如果为 return; 或 throw new InterruptedException() 则直接退出当前线程</span></span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterruptedException</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;for循环外面的语句&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抛出异常方式详情：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">            myThread.start();</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            myThread.interrupt();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000000</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (interrupted()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;线程已经停止&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterruptedException</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;for循环外面的语句&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;抛出异常&quot;</span>);</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过下面的运行结果可以看出，线程终于被正确的停止了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i=<span class=\"number\">312961</span></span><br><span class=\"line\">i=<span class=\"number\">312962</span></span><br><span class=\"line\">线程已经停止</span><br><span class=\"line\">抛出异常</span><br><span class=\"line\">java.lang.InterruptedException</span><br><span class=\"line\">\tat com.fun.async.test.class03.MyThread.run(ThreadInterrupt.java:<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、在-sleep-状态下停止线程\"><a href=\"#五、在-sleep-状态下停止线程\" class=\"headerlink\" title=\"五、在 sleep 状态下停止线程\"></a>五、在 sleep 状态下停止线程</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SleepThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">MyThread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">200</span>); <span class=\"comment\">// 先sleep 在调用 interrupt</span></span><br><span class=\"line\">            thread.interrupt();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;complete!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;main catch&quot;</span>);</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;run start ...&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">200000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;run end!&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;在sleep中停止，进入catch！&quot;</span>+<span class=\"built_in\">this</span>.isInterrupted());</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从下面的输出结果来看，如果线程在 sleep 状态下停止，则该线程会进入 catch 语句，并且清除停止状态值，变成false。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">run start ...</span><br><span class=\"line\">complete!</span><br><span class=\"line\">在sleep中停止，进入<span class=\"keyword\">catch</span>！<span class=\"literal\">false</span></span><br><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">\tat java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">\tat com.fun.async.test.class03.SleepThreadInterrupt$MyThread.run(SleepThreadInterrupt.java:<span class=\"number\">26</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"线程-停止\"><a href=\"#线程-停止\" class=\"headerlink\" title=\"线程 - 停止\"></a>线程 - 停止</h2><h3 id=\"一、-废弃的停止方法\"><a href=\"#一、-废弃的停止方法\" class=\"headerlink\" title=\"一、 废弃的停止方法\"></a>一、 废弃的停止方法</h3><p>​        看到这个标题就能想到：Thread.stop()。Java中的多线程可不像break语句那么干脆。</p>\n<p>​        stop、suspend、resume 这三个过期作废的方法是不推荐使用的，因为有可能会发生不可预料的结果而且出现错误后还难定位。</p>\n<p>​        不推荐使用 Thread.stop() 的原因。这个方法是从外面让线程<strong>强制停止</strong>，如果停止的线程持有一个临界锁， 把一个对象置于一个不一致的状态（包含临界、持久化、游离），说白了就是造成数据不一致的结果。</p>\n<p>​        大多数情况下，停止一个线程使用  Thread.interrupt() 方法，但是这个方法不会终止一个正在运行状态的线程，还需要加入一些判断才能完成停止线程。</p>\n<p>​        在Java中有3种方式停止正在运行的线程：</p>\n<p>​        1、使用退出标志，正常退出；</p>\n<p>​        2、使用 stop()， 强行终止；</p>\n<p>​        3、使用 interrupt() 方法，中断线程；</p>\n<h3 id=\"二、interrupt-初体验\"><a href=\"#二、interrupt-初体验\" class=\"headerlink\" title=\"二、interrupt() 初体验\"></a>二、interrupt() 初体验</h3><p>​    一上来就按照下面这种方式运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        myThread.interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;mrdjun&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现结果输出了 <strong>1000000</strong> 行，而且 mrdjun 还输出在了中间，说明 interrupt 并没有让线程停下来。</p>\n<h3 id=\"三、判断线程是否为停止状态\"><a href=\"#三、判断线程是否为停止状态\" class=\"headerlink\" title=\"三、判断线程是否为停止状态\"></a>三、判断线程是否为停止状态</h3><p>​    下面Java提供了两个判断线程是否为停止状态的方法。</p>\n<p>​    public static boolean interrupted() ：使用 Thread.interrupted() 测试当前线程是否已经中断，执行后清楚状态标志值为 false 的功能。</p>\n<p>​    public boolean this.isInterrupted()： 测试 this 关键字所在类的对象是否已经中断，不清楚标志。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        myThread.interrupt(); <span class=\"comment\">// 作用于 myThread 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// isInterrupted 测试当前线程是否已经中断</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+myThread.isInterrupted());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+myThread.isInterrupted());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        补充一点：也可以使用 Thread.interrupted() 来判断当前线程是否已经中断，因为在 Thread.java 这个类中调用静态static方法的时候，大多数是针对 currentThread() 线程进行操作的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">      \tThread.currentThread().interrupt(); <span class=\"comment\">// 作用于 Thread</span></span><br><span class=\"line\">        <span class=\"comment\">// isInterrupted 测试当前线程是否已经中断</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+ Thread.interrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+ Thread.interrupted()); <span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;END!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>出乎意料的是结果输出不一致，查看官方帮助文档中的 interrupted() 解释：</p>\n<blockquote>\n<p>测试当前线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。</p>\n</blockquote>\n<p>isInterrupted() 的方法声明如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isInterrupted</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>很显然，这个方法不是一个static方法，作用于这个方法的对象，如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t    myThread.interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span> + myThread.isInterrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span> + myThread.isInterrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;END!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>综上所述，两者区别如下：</p>\n<p>（1）Thread.interrupted() 测试线程是否已经中断，执行后具有清除状态标志值为false的功能；</p>\n<p>（2）new Thread().isInterrupted() 测试线程Thread对象是否已经是中断状态，不清除状态标志；</p>\n<h3 id=\"四、-能停止的线程——异常法\"><a href=\"#四、-能停止的线程——异常法\" class=\"headerlink\" title=\"四、 能停止的线程——异常法\"></a>四、 能停止的线程——异常法</h3><p>​    在main方法中两秒后调用 Thread 对象的 myThread.interrupt() 方法，在线程中的for循环中加入 if 判断后面的代码是否可以运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        myThread.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000000</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (interrupted()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;线程已经停止&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 退出当前循环，如果为 return; 或 throw new InterruptedException() 则直接退出当前线程</span></span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterruptedException</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;for循环外面的语句&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抛出异常方式详情：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">            myThread.start();</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            myThread.interrupt();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000000</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (interrupted()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;线程已经停止&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterruptedException</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;for循环外面的语句&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;抛出异常&quot;</span>);</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过下面的运行结果可以看出，线程终于被正确的停止了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i=<span class=\"number\">312961</span></span><br><span class=\"line\">i=<span class=\"number\">312962</span></span><br><span class=\"line\">线程已经停止</span><br><span class=\"line\">抛出异常</span><br><span class=\"line\">java.lang.InterruptedException</span><br><span class=\"line\">\tat com.fun.async.test.class03.MyThread.run(ThreadInterrupt.java:<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"五、在-sleep-状态下停止线程\"><a href=\"#五、在-sleep-状态下停止线程\" class=\"headerlink\" title=\"五、在 sleep 状态下停止线程\"></a>五、在 sleep 状态下停止线程</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SleepThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">MyThread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">200</span>); <span class=\"comment\">// 先sleep 在调用 interrupt</span></span><br><span class=\"line\">            thread.interrupt();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;complete!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;main catch&quot;</span>);</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;run start ...&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">200000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;run end!&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;在sleep中停止，进入catch！&quot;</span>+<span class=\"built_in\">this</span>.isInterrupted());</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从下面的输出结果来看，如果线程在 sleep 状态下停止，则该线程会进入 catch 语句，并且清除停止状态值，变成false。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">run start ...</span><br><span class=\"line\">complete!</span><br><span class=\"line\">在sleep中停止，进入<span class=\"keyword\">catch</span>！<span class=\"literal\">false</span></span><br><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">\tat java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">\tat com.fun.async.test.class03.SleepThreadInterrupt$MyThread.run(SleepThreadInterrupt.java:<span class=\"number\">26</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"synchronized关键字","date":"2021-06-07T05:58:00.000Z","comments":0,"_content":"\nsynchronized（悲观锁又叫独享锁） 用于保障原子性、可见性、有序性。\n\nsynchronized 属于最基本的线程通信机制，基于对象监视器实现的，Java中每个对象都与一个监视器相关联，一个线程可以锁的或解锁，一次只有一个线程可以锁定监视器，试图锁定该监视器的任何其它线程都会被阻塞，直到它们可以获得该监视器上的锁定为止。\n\n## 方法内的变量为线程安全\n\n非线程安全问题存在于实例变量中，如果是方法内部的私有变量，则不存在非线程安全问题，所得到的结果是线程安全的。\n\n**原因**\n\n（1）方法内部的变量为方法私有的变量，其生存周期随着方法的结束而终结。\n（2）每个线程执行的时候会把局部变量存放在各自栈帧的工作内存中（栈帧进入虚拟机栈），虚拟机栈线程间不共享，故不存在线程安全问题。\n\n方法内部的变量线程安全验证案例：\n\n```java\npublic class HasSelfPrivateNum_1 {\n\n    public void addI(String str) {\n        try {\n            int num = 0;\n            if (str.equals(\"a\")) {\n                num = 100;\n                System.out.println(\"a set over!\");\n                Thread.sleep(200);\n            } else {\n                num = 200;\n                System.out.println(\"b set over!\");\n            }\n            System.out.println(str + \" num=\" + num);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ThreadA extends Thread {\n    private HasSelfPrivateNum_1 numRef;\n\n    public ThreadA(HasSelfPrivateNum_1 numRef) {\n        this.numRef = numRef;\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        numRef.addI(\"a\");\n    }\n}\n\nclass ThreadB extends Thread {\n    private HasSelfPrivateNum_1 numRef;\n\n    public ThreadB(HasSelfPrivateNum_1 numRef) {\n        this.numRef = numRef;\n    }\n    @Override\n    public void run() {\n        super.run();\n        numRef.addI(\"b\");\n    }\n}\n\nclass ThreadTest0216{\n    public static void main(String[] args) {\n        HasSelfPrivateNum_1 privateNum = new HasSelfPrivateNum_1();\n        ThreadA threadA  = new ThreadA(privateNum);\n        threadA.start();\n\n        ThreadB threadB = new ThreadB(privateNum);\n        threadB.start();\n    }\n}\n```\n\n执行结果\n\n```\na set over!\nb set over!\nb num=200\na num=100\n```\n\n## 实例变量非线程安全问题与解决方案\n\n- 如果多个线程共同访问一个对象中的实例变量，则有可能出现非线程安全问题；\n- 用多线程访问的对象中如果有多个实例变量，则运行结果有可能会出现交叉的情况。\n- 如果对象仅有一个实例变量，则有可能出现覆盖的情况。\n\n```java\npublic class HasSelfPrivateNum_2 {\n    private int num = 0;\n\n    public void addI(String str) {\n        try {\n            if (str.equals(\"a\")) {\n                num = 100;\n                System.out.println(\"a set over!\");\n                Thread.sleep(200);\n            } else {\n                num = 200;\n                System.out.println(\"b set over!\");\n            }\n            System.out.println(str + \" num=\" + num);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ThreadC extends Thread {\n    private HasSelfPrivateNum_2 numRef;\n\n    public ThreadC(HasSelfPrivateNum_2 numRef) {\n        this.numRef = numRef;\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        numRef.addI(\"a\");\n    }\n}\n\nclass ThreadD extends Thread {\n    private HasSelfPrivateNum_2 numRef;\n\n    public ThreadD(HasSelfPrivateNum_2 numRef) {\n        this.numRef = numRef;\n    }\n    @Override\n    public void run() {\n        super.run();\n        numRef.addI(\"b\");\n    }\n}\n\nclass ThreadTest02162{\n    public static void main(String[] args) {\n        HasSelfPrivateNum_2 privateNum = new HasSelfPrivateNum_2();\n        ThreadC threadC  = new ThreadC(privateNum);\n        threadC.start();\n\n        ThreadD threadD = new ThreadD(privateNum);\n        threadD.start();\n    }\n}\n```\n\n执行结果\n\n```\na set over!\nb set over!\nb num=200\na num=200\n```\n\n上面这个案例是两个线程同时访问同一个业务对象中的一个没有同步的方法，如果线程同时操作业务对象中的变量，则有可能出现非线程安全问题。\n\n解决上面这个错误，在 public void addI(String str) 方法前加关键字 synchronized 即可。\n\n\n\n## 同步代码块\n\nsysnchronized(**同步监视器**){\n\n  // 需要被同步的代码块(即为**共享数据**的代码)\n\n}\n\n1） 共享数据：多个线程共同操作的同一个数据（变量） \n\n2） 同步监视器：有一个类的对象来充当。哪个线程获取此监视器，谁就去执行大括号里被同步的代码。俗称：锁。要求所有的线程共用同一把锁。\n\n下面提供一个用同步代码块的方式解决**数据共享的安全**问题：\n\n**实例**\n\n```java\nclass W implements Runnable{\n    int ticket = 100;\n    // Object obj = new Object();\n    public void run(){\n        while(true) {\n            /*\n              在继承中一定要慎用this\n              严格控制：要求所有的线程共用同一把锁，\n              也就是说这个this代表同一个对象的时候才能够使用。\n             */\n            synchronized (this) {\n                if (ticket > 0) {\n                    try{\n                        Thread.currentThread().sleep(100);\n                        System.out.println(Thread.currentThread().getName() + \"售票，余票为：\" + ticket--);\n                    }catch (InterruptedException e){\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\npublic class TestThreadSecurity {\n    public static void main(String[] args){\n        W window = new W();\n        Thread window1 = new Thread(window);\n        Thread window2 = new Thread(window);\n        Thread window3 = new Thread(window);\n\n        window1.setName(\"窗口1\");\n        window2.setName(\"窗口2\");\n        window3.setName(\"窗口3\");\n\n        window1.start();\n        window2.start();\n        window3.start();\n    }\n}\n```\n\n##  同步方法\n\n将操作共享数据的方法声明为sysnchronized。即此方法，能够保证其中一个线程执行此方法时，其它线程在外等待直至此线程执行完此方法。\n\n同步方法的锁：this。\n\n```java\nclass Win implements Runnable{\n    int ticket = 100;\n    // Object obj = new Object();\n    public void run(){\n        while(true){\n            show();\n        }\n    }\n    public synchronized void show(){\n        if (ticket > 0 ){\n            try{\n                Thread.currentThread().sleep(10);\n                System.out.println(Thread.currentThread().getName()+\"售票，余票为：\"+ticket--);\n            }catch (InterruptedException e){\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\npublic class TestThreadSecurity2 {\n    public static void main(String[] args){\n        Win window = new Win();\n        Thread window1 = new Thread(window);\n        Thread window2 = new Thread(window);\n        Thread window3 = new Thread(window);\n\n        window1.setName(\"窗口1\");\n        window2.setName(\"窗口2\");\n        window3.setName(\"窗口3\");\n\n        window1.start();\n        window2.start();\n        window3.start();\n    }\n}\n```\n\n 这里还涉及到一个**互斥锁**的概念。\n\n先了解一下单例模式：https://blog.csdn.net/qq_41647999/article/details/83447936\n\n单例模式一般用于比较大、复杂的对象，只初始化一次，应该还有一个private的构造函数，使得不能用new来实例化对象，只能调用getInstance方法来得到对象，而getInstance保证了每次调用都返回相同的对象。\n\n这里在举一个实例，解释在代码里：\n\n```java\nclass Singleton{\n    private Singleton(){\n\n    }\n    /*\n    这里存在一个问题， 两个线程（A、B）分别调用getInstance方法，\n    首次调用的时候，instance肯定为null，A在创建Singleton之前被挂起，\n    线程B进入之后也被挂起，当前的instance仍然为null。此时A继续执行\n    创建一个Singleton对象，假设此时在内存中的地址为1111，线程B执行之后\n    也会创建一个对象，大家肯定都知道在内存中的值一定不为1111，\n    像这样返回出去的判断相等不相等的时候就有问题了。为什么呢？因为在这里的instance\n    只能够new一次，这种情况却new了两次。\n     */\n    private static Singleton instance = null;\n    /*\n    这里为什么要判断一次instance为null？\n    假设这里只有一家华为手机店（这里的代码块），店里面只有一台mate20，\n    门口排了一大堆的人（线程）来买mate20，第一个人肯定买的到，后面的人\n    就买不到了，但是没有人告诉后面的人卖完了，每个人还得进店一次。所以\n    这里的instance不为null的时候，就是告诉后面的线程，说这里的mate20\n    已经卖完了，不用排队了。\n    */\n    if (instance == null ){\n    public static Singleton getInstance(){\n        if (instance == null ){\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n}\n\npublic class TestSingleton {\n    public static void main(String[] args) {\n        /*\n        getInstance在单例模式(保证一个类仅有一个实例，\n        并提供一个访问它的全局访问点)的类中常见，\n        用来生成唯一的实例，getInstance一般是static的\n         */\n        Singleton s1 = Singleton.getInstance();\n        Singleton s2 = Singleton.getInstance();\n        System.out.println(s1 == s2);\n    }\n}\n```\n\n**上例BUG修复**\n\n```java\nclass Singleton2{\n    private Singleton2(){\n\n    }\n\n    private static Singleton2 instance = null;\n    public static Singleton2 getInstance() {\n        /*\n        1、 static里面不能使用this\n        2、 关于解决懒汉式的线程安全问题，需要使用同步机制\n        3、 对于静态方法而言，使用当前类本身充当锁\n         */\n        synchronized (Singleton2.class) {\n            /*\n            关于这里为什么使用Singleton2.class为什么能行，涉及到反射的知识点。\n             */\n            if (instance == null) {\n                instance = new Singleton2();\n            }\n            \n        }\n        return instance;\n    }\n}\n\npublic class TestSingleton2 {\n    public static void main(String[] args) {\n        Singleton2 s1 = Singleton2.getInstance();\n        Singleton2 s2 = Singleton2.getInstance();\n        System.out.println(s1 == s2);\n    }\n}\n```\n\n## 同步synchronized在字节码指令中的原理（浅）\n\n​\t在方法中使用synchronized关键字实现同步的原因是使用了flag标记ACC_SYNCHRONIZED.当调用方法时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否设置，如果设置了，执行线程先持有同步锁，然后执行方法，最后在方法完成时释放锁。\n```java\n/**\n *  public static synchronized void testMethod();\n *     descriptor: ()V\n *     flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED\n *     Code:\n *       stack=0, locals=0, args_size=0\n *          0: return\n *       LineNumberTable:\n *         line 26: 0\n *\n *       在翻编译的字节码指令，对public synchronized.viod myMethod()方法使用\n *   了flag标记ACC_SYNCHRONIZED,说明此方法是同步的。\n *\n *\n *\n *  public void myMethod();\n *     descriptor: ()V\n *     flags: ACC_PUBLIC\n *     Code:\n *       stack=2, locals=4, args_size=1\n *          0: aload_0\n *          1: dup\n *          2: astore_1\n *          3: monitorenter\n *          4: bipush        100\n *          6: istore_2\n *          7: aload_1\n *          8: monitorexit\n *          9: goto          17\n *         12: astore_3\n *         13: aload_1\n *         14: monitorexit\n *         15: aload_3\n *         16: athrow\n *         17: return\n *\n *         在字节码中使用monitorenter和monitorexit指令进行同步处理\n *         同步：按顺序执行A和B这两个业务，就是同步\n *         异步：执行A业务的时候，B业务也在同时执行，这就是异步。\n */\nclass Test {\n    synchronized public static void testMethod(){\n\t\t\n    }\n    public static void Test()throws InterruptedException{\n        testMethod();\n    }\n}\npublic class Test2 {\n\t//  如果使用synchronized代码块，则使用 monitorenter 和 monitorexit 指令进行同步处理。\n     public void myMethod(){\n        synchronized (this){\n            int age=100;\n        }\n    }\n    public static void main(String[] args)throws InterruptedException {\n     \tTest2 test = new Test2();\n        test.myMethod();\t\n    }\n}\n```\n\n## 将 Synchronized 方法与对象作为锁\n\n有一个对象 object 中有 a 和 b 两个方法，有 t1 和 t2 两个线程，t1 调用方法 a，t2调用方法b，请问以下情况两个线程的执行顺序是怎样的？\n\n（1）如果 a 加了同步锁，b没加。执行顺序：t1 持有 object 对象的 lock 锁，t2 可以以异步的方式调用object中的非同步锁的方法，所以 t1 和 t2 是同时执行的。\n\n（2）如果 a 加了同步锁，b也加了。执行顺序：在方法声明处添加 synchronized 并不是锁方法，而是锁当前类的对象，所以根据t1 和 t2 的调用顺序来执行的。\n\n注意：\n\n- 在Java 中，只有将对象作为锁这种说法，没有锁方法这种说法。\n- 在Java中，锁就是对象，对象可以映射成锁，哪个线程拿到这把锁，哪个线程就可以执行这个对象中的 synchronized 同步方法。\n- 如果在某对象中使用了 synchronized 关键字声明非静态方法，那么这个对象就被当成锁。\n\n> 这里存在一个误区：synchronized修饰方法时，如果该方法没有static关键字不是静态方法，则锁的只是这个对象，也就是说在另一个线程中新创建一个这个类的对象，两个线程操作不是同一把锁是不会产生竞态条件的。如果该方法上使用了静态关键字，则当前锁锁的是这个对象的类，使用该类重新创建对象多个线程的操作该对象都会产生静态条件。\n\n## synchronized 锁重入\n\n> 问题导入：如果一个线程调用了一个对象的同步方法，那么他还能不能在调用这个对象的另外一个同步方法呢？\n\nsynchronized 锁拥有重入锁的功能，当一个线程得到对象锁之后，再次请求此对象锁时是可以获取到该对象锁的，也就可以在一个 synchronized 方法 / 块的内部调用本类的其它加锁的方法 / 块，是永远可以得到锁的。\n\n```java\npublic class Service{\n    public synchronized  void fun1(){\n        System.out.println(\"一号同步方法\");\n        fun2();\n    }\n\n    public synchronized void fun2(){\n        System.out.println(\"二号同步方法\");\n        fun3();\n    }\n\n    public synchronized void fun3(){\n        System.out.println(\"三号同步方法\");\n    }\n}\n```\n\n```java\npublic class MyThread extends Thread {\n    private Service service;\n    \n    public SynThreadText(Service service){\n        this.service=service;\n    }\n    \n    @Override\n    public void run(){\n        service.fun1();\n    }\n\n    public static void main(String[] args) {\n        Service service = new Service();\n        MyThread myThread = new MyThread(service);\n        myThread.start();\n    }\n}\n```\n\n执行结果：\n\n```\n一号同步方法\n二号同步方法\n三号同步方法\n```\n\n## synchronized 锁重入支持父类继承\n\n既然 synchronized 支持对象的方法重入，那么他是否也支持子类继承父类的同步方法重入呢？\n\n```java\npublic class SubClass extends SuperClass implements Runnable {\n    @Override\n    public void run(){\n        this.subFun();\n    }\n\t\n    public synchronized  void subFun(){\n        System.out.println(\"子类的同步方法\");\n        this.superSynFun();\n    }\n\t\n    public static void main(String[] args) {\n        SubClass sub = new SubClass();\n        Thread t = new Thread(sub);\n        t.start();\n    }\n\n}\n\nclass SuperClass{\n    public synchronized void superSynFun(){\n        System.out.println(\"父类的同步方法\");\n    }\n}\n```\n\n执行结果：\n\n```\n子类的同步方法\n父类的同步方法\n```\n\n如果被重写的方法有synchronized关键字，在所重写方法如果不加 synchronized  修饰，那就是非同步方法。\n\n## 锁的范围\n\n类锁、对象锁、锁粗化、锁消除\n\n锁粗化：指JIT对于高频调用的方法，将该方法中的多个锁合并成一个锁。因为锁的请求、同步以及释放都会带来性能损耗。\n\n```java\npublic void test(){\n    synchronized(lock){\n        //do some thing\n    }\n    // 被JIT优化后，会直接跳过该方法。可通过JITWatch查看运行的过程\n    synchronized(lock){\n        //do other thing\n    }\n}\n```\n\n锁消除：指JIT对不需要加锁的代码却执行了加锁的操作进行锁的消除。\n\n例如，StringBuffer类的append() 方法使用了 synchronized 关键字，是线程安全的，但是仅用在线程封闭的环境中，则锁会浪费资源，JIT就会对锁进行消除。\n\n## 深入理解synchronized原理\n\nsynchronized关键字不仅实现同步，根据JMM规定还能保证可见性（读取最新主内存数据，结束后写入主内存）。\n\n![image-20210423124817593](.\\images\\synchronized关键字的原理.png)\n\n在HotSpot中，由Mark Word、Class Metadata Address、Array Length三部份组成。\n\n- Mark Word：在Mark Word中有一块内存空间，不同的虚拟机有不同的做法，在其中有一个对应的状态关键字State对应有锁还是无锁，是轻量级锁还是重量级锁，是否被GC了。左边bitfields中存放的是数据，不同的状态下存放对应的数据。  \n- Class Metadata Address：存储对对象（Class）的描述，例如类中的某个属性对应哪一块内存地址。\n- Array Length：存储数据的格式。\n\n在JVM中，加锁会经历：偏向锁 -> 轻量级锁 -> 重量级锁这四个状态。\n\n偏向锁：本质就是无锁，如果没有发生任何多线程争抢锁的情况，JVM认为就是单线程，无需做同步。\n\n![image-20210429101554456](.\\images\\JVM-从偏向锁到重量级锁的过程.png)\n\n重量级锁 - 监视器（monitor）\n\n![image-20210429101903740](.\\images\\重量级锁监视器(monitor)原理.png)\n\n","source":"_posts/Java并发 - synchronized.md","raw":"---\ntitle: synchronized关键字\ndate: 2021-06-07 13:58:00\ntags:\n  - JUC并发包\ncomments: false\n---\n\nsynchronized（悲观锁又叫独享锁） 用于保障原子性、可见性、有序性。\n\nsynchronized 属于最基本的线程通信机制，基于对象监视器实现的，Java中每个对象都与一个监视器相关联，一个线程可以锁的或解锁，一次只有一个线程可以锁定监视器，试图锁定该监视器的任何其它线程都会被阻塞，直到它们可以获得该监视器上的锁定为止。\n\n## 方法内的变量为线程安全\n\n非线程安全问题存在于实例变量中，如果是方法内部的私有变量，则不存在非线程安全问题，所得到的结果是线程安全的。\n\n**原因**\n\n（1）方法内部的变量为方法私有的变量，其生存周期随着方法的结束而终结。\n（2）每个线程执行的时候会把局部变量存放在各自栈帧的工作内存中（栈帧进入虚拟机栈），虚拟机栈线程间不共享，故不存在线程安全问题。\n\n方法内部的变量线程安全验证案例：\n\n```java\npublic class HasSelfPrivateNum_1 {\n\n    public void addI(String str) {\n        try {\n            int num = 0;\n            if (str.equals(\"a\")) {\n                num = 100;\n                System.out.println(\"a set over!\");\n                Thread.sleep(200);\n            } else {\n                num = 200;\n                System.out.println(\"b set over!\");\n            }\n            System.out.println(str + \" num=\" + num);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ThreadA extends Thread {\n    private HasSelfPrivateNum_1 numRef;\n\n    public ThreadA(HasSelfPrivateNum_1 numRef) {\n        this.numRef = numRef;\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        numRef.addI(\"a\");\n    }\n}\n\nclass ThreadB extends Thread {\n    private HasSelfPrivateNum_1 numRef;\n\n    public ThreadB(HasSelfPrivateNum_1 numRef) {\n        this.numRef = numRef;\n    }\n    @Override\n    public void run() {\n        super.run();\n        numRef.addI(\"b\");\n    }\n}\n\nclass ThreadTest0216{\n    public static void main(String[] args) {\n        HasSelfPrivateNum_1 privateNum = new HasSelfPrivateNum_1();\n        ThreadA threadA  = new ThreadA(privateNum);\n        threadA.start();\n\n        ThreadB threadB = new ThreadB(privateNum);\n        threadB.start();\n    }\n}\n```\n\n执行结果\n\n```\na set over!\nb set over!\nb num=200\na num=100\n```\n\n## 实例变量非线程安全问题与解决方案\n\n- 如果多个线程共同访问一个对象中的实例变量，则有可能出现非线程安全问题；\n- 用多线程访问的对象中如果有多个实例变量，则运行结果有可能会出现交叉的情况。\n- 如果对象仅有一个实例变量，则有可能出现覆盖的情况。\n\n```java\npublic class HasSelfPrivateNum_2 {\n    private int num = 0;\n\n    public void addI(String str) {\n        try {\n            if (str.equals(\"a\")) {\n                num = 100;\n                System.out.println(\"a set over!\");\n                Thread.sleep(200);\n            } else {\n                num = 200;\n                System.out.println(\"b set over!\");\n            }\n            System.out.println(str + \" num=\" + num);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ThreadC extends Thread {\n    private HasSelfPrivateNum_2 numRef;\n\n    public ThreadC(HasSelfPrivateNum_2 numRef) {\n        this.numRef = numRef;\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        numRef.addI(\"a\");\n    }\n}\n\nclass ThreadD extends Thread {\n    private HasSelfPrivateNum_2 numRef;\n\n    public ThreadD(HasSelfPrivateNum_2 numRef) {\n        this.numRef = numRef;\n    }\n    @Override\n    public void run() {\n        super.run();\n        numRef.addI(\"b\");\n    }\n}\n\nclass ThreadTest02162{\n    public static void main(String[] args) {\n        HasSelfPrivateNum_2 privateNum = new HasSelfPrivateNum_2();\n        ThreadC threadC  = new ThreadC(privateNum);\n        threadC.start();\n\n        ThreadD threadD = new ThreadD(privateNum);\n        threadD.start();\n    }\n}\n```\n\n执行结果\n\n```\na set over!\nb set over!\nb num=200\na num=200\n```\n\n上面这个案例是两个线程同时访问同一个业务对象中的一个没有同步的方法，如果线程同时操作业务对象中的变量，则有可能出现非线程安全问题。\n\n解决上面这个错误，在 public void addI(String str) 方法前加关键字 synchronized 即可。\n\n\n\n## 同步代码块\n\nsysnchronized(**同步监视器**){\n\n  // 需要被同步的代码块(即为**共享数据**的代码)\n\n}\n\n1） 共享数据：多个线程共同操作的同一个数据（变量） \n\n2） 同步监视器：有一个类的对象来充当。哪个线程获取此监视器，谁就去执行大括号里被同步的代码。俗称：锁。要求所有的线程共用同一把锁。\n\n下面提供一个用同步代码块的方式解决**数据共享的安全**问题：\n\n**实例**\n\n```java\nclass W implements Runnable{\n    int ticket = 100;\n    // Object obj = new Object();\n    public void run(){\n        while(true) {\n            /*\n              在继承中一定要慎用this\n              严格控制：要求所有的线程共用同一把锁，\n              也就是说这个this代表同一个对象的时候才能够使用。\n             */\n            synchronized (this) {\n                if (ticket > 0) {\n                    try{\n                        Thread.currentThread().sleep(100);\n                        System.out.println(Thread.currentThread().getName() + \"售票，余票为：\" + ticket--);\n                    }catch (InterruptedException e){\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\npublic class TestThreadSecurity {\n    public static void main(String[] args){\n        W window = new W();\n        Thread window1 = new Thread(window);\n        Thread window2 = new Thread(window);\n        Thread window3 = new Thread(window);\n\n        window1.setName(\"窗口1\");\n        window2.setName(\"窗口2\");\n        window3.setName(\"窗口3\");\n\n        window1.start();\n        window2.start();\n        window3.start();\n    }\n}\n```\n\n##  同步方法\n\n将操作共享数据的方法声明为sysnchronized。即此方法，能够保证其中一个线程执行此方法时，其它线程在外等待直至此线程执行完此方法。\n\n同步方法的锁：this。\n\n```java\nclass Win implements Runnable{\n    int ticket = 100;\n    // Object obj = new Object();\n    public void run(){\n        while(true){\n            show();\n        }\n    }\n    public synchronized void show(){\n        if (ticket > 0 ){\n            try{\n                Thread.currentThread().sleep(10);\n                System.out.println(Thread.currentThread().getName()+\"售票，余票为：\"+ticket--);\n            }catch (InterruptedException e){\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\npublic class TestThreadSecurity2 {\n    public static void main(String[] args){\n        Win window = new Win();\n        Thread window1 = new Thread(window);\n        Thread window2 = new Thread(window);\n        Thread window3 = new Thread(window);\n\n        window1.setName(\"窗口1\");\n        window2.setName(\"窗口2\");\n        window3.setName(\"窗口3\");\n\n        window1.start();\n        window2.start();\n        window3.start();\n    }\n}\n```\n\n 这里还涉及到一个**互斥锁**的概念。\n\n先了解一下单例模式：https://blog.csdn.net/qq_41647999/article/details/83447936\n\n单例模式一般用于比较大、复杂的对象，只初始化一次，应该还有一个private的构造函数，使得不能用new来实例化对象，只能调用getInstance方法来得到对象，而getInstance保证了每次调用都返回相同的对象。\n\n这里在举一个实例，解释在代码里：\n\n```java\nclass Singleton{\n    private Singleton(){\n\n    }\n    /*\n    这里存在一个问题， 两个线程（A、B）分别调用getInstance方法，\n    首次调用的时候，instance肯定为null，A在创建Singleton之前被挂起，\n    线程B进入之后也被挂起，当前的instance仍然为null。此时A继续执行\n    创建一个Singleton对象，假设此时在内存中的地址为1111，线程B执行之后\n    也会创建一个对象，大家肯定都知道在内存中的值一定不为1111，\n    像这样返回出去的判断相等不相等的时候就有问题了。为什么呢？因为在这里的instance\n    只能够new一次，这种情况却new了两次。\n     */\n    private static Singleton instance = null;\n    /*\n    这里为什么要判断一次instance为null？\n    假设这里只有一家华为手机店（这里的代码块），店里面只有一台mate20，\n    门口排了一大堆的人（线程）来买mate20，第一个人肯定买的到，后面的人\n    就买不到了，但是没有人告诉后面的人卖完了，每个人还得进店一次。所以\n    这里的instance不为null的时候，就是告诉后面的线程，说这里的mate20\n    已经卖完了，不用排队了。\n    */\n    if (instance == null ){\n    public static Singleton getInstance(){\n        if (instance == null ){\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n}\n\npublic class TestSingleton {\n    public static void main(String[] args) {\n        /*\n        getInstance在单例模式(保证一个类仅有一个实例，\n        并提供一个访问它的全局访问点)的类中常见，\n        用来生成唯一的实例，getInstance一般是static的\n         */\n        Singleton s1 = Singleton.getInstance();\n        Singleton s2 = Singleton.getInstance();\n        System.out.println(s1 == s2);\n    }\n}\n```\n\n**上例BUG修复**\n\n```java\nclass Singleton2{\n    private Singleton2(){\n\n    }\n\n    private static Singleton2 instance = null;\n    public static Singleton2 getInstance() {\n        /*\n        1、 static里面不能使用this\n        2、 关于解决懒汉式的线程安全问题，需要使用同步机制\n        3、 对于静态方法而言，使用当前类本身充当锁\n         */\n        synchronized (Singleton2.class) {\n            /*\n            关于这里为什么使用Singleton2.class为什么能行，涉及到反射的知识点。\n             */\n            if (instance == null) {\n                instance = new Singleton2();\n            }\n            \n        }\n        return instance;\n    }\n}\n\npublic class TestSingleton2 {\n    public static void main(String[] args) {\n        Singleton2 s1 = Singleton2.getInstance();\n        Singleton2 s2 = Singleton2.getInstance();\n        System.out.println(s1 == s2);\n    }\n}\n```\n\n## 同步synchronized在字节码指令中的原理（浅）\n\n​\t在方法中使用synchronized关键字实现同步的原因是使用了flag标记ACC_SYNCHRONIZED.当调用方法时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否设置，如果设置了，执行线程先持有同步锁，然后执行方法，最后在方法完成时释放锁。\n```java\n/**\n *  public static synchronized void testMethod();\n *     descriptor: ()V\n *     flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED\n *     Code:\n *       stack=0, locals=0, args_size=0\n *          0: return\n *       LineNumberTable:\n *         line 26: 0\n *\n *       在翻编译的字节码指令，对public synchronized.viod myMethod()方法使用\n *   了flag标记ACC_SYNCHRONIZED,说明此方法是同步的。\n *\n *\n *\n *  public void myMethod();\n *     descriptor: ()V\n *     flags: ACC_PUBLIC\n *     Code:\n *       stack=2, locals=4, args_size=1\n *          0: aload_0\n *          1: dup\n *          2: astore_1\n *          3: monitorenter\n *          4: bipush        100\n *          6: istore_2\n *          7: aload_1\n *          8: monitorexit\n *          9: goto          17\n *         12: astore_3\n *         13: aload_1\n *         14: monitorexit\n *         15: aload_3\n *         16: athrow\n *         17: return\n *\n *         在字节码中使用monitorenter和monitorexit指令进行同步处理\n *         同步：按顺序执行A和B这两个业务，就是同步\n *         异步：执行A业务的时候，B业务也在同时执行，这就是异步。\n */\nclass Test {\n    synchronized public static void testMethod(){\n\t\t\n    }\n    public static void Test()throws InterruptedException{\n        testMethod();\n    }\n}\npublic class Test2 {\n\t//  如果使用synchronized代码块，则使用 monitorenter 和 monitorexit 指令进行同步处理。\n     public void myMethod(){\n        synchronized (this){\n            int age=100;\n        }\n    }\n    public static void main(String[] args)throws InterruptedException {\n     \tTest2 test = new Test2();\n        test.myMethod();\t\n    }\n}\n```\n\n## 将 Synchronized 方法与对象作为锁\n\n有一个对象 object 中有 a 和 b 两个方法，有 t1 和 t2 两个线程，t1 调用方法 a，t2调用方法b，请问以下情况两个线程的执行顺序是怎样的？\n\n（1）如果 a 加了同步锁，b没加。执行顺序：t1 持有 object 对象的 lock 锁，t2 可以以异步的方式调用object中的非同步锁的方法，所以 t1 和 t2 是同时执行的。\n\n（2）如果 a 加了同步锁，b也加了。执行顺序：在方法声明处添加 synchronized 并不是锁方法，而是锁当前类的对象，所以根据t1 和 t2 的调用顺序来执行的。\n\n注意：\n\n- 在Java 中，只有将对象作为锁这种说法，没有锁方法这种说法。\n- 在Java中，锁就是对象，对象可以映射成锁，哪个线程拿到这把锁，哪个线程就可以执行这个对象中的 synchronized 同步方法。\n- 如果在某对象中使用了 synchronized 关键字声明非静态方法，那么这个对象就被当成锁。\n\n> 这里存在一个误区：synchronized修饰方法时，如果该方法没有static关键字不是静态方法，则锁的只是这个对象，也就是说在另一个线程中新创建一个这个类的对象，两个线程操作不是同一把锁是不会产生竞态条件的。如果该方法上使用了静态关键字，则当前锁锁的是这个对象的类，使用该类重新创建对象多个线程的操作该对象都会产生静态条件。\n\n## synchronized 锁重入\n\n> 问题导入：如果一个线程调用了一个对象的同步方法，那么他还能不能在调用这个对象的另外一个同步方法呢？\n\nsynchronized 锁拥有重入锁的功能，当一个线程得到对象锁之后，再次请求此对象锁时是可以获取到该对象锁的，也就可以在一个 synchronized 方法 / 块的内部调用本类的其它加锁的方法 / 块，是永远可以得到锁的。\n\n```java\npublic class Service{\n    public synchronized  void fun1(){\n        System.out.println(\"一号同步方法\");\n        fun2();\n    }\n\n    public synchronized void fun2(){\n        System.out.println(\"二号同步方法\");\n        fun3();\n    }\n\n    public synchronized void fun3(){\n        System.out.println(\"三号同步方法\");\n    }\n}\n```\n\n```java\npublic class MyThread extends Thread {\n    private Service service;\n    \n    public SynThreadText(Service service){\n        this.service=service;\n    }\n    \n    @Override\n    public void run(){\n        service.fun1();\n    }\n\n    public static void main(String[] args) {\n        Service service = new Service();\n        MyThread myThread = new MyThread(service);\n        myThread.start();\n    }\n}\n```\n\n执行结果：\n\n```\n一号同步方法\n二号同步方法\n三号同步方法\n```\n\n## synchronized 锁重入支持父类继承\n\n既然 synchronized 支持对象的方法重入，那么他是否也支持子类继承父类的同步方法重入呢？\n\n```java\npublic class SubClass extends SuperClass implements Runnable {\n    @Override\n    public void run(){\n        this.subFun();\n    }\n\t\n    public synchronized  void subFun(){\n        System.out.println(\"子类的同步方法\");\n        this.superSynFun();\n    }\n\t\n    public static void main(String[] args) {\n        SubClass sub = new SubClass();\n        Thread t = new Thread(sub);\n        t.start();\n    }\n\n}\n\nclass SuperClass{\n    public synchronized void superSynFun(){\n        System.out.println(\"父类的同步方法\");\n    }\n}\n```\n\n执行结果：\n\n```\n子类的同步方法\n父类的同步方法\n```\n\n如果被重写的方法有synchronized关键字，在所重写方法如果不加 synchronized  修饰，那就是非同步方法。\n\n## 锁的范围\n\n类锁、对象锁、锁粗化、锁消除\n\n锁粗化：指JIT对于高频调用的方法，将该方法中的多个锁合并成一个锁。因为锁的请求、同步以及释放都会带来性能损耗。\n\n```java\npublic void test(){\n    synchronized(lock){\n        //do some thing\n    }\n    // 被JIT优化后，会直接跳过该方法。可通过JITWatch查看运行的过程\n    synchronized(lock){\n        //do other thing\n    }\n}\n```\n\n锁消除：指JIT对不需要加锁的代码却执行了加锁的操作进行锁的消除。\n\n例如，StringBuffer类的append() 方法使用了 synchronized 关键字，是线程安全的，但是仅用在线程封闭的环境中，则锁会浪费资源，JIT就会对锁进行消除。\n\n## 深入理解synchronized原理\n\nsynchronized关键字不仅实现同步，根据JMM规定还能保证可见性（读取最新主内存数据，结束后写入主内存）。\n\n![image-20210423124817593](.\\images\\synchronized关键字的原理.png)\n\n在HotSpot中，由Mark Word、Class Metadata Address、Array Length三部份组成。\n\n- Mark Word：在Mark Word中有一块内存空间，不同的虚拟机有不同的做法，在其中有一个对应的状态关键字State对应有锁还是无锁，是轻量级锁还是重量级锁，是否被GC了。左边bitfields中存放的是数据，不同的状态下存放对应的数据。  \n- Class Metadata Address：存储对对象（Class）的描述，例如类中的某个属性对应哪一块内存地址。\n- Array Length：存储数据的格式。\n\n在JVM中，加锁会经历：偏向锁 -> 轻量级锁 -> 重量级锁这四个状态。\n\n偏向锁：本质就是无锁，如果没有发生任何多线程争抢锁的情况，JVM认为就是单线程，无需做同步。\n\n![image-20210429101554456](.\\images\\JVM-从偏向锁到重量级锁的过程.png)\n\n重量级锁 - 监视器（monitor）\n\n![image-20210429101903740](.\\images\\重量级锁监视器(monitor)原理.png)\n\n","slug":"Java并发 - synchronized","published":1,"updated":"2022-03-02T11:28:45.252Z","layout":"post","photos":[],"link":"","_id":"cl0atbcp2000l7cu5hlkmc7hk","content":"<p>synchronized（悲观锁又叫独享锁） 用于保障原子性、可见性、有序性。</p>\n<p>synchronized 属于最基本的线程通信机制，基于对象监视器实现的，Java中每个对象都与一个监视器相关联，一个线程可以锁的或解锁，一次只有一个线程可以锁定监视器，试图锁定该监视器的任何其它线程都会被阻塞，直到它们可以获得该监视器上的锁定为止。</p>\n<h2 id=\"方法内的变量为线程安全\"><a href=\"#方法内的变量为线程安全\" class=\"headerlink\" title=\"方法内的变量为线程安全\"></a>方法内的变量为线程安全</h2><p>非线程安全问题存在于实例变量中，如果是方法内部的私有变量，则不存在非线程安全问题，所得到的结果是线程安全的。</p>\n<p><strong>原因</strong></p>\n<p>（1）方法内部的变量为方法私有的变量，其生存周期随着方法的结束而终结。<br>（2）每个线程执行的时候会把局部变量存放在各自栈帧的工作内存中（栈帧进入虚拟机栈），虚拟机栈线程间不共享，故不存在线程安全问题。</p>\n<p>方法内部的变量线程安全验证案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HasSelfPrivateNum_1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addI</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str.equals(<span class=\"string\">&quot;a&quot;</span>)) &#123;</span><br><span class=\"line\">                num = <span class=\"number\">100</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;a set over!&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                num = <span class=\"number\">200</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;b set over!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(str + <span class=\"string\">&quot; num=&quot;</span> + num);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HasSelfPrivateNum_1 numRef;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThreadA</span><span class=\"params\">(HasSelfPrivateNum_1 numRef)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.numRef = numRef;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        numRef.addI(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HasSelfPrivateNum_1 numRef;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThreadB</span><span class=\"params\">(HasSelfPrivateNum_1 numRef)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.numRef = numRef;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        numRef.addI(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadTest0216</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">HasSelfPrivateNum_1</span> <span class=\"variable\">privateNum</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HasSelfPrivateNum_1</span>();</span><br><span class=\"line\">        <span class=\"type\">ThreadA</span> <span class=\"variable\">threadA</span>  <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadA</span>(privateNum);</span><br><span class=\"line\">        threadA.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ThreadB</span> <span class=\"variable\">threadB</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadB</span>(privateNum);</span><br><span class=\"line\">        threadB.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a set over!</span><br><span class=\"line\">b set over!</span><br><span class=\"line\">b num=200</span><br><span class=\"line\">a num=100</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实例变量非线程安全问题与解决方案\"><a href=\"#实例变量非线程安全问题与解决方案\" class=\"headerlink\" title=\"实例变量非线程安全问题与解决方案\"></a>实例变量非线程安全问题与解决方案</h2><ul>\n<li>如果多个线程共同访问一个对象中的实例变量，则有可能出现非线程安全问题；</li>\n<li>用多线程访问的对象中如果有多个实例变量，则运行结果有可能会出现交叉的情况。</li>\n<li>如果对象仅有一个实例变量，则有可能出现覆盖的情况。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HasSelfPrivateNum_2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addI</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str.equals(<span class=\"string\">&quot;a&quot;</span>)) &#123;</span><br><span class=\"line\">                num = <span class=\"number\">100</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;a set over!&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                num = <span class=\"number\">200</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;b set over!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(str + <span class=\"string\">&quot; num=&quot;</span> + num);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadC</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HasSelfPrivateNum_2 numRef;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThreadC</span><span class=\"params\">(HasSelfPrivateNum_2 numRef)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.numRef = numRef;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        numRef.addI(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadD</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HasSelfPrivateNum_2 numRef;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThreadD</span><span class=\"params\">(HasSelfPrivateNum_2 numRef)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.numRef = numRef;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        numRef.addI(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadTest02162</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">HasSelfPrivateNum_2</span> <span class=\"variable\">privateNum</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HasSelfPrivateNum_2</span>();</span><br><span class=\"line\">        <span class=\"type\">ThreadC</span> <span class=\"variable\">threadC</span>  <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadC</span>(privateNum);</span><br><span class=\"line\">        threadC.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ThreadD</span> <span class=\"variable\">threadD</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadD</span>(privateNum);</span><br><span class=\"line\">        threadD.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a set over!</span><br><span class=\"line\">b set over!</span><br><span class=\"line\">b num=200</span><br><span class=\"line\">a num=200</span><br></pre></td></tr></table></figure>\n\n<p>上面这个案例是两个线程同时访问同一个业务对象中的一个没有同步的方法，如果线程同时操作业务对象中的变量，则有可能出现非线程安全问题。</p>\n<p>解决上面这个错误，在 public void addI(String str) 方法前加关键字 synchronized 即可。</p>\n<h2 id=\"同步代码块\"><a href=\"#同步代码块\" class=\"headerlink\" title=\"同步代码块\"></a>同步代码块</h2><p>sysnchronized(<strong>同步监视器</strong>){</p>\n<p>  // 需要被同步的代码块(即为<strong>共享数据</strong>的代码)</p>\n<p>}</p>\n<p>1） 共享数据：多个线程共同操作的同一个数据（变量） </p>\n<p>2） 同步监视器：有一个类的对象来充当。哪个线程获取此监视器，谁就去执行大括号里被同步的代码。俗称：锁。要求所有的线程共用同一把锁。</p>\n<p>下面提供一个用同步代码块的方式解决<strong>数据共享的安全</strong>问题：</p>\n<p><strong>实例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">W</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ticket</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Object obj = new Object();</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">              在继承中一定要慎用this</span></span><br><span class=\"line\"><span class=\"comment\">              严格控制：要求所有的线程共用同一把锁，</span></span><br><span class=\"line\"><span class=\"comment\">              也就是说这个this代表同一个对象的时候才能够使用。</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ticket &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        Thread.currentThread().sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;售票，余票为：&quot;</span> + ticket--);</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestThreadSecurity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">W</span> <span class=\"variable\">window</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">W</span>();</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\"></span><br><span class=\"line\">        window1.setName(<span class=\"string\">&quot;窗口1&quot;</span>);</span><br><span class=\"line\">        window2.setName(<span class=\"string\">&quot;窗口2&quot;</span>);</span><br><span class=\"line\">        window3.setName(<span class=\"string\">&quot;窗口3&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        window1.start();</span><br><span class=\"line\">        window2.start();</span><br><span class=\"line\">        window3.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h2><p>将操作共享数据的方法声明为sysnchronized。即此方法，能够保证其中一个线程执行此方法时，其它线程在外等待直至此线程执行完此方法。</p>\n<p>同步方法的锁：this。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Win</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ticket</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Object obj = new Object();</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ticket &gt; <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                Thread.currentThread().sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;售票，余票为：&quot;</span>+ticket--);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestThreadSecurity2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Win</span> <span class=\"variable\">window</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Win</span>();</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\"></span><br><span class=\"line\">        window1.setName(<span class=\"string\">&quot;窗口1&quot;</span>);</span><br><span class=\"line\">        window2.setName(<span class=\"string\">&quot;窗口2&quot;</span>);</span><br><span class=\"line\">        window3.setName(<span class=\"string\">&quot;窗口3&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        window1.start();</span><br><span class=\"line\">        window2.start();</span><br><span class=\"line\">        window3.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 这里还涉及到一个<strong>互斥锁</strong>的概念。</p>\n<p>先了解一下单例模式：<a href=\"https://blog.csdn.net/qq_41647999/article/details/83447936\">https://blog.csdn.net/qq_41647999/article/details/83447936</a></p>\n<p>单例模式一般用于比较大、复杂的对象，只初始化一次，应该还有一个private的构造函数，使得不能用new来实例化对象，只能调用getInstance方法来得到对象，而getInstance保证了每次调用都返回相同的对象。</p>\n<p>这里在举一个实例，解释在代码里：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    这里存在一个问题， 两个线程（A、B）分别调用getInstance方法，</span></span><br><span class=\"line\"><span class=\"comment\">    首次调用的时候，instance肯定为null，A在创建Singleton之前被挂起，</span></span><br><span class=\"line\"><span class=\"comment\">    线程B进入之后也被挂起，当前的instance仍然为null。此时A继续执行</span></span><br><span class=\"line\"><span class=\"comment\">    创建一个Singleton对象，假设此时在内存中的地址为1111，线程B执行之后</span></span><br><span class=\"line\"><span class=\"comment\">    也会创建一个对象，大家肯定都知道在内存中的值一定不为1111，</span></span><br><span class=\"line\"><span class=\"comment\">    像这样返回出去的判断相等不相等的时候就有问题了。为什么呢？因为在这里的instance</span></span><br><span class=\"line\"><span class=\"comment\">    只能够new一次，这种情况却new了两次。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    这里为什么要判断一次instance为null？</span></span><br><span class=\"line\"><span class=\"comment\">    假设这里只有一家华为手机店（这里的代码块），店里面只有一台mate20，</span></span><br><span class=\"line\"><span class=\"comment\">    门口排了一大堆的人（线程）来买mate20，第一个人肯定买的到，后面的人</span></span><br><span class=\"line\"><span class=\"comment\">    就买不到了，但是没有人告诉后面的人卖完了，每个人还得进店一次。所以</span></span><br><span class=\"line\"><span class=\"comment\">    这里的instance不为null的时候，就是告诉后面的线程，说这里的mate20</span></span><br><span class=\"line\"><span class=\"comment\">    已经卖完了，不用排队了。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span> )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span> )&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestSingleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        getInstance在单例模式(保证一个类仅有一个实例，</span></span><br><span class=\"line\"><span class=\"comment\">        并提供一个访问它的全局访问点)的类中常见，</span></span><br><span class=\"line\"><span class=\"comment\">        用来生成唯一的实例，getInstance一般是static的</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">Singleton</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">        <span class=\"type\">Singleton</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">        System.out.println(s1 == s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>上例BUG修复</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton2</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton2</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton2 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        1、 static里面不能使用this</span></span><br><span class=\"line\"><span class=\"comment\">        2、 关于解决懒汉式的线程安全问题，需要使用同步机制</span></span><br><span class=\"line\"><span class=\"comment\">        3、 对于静态方法而言，使用当前类本身充当锁</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton2.class) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            关于这里为什么使用Singleton2.class为什么能行，涉及到反射的知识点。</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton2</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestSingleton2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Singleton2</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> Singleton2.getInstance();</span><br><span class=\"line\">        <span class=\"type\">Singleton2</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> Singleton2.getInstance();</span><br><span class=\"line\">        System.out.println(s1 == s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"同步synchronized在字节码指令中的原理（浅）\"><a href=\"#同步synchronized在字节码指令中的原理（浅）\" class=\"headerlink\" title=\"同步synchronized在字节码指令中的原理（浅）\"></a>同步synchronized在字节码指令中的原理（浅）</h2><p>​    在方法中使用synchronized关键字实现同步的原因是使用了flag标记ACC_SYNCHRONIZED.当调用方法时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否设置，如果设置了，执行线程先持有同步锁，然后执行方法，最后在方法完成时释放锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  public static synchronized void testMethod();</span></span><br><span class=\"line\"><span class=\"comment\"> *     descriptor: ()V</span></span><br><span class=\"line\"><span class=\"comment\"> *     flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span></span><br><span class=\"line\"><span class=\"comment\"> *     Code:</span></span><br><span class=\"line\"><span class=\"comment\"> *       stack=0, locals=0, args_size=0</span></span><br><span class=\"line\"><span class=\"comment\"> *          0: return</span></span><br><span class=\"line\"><span class=\"comment\"> *       LineNumberTable:</span></span><br><span class=\"line\"><span class=\"comment\"> *         line 26: 0</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *       在翻编译的字节码指令，对public synchronized.viod myMethod()方法使用</span></span><br><span class=\"line\"><span class=\"comment\"> *   了flag标记ACC_SYNCHRONIZED,说明此方法是同步的。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  public void myMethod();</span></span><br><span class=\"line\"><span class=\"comment\"> *     descriptor: ()V</span></span><br><span class=\"line\"><span class=\"comment\"> *     flags: ACC_PUBLIC</span></span><br><span class=\"line\"><span class=\"comment\"> *     Code:</span></span><br><span class=\"line\"><span class=\"comment\"> *       stack=2, locals=4, args_size=1</span></span><br><span class=\"line\"><span class=\"comment\"> *          0: aload_0</span></span><br><span class=\"line\"><span class=\"comment\"> *          1: dup</span></span><br><span class=\"line\"><span class=\"comment\"> *          2: astore_1</span></span><br><span class=\"line\"><span class=\"comment\"> *          3: monitorenter</span></span><br><span class=\"line\"><span class=\"comment\"> *          4: bipush        100</span></span><br><span class=\"line\"><span class=\"comment\"> *          6: istore_2</span></span><br><span class=\"line\"><span class=\"comment\"> *          7: aload_1</span></span><br><span class=\"line\"><span class=\"comment\"> *          8: monitorexit</span></span><br><span class=\"line\"><span class=\"comment\"> *          9: goto          17</span></span><br><span class=\"line\"><span class=\"comment\"> *         12: astore_3</span></span><br><span class=\"line\"><span class=\"comment\"> *         13: aload_1</span></span><br><span class=\"line\"><span class=\"comment\"> *         14: monitorexit</span></span><br><span class=\"line\"><span class=\"comment\"> *         15: aload_3</span></span><br><span class=\"line\"><span class=\"comment\"> *         16: athrow</span></span><br><span class=\"line\"><span class=\"comment\"> *         17: return</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *         在字节码中使用monitorenter和monitorexit指令进行同步处理</span></span><br><span class=\"line\"><span class=\"comment\"> *         同步：按顺序执行A和B这两个业务，就是同步</span></span><br><span class=\"line\"><span class=\"comment\"> *         异步：执行A业务的时候，B业务也在同时执行，这就是异步。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">Test</span><span class=\"params\">()</span><span class=\"keyword\">throws</span> InterruptedException&#123;</span><br><span class=\"line\">        testMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//  如果使用synchronized代码块，则使用 monitorenter 和 monitorexit 指令进行同步处理。</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> age=<span class=\"number\">100</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span><span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">     \t<span class=\"type\">Test2</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test2</span>();</span><br><span class=\"line\">        test.myMethod();\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将-Synchronized-方法与对象作为锁\"><a href=\"#将-Synchronized-方法与对象作为锁\" class=\"headerlink\" title=\"将 Synchronized 方法与对象作为锁\"></a>将 Synchronized 方法与对象作为锁</h2><p>有一个对象 object 中有 a 和 b 两个方法，有 t1 和 t2 两个线程，t1 调用方法 a，t2调用方法b，请问以下情况两个线程的执行顺序是怎样的？</p>\n<p>（1）如果 a 加了同步锁，b没加。执行顺序：t1 持有 object 对象的 lock 锁，t2 可以以异步的方式调用object中的非同步锁的方法，所以 t1 和 t2 是同时执行的。</p>\n<p>（2）如果 a 加了同步锁，b也加了。执行顺序：在方法声明处添加 synchronized 并不是锁方法，而是锁当前类的对象，所以根据t1 和 t2 的调用顺序来执行的。</p>\n<p>注意：</p>\n<ul>\n<li>在Java 中，只有将对象作为锁这种说法，没有锁方法这种说法。</li>\n<li>在Java中，锁就是对象，对象可以映射成锁，哪个线程拿到这把锁，哪个线程就可以执行这个对象中的 synchronized 同步方法。</li>\n<li>如果在某对象中使用了 synchronized 关键字声明非静态方法，那么这个对象就被当成锁。</li>\n</ul>\n<blockquote>\n<p>这里存在一个误区：synchronized修饰方法时，如果该方法没有static关键字不是静态方法，则锁的只是这个对象，也就是说在另一个线程中新创建一个这个类的对象，两个线程操作不是同一把锁是不会产生竞态条件的。如果该方法上使用了静态关键字，则当前锁锁的是这个对象的类，使用该类重新创建对象多个线程的操作该对象都会产生静态条件。</p>\n</blockquote>\n<h2 id=\"synchronized-锁重入\"><a href=\"#synchronized-锁重入\" class=\"headerlink\" title=\"synchronized 锁重入\"></a>synchronized 锁重入</h2><blockquote>\n<p>问题导入：如果一个线程调用了一个对象的同步方法，那么他还能不能在调用这个对象的另外一个同步方法呢？</p>\n</blockquote>\n<p>synchronized 锁拥有重入锁的功能，当一个线程得到对象锁之后，再次请求此对象锁时是可以获取到该对象锁的，也就可以在一个 synchronized 方法 / 块的内部调用本类的其它加锁的方法 / 块，是永远可以得到锁的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">fun1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;一号同步方法&quot;</span>);</span><br><span class=\"line\">        fun2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;二号同步方法&quot;</span>);</span><br><span class=\"line\">        fun3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;三号同步方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Service service;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SynThreadText</span><span class=\"params\">(Service service)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.service=service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        service.fun1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Service</span>();</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>(service);</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一号同步方法</span><br><span class=\"line\">二号同步方法</span><br><span class=\"line\">三号同步方法</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"synchronized-锁重入支持父类继承\"><a href=\"#synchronized-锁重入支持父类继承\" class=\"headerlink\" title=\"synchronized 锁重入支持父类继承\"></a>synchronized 锁重入支持父类继承</h2><p>既然 synchronized 支持对象的方法重入，那么他是否也支持子类继承父类的同步方法重入呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SuperClass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.subFun();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">subFun</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类的同步方法&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.superSynFun();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">SubClass</span> <span class=\"variable\">sub</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SubClass</span>();</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(sub);</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SuperClass</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">superSynFun</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;父类的同步方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">子类的同步方法</span><br><span class=\"line\">父类的同步方法</span><br></pre></td></tr></table></figure>\n\n<p>如果被重写的方法有synchronized关键字，在所重写方法如果不加 synchronized  修饰，那就是非同步方法。</p>\n<h2 id=\"锁的范围\"><a href=\"#锁的范围\" class=\"headerlink\" title=\"锁的范围\"></a>锁的范围</h2><p>类锁、对象锁、锁粗化、锁消除</p>\n<p>锁粗化：指JIT对于高频调用的方法，将该方法中的多个锁合并成一个锁。因为锁的请求、同步以及释放都会带来性能损耗。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lock)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do some thing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 被JIT优化后，会直接跳过该方法。可通过JITWatch查看运行的过程</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lock)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do other thing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>锁消除：指JIT对不需要加锁的代码却执行了加锁的操作进行锁的消除。</p>\n<p>例如，StringBuffer类的append() 方法使用了 synchronized 关键字，是线程安全的，但是仅用在线程封闭的环境中，则锁会浪费资源，JIT就会对锁进行消除。</p>\n<h2 id=\"深入理解synchronized原理\"><a href=\"#深入理解synchronized原理\" class=\"headerlink\" title=\"深入理解synchronized原理\"></a>深入理解synchronized原理</h2><p>synchronized关键字不仅实现同步，根据JMM规定还能保证可见性（读取最新主内存数据，结束后写入主内存）。</p>\n<p><img src=\"/.%5Cimages%5Csynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86.png\" alt=\"image-20210423124817593\"></p>\n<p>在HotSpot中，由Mark Word、Class Metadata Address、Array Length三部份组成。</p>\n<ul>\n<li>Mark Word：在Mark Word中有一块内存空间，不同的虚拟机有不同的做法，在其中有一个对应的状态关键字State对应有锁还是无锁，是轻量级锁还是重量级锁，是否被GC了。左边bitfields中存放的是数据，不同的状态下存放对应的数据。  </li>\n<li>Class Metadata Address：存储对对象（Class）的描述，例如类中的某个属性对应哪一块内存地址。</li>\n<li>Array Length：存储数据的格式。</li>\n</ul>\n<p>在JVM中，加锁会经历：偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁这四个状态。</p>\n<p>偏向锁：本质就是无锁，如果没有发生任何多线程争抢锁的情况，JVM认为就是单线程，无需做同步。</p>\n<p><img src=\"/.%5Cimages%5CJVM-%E4%BB%8E%E5%81%8F%E5%90%91%E9%94%81%E5%88%B0%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E8%BF%87%E7%A8%8B.png\" alt=\"image-20210429101554456\"></p>\n<p>重量级锁 - 监视器（monitor）</p>\n<p><img src=\"/.%5Cimages%5C%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9B%91%E8%A7%86%E5%99%A8(monitor)%E5%8E%9F%E7%90%86.png\" alt=\"image-20210429101903740\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>synchronized（悲观锁又叫独享锁） 用于保障原子性、可见性、有序性。</p>\n<p>synchronized 属于最基本的线程通信机制，基于对象监视器实现的，Java中每个对象都与一个监视器相关联，一个线程可以锁的或解锁，一次只有一个线程可以锁定监视器，试图锁定该监视器的任何其它线程都会被阻塞，直到它们可以获得该监视器上的锁定为止。</p>\n<h2 id=\"方法内的变量为线程安全\"><a href=\"#方法内的变量为线程安全\" class=\"headerlink\" title=\"方法内的变量为线程安全\"></a>方法内的变量为线程安全</h2><p>非线程安全问题存在于实例变量中，如果是方法内部的私有变量，则不存在非线程安全问题，所得到的结果是线程安全的。</p>\n<p><strong>原因</strong></p>\n<p>（1）方法内部的变量为方法私有的变量，其生存周期随着方法的结束而终结。<br>（2）每个线程执行的时候会把局部变量存放在各自栈帧的工作内存中（栈帧进入虚拟机栈），虚拟机栈线程间不共享，故不存在线程安全问题。</p>\n<p>方法内部的变量线程安全验证案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HasSelfPrivateNum_1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addI</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str.equals(<span class=\"string\">&quot;a&quot;</span>)) &#123;</span><br><span class=\"line\">                num = <span class=\"number\">100</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;a set over!&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                num = <span class=\"number\">200</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;b set over!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(str + <span class=\"string\">&quot; num=&quot;</span> + num);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HasSelfPrivateNum_1 numRef;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThreadA</span><span class=\"params\">(HasSelfPrivateNum_1 numRef)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.numRef = numRef;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        numRef.addI(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HasSelfPrivateNum_1 numRef;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThreadB</span><span class=\"params\">(HasSelfPrivateNum_1 numRef)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.numRef = numRef;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        numRef.addI(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadTest0216</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">HasSelfPrivateNum_1</span> <span class=\"variable\">privateNum</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HasSelfPrivateNum_1</span>();</span><br><span class=\"line\">        <span class=\"type\">ThreadA</span> <span class=\"variable\">threadA</span>  <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadA</span>(privateNum);</span><br><span class=\"line\">        threadA.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ThreadB</span> <span class=\"variable\">threadB</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadB</span>(privateNum);</span><br><span class=\"line\">        threadB.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a set over!</span><br><span class=\"line\">b set over!</span><br><span class=\"line\">b num=200</span><br><span class=\"line\">a num=100</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实例变量非线程安全问题与解决方案\"><a href=\"#实例变量非线程安全问题与解决方案\" class=\"headerlink\" title=\"实例变量非线程安全问题与解决方案\"></a>实例变量非线程安全问题与解决方案</h2><ul>\n<li>如果多个线程共同访问一个对象中的实例变量，则有可能出现非线程安全问题；</li>\n<li>用多线程访问的对象中如果有多个实例变量，则运行结果有可能会出现交叉的情况。</li>\n<li>如果对象仅有一个实例变量，则有可能出现覆盖的情况。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HasSelfPrivateNum_2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addI</span><span class=\"params\">(String str)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str.equals(<span class=\"string\">&quot;a&quot;</span>)) &#123;</span><br><span class=\"line\">                num = <span class=\"number\">100</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;a set over!&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                num = <span class=\"number\">200</span>;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;b set over!&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(str + <span class=\"string\">&quot; num=&quot;</span> + num);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadC</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HasSelfPrivateNum_2 numRef;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThreadC</span><span class=\"params\">(HasSelfPrivateNum_2 numRef)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.numRef = numRef;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        numRef.addI(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadD</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HasSelfPrivateNum_2 numRef;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThreadD</span><span class=\"params\">(HasSelfPrivateNum_2 numRef)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.numRef = numRef;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        numRef.addI(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ThreadTest02162</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">HasSelfPrivateNum_2</span> <span class=\"variable\">privateNum</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HasSelfPrivateNum_2</span>();</span><br><span class=\"line\">        <span class=\"type\">ThreadC</span> <span class=\"variable\">threadC</span>  <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadC</span>(privateNum);</span><br><span class=\"line\">        threadC.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ThreadD</span> <span class=\"variable\">threadD</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadD</span>(privateNum);</span><br><span class=\"line\">        threadD.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a set over!</span><br><span class=\"line\">b set over!</span><br><span class=\"line\">b num=200</span><br><span class=\"line\">a num=200</span><br></pre></td></tr></table></figure>\n\n<p>上面这个案例是两个线程同时访问同一个业务对象中的一个没有同步的方法，如果线程同时操作业务对象中的变量，则有可能出现非线程安全问题。</p>\n<p>解决上面这个错误，在 public void addI(String str) 方法前加关键字 synchronized 即可。</p>\n<h2 id=\"同步代码块\"><a href=\"#同步代码块\" class=\"headerlink\" title=\"同步代码块\"></a>同步代码块</h2><p>sysnchronized(<strong>同步监视器</strong>){</p>\n<p>  // 需要被同步的代码块(即为<strong>共享数据</strong>的代码)</p>\n<p>}</p>\n<p>1） 共享数据：多个线程共同操作的同一个数据（变量） </p>\n<p>2） 同步监视器：有一个类的对象来充当。哪个线程获取此监视器，谁就去执行大括号里被同步的代码。俗称：锁。要求所有的线程共用同一把锁。</p>\n<p>下面提供一个用同步代码块的方式解决<strong>数据共享的安全</strong>问题：</p>\n<p><strong>实例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">W</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ticket</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Object obj = new Object();</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">              在继承中一定要慎用this</span></span><br><span class=\"line\"><span class=\"comment\">              严格控制：要求所有的线程共用同一把锁，</span></span><br><span class=\"line\"><span class=\"comment\">              也就是说这个this代表同一个对象的时候才能够使用。</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ticket &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        Thread.currentThread().sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">                        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;售票，余票为：&quot;</span> + ticket--);</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestThreadSecurity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">W</span> <span class=\"variable\">window</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">W</span>();</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\"></span><br><span class=\"line\">        window1.setName(<span class=\"string\">&quot;窗口1&quot;</span>);</span><br><span class=\"line\">        window2.setName(<span class=\"string\">&quot;窗口2&quot;</span>);</span><br><span class=\"line\">        window3.setName(<span class=\"string\">&quot;窗口3&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        window1.start();</span><br><span class=\"line\">        window2.start();</span><br><span class=\"line\">        window3.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h2><p>将操作共享数据的方法声明为sysnchronized。即此方法，能够保证其中一个线程执行此方法时，其它线程在外等待直至此线程执行完此方法。</p>\n<p>同步方法的锁：this。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Win</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ticket</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Object obj = new Object();</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ticket &gt; <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                Thread.currentThread().sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;售票，余票为：&quot;</span>+ticket--);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestThreadSecurity2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Win</span> <span class=\"variable\">window</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Win</span>();</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">window3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(window);</span><br><span class=\"line\"></span><br><span class=\"line\">        window1.setName(<span class=\"string\">&quot;窗口1&quot;</span>);</span><br><span class=\"line\">        window2.setName(<span class=\"string\">&quot;窗口2&quot;</span>);</span><br><span class=\"line\">        window3.setName(<span class=\"string\">&quot;窗口3&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        window1.start();</span><br><span class=\"line\">        window2.start();</span><br><span class=\"line\">        window3.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 这里还涉及到一个<strong>互斥锁</strong>的概念。</p>\n<p>先了解一下单例模式：<a href=\"https://blog.csdn.net/qq_41647999/article/details/83447936\">https://blog.csdn.net/qq_41647999/article/details/83447936</a></p>\n<p>单例模式一般用于比较大、复杂的对象，只初始化一次，应该还有一个private的构造函数，使得不能用new来实例化对象，只能调用getInstance方法来得到对象，而getInstance保证了每次调用都返回相同的对象。</p>\n<p>这里在举一个实例，解释在代码里：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    这里存在一个问题， 两个线程（A、B）分别调用getInstance方法，</span></span><br><span class=\"line\"><span class=\"comment\">    首次调用的时候，instance肯定为null，A在创建Singleton之前被挂起，</span></span><br><span class=\"line\"><span class=\"comment\">    线程B进入之后也被挂起，当前的instance仍然为null。此时A继续执行</span></span><br><span class=\"line\"><span class=\"comment\">    创建一个Singleton对象，假设此时在内存中的地址为1111，线程B执行之后</span></span><br><span class=\"line\"><span class=\"comment\">    也会创建一个对象，大家肯定都知道在内存中的值一定不为1111，</span></span><br><span class=\"line\"><span class=\"comment\">    像这样返回出去的判断相等不相等的时候就有问题了。为什么呢？因为在这里的instance</span></span><br><span class=\"line\"><span class=\"comment\">    只能够new一次，这种情况却new了两次。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    这里为什么要判断一次instance为null？</span></span><br><span class=\"line\"><span class=\"comment\">    假设这里只有一家华为手机店（这里的代码块），店里面只有一台mate20，</span></span><br><span class=\"line\"><span class=\"comment\">    门口排了一大堆的人（线程）来买mate20，第一个人肯定买的到，后面的人</span></span><br><span class=\"line\"><span class=\"comment\">    就买不到了，但是没有人告诉后面的人卖完了，每个人还得进店一次。所以</span></span><br><span class=\"line\"><span class=\"comment\">    这里的instance不为null的时候，就是告诉后面的线程，说这里的mate20</span></span><br><span class=\"line\"><span class=\"comment\">    已经卖完了，不用排队了。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span> )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span> )&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestSingleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        getInstance在单例模式(保证一个类仅有一个实例，</span></span><br><span class=\"line\"><span class=\"comment\">        并提供一个访问它的全局访问点)的类中常见，</span></span><br><span class=\"line\"><span class=\"comment\">        用来生成唯一的实例，getInstance一般是static的</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">Singleton</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">        <span class=\"type\">Singleton</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> Singleton.getInstance();</span><br><span class=\"line\">        System.out.println(s1 == s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>上例BUG修复</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton2</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton2</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton2 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        1、 static里面不能使用this</span></span><br><span class=\"line\"><span class=\"comment\">        2、 关于解决懒汉式的线程安全问题，需要使用同步机制</span></span><br><span class=\"line\"><span class=\"comment\">        3、 对于静态方法而言，使用当前类本身充当锁</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton2.class) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            关于这里为什么使用Singleton2.class为什么能行，涉及到反射的知识点。</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton2</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestSingleton2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Singleton2</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> Singleton2.getInstance();</span><br><span class=\"line\">        <span class=\"type\">Singleton2</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> Singleton2.getInstance();</span><br><span class=\"line\">        System.out.println(s1 == s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"同步synchronized在字节码指令中的原理（浅）\"><a href=\"#同步synchronized在字节码指令中的原理（浅）\" class=\"headerlink\" title=\"同步synchronized在字节码指令中的原理（浅）\"></a>同步synchronized在字节码指令中的原理（浅）</h2><p>​    在方法中使用synchronized关键字实现同步的原因是使用了flag标记ACC_SYNCHRONIZED.当调用方法时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否设置，如果设置了，执行线程先持有同步锁，然后执行方法，最后在方法完成时释放锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  public static synchronized void testMethod();</span></span><br><span class=\"line\"><span class=\"comment\"> *     descriptor: ()V</span></span><br><span class=\"line\"><span class=\"comment\"> *     flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span></span><br><span class=\"line\"><span class=\"comment\"> *     Code:</span></span><br><span class=\"line\"><span class=\"comment\"> *       stack=0, locals=0, args_size=0</span></span><br><span class=\"line\"><span class=\"comment\"> *          0: return</span></span><br><span class=\"line\"><span class=\"comment\"> *       LineNumberTable:</span></span><br><span class=\"line\"><span class=\"comment\"> *         line 26: 0</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *       在翻编译的字节码指令，对public synchronized.viod myMethod()方法使用</span></span><br><span class=\"line\"><span class=\"comment\"> *   了flag标记ACC_SYNCHRONIZED,说明此方法是同步的。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  public void myMethod();</span></span><br><span class=\"line\"><span class=\"comment\"> *     descriptor: ()V</span></span><br><span class=\"line\"><span class=\"comment\"> *     flags: ACC_PUBLIC</span></span><br><span class=\"line\"><span class=\"comment\"> *     Code:</span></span><br><span class=\"line\"><span class=\"comment\"> *       stack=2, locals=4, args_size=1</span></span><br><span class=\"line\"><span class=\"comment\"> *          0: aload_0</span></span><br><span class=\"line\"><span class=\"comment\"> *          1: dup</span></span><br><span class=\"line\"><span class=\"comment\"> *          2: astore_1</span></span><br><span class=\"line\"><span class=\"comment\"> *          3: monitorenter</span></span><br><span class=\"line\"><span class=\"comment\"> *          4: bipush        100</span></span><br><span class=\"line\"><span class=\"comment\"> *          6: istore_2</span></span><br><span class=\"line\"><span class=\"comment\"> *          7: aload_1</span></span><br><span class=\"line\"><span class=\"comment\"> *          8: monitorexit</span></span><br><span class=\"line\"><span class=\"comment\"> *          9: goto          17</span></span><br><span class=\"line\"><span class=\"comment\"> *         12: astore_3</span></span><br><span class=\"line\"><span class=\"comment\"> *         13: aload_1</span></span><br><span class=\"line\"><span class=\"comment\"> *         14: monitorexit</span></span><br><span class=\"line\"><span class=\"comment\"> *         15: aload_3</span></span><br><span class=\"line\"><span class=\"comment\"> *         16: athrow</span></span><br><span class=\"line\"><span class=\"comment\"> *         17: return</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *         在字节码中使用monitorenter和monitorexit指令进行同步处理</span></span><br><span class=\"line\"><span class=\"comment\"> *         同步：按顺序执行A和B这两个业务，就是同步</span></span><br><span class=\"line\"><span class=\"comment\"> *         异步：执行A业务的时候，B业务也在同时执行，这就是异步。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">Test</span><span class=\"params\">()</span><span class=\"keyword\">throws</span> InterruptedException&#123;</span><br><span class=\"line\">        testMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//  如果使用synchronized代码块，则使用 monitorenter 和 monitorexit 指令进行同步处理。</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> age=<span class=\"number\">100</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span><span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">     \t<span class=\"type\">Test2</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Test2</span>();</span><br><span class=\"line\">        test.myMethod();\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将-Synchronized-方法与对象作为锁\"><a href=\"#将-Synchronized-方法与对象作为锁\" class=\"headerlink\" title=\"将 Synchronized 方法与对象作为锁\"></a>将 Synchronized 方法与对象作为锁</h2><p>有一个对象 object 中有 a 和 b 两个方法，有 t1 和 t2 两个线程，t1 调用方法 a，t2调用方法b，请问以下情况两个线程的执行顺序是怎样的？</p>\n<p>（1）如果 a 加了同步锁，b没加。执行顺序：t1 持有 object 对象的 lock 锁，t2 可以以异步的方式调用object中的非同步锁的方法，所以 t1 和 t2 是同时执行的。</p>\n<p>（2）如果 a 加了同步锁，b也加了。执行顺序：在方法声明处添加 synchronized 并不是锁方法，而是锁当前类的对象，所以根据t1 和 t2 的调用顺序来执行的。</p>\n<p>注意：</p>\n<ul>\n<li>在Java 中，只有将对象作为锁这种说法，没有锁方法这种说法。</li>\n<li>在Java中，锁就是对象，对象可以映射成锁，哪个线程拿到这把锁，哪个线程就可以执行这个对象中的 synchronized 同步方法。</li>\n<li>如果在某对象中使用了 synchronized 关键字声明非静态方法，那么这个对象就被当成锁。</li>\n</ul>\n<blockquote>\n<p>这里存在一个误区：synchronized修饰方法时，如果该方法没有static关键字不是静态方法，则锁的只是这个对象，也就是说在另一个线程中新创建一个这个类的对象，两个线程操作不是同一把锁是不会产生竞态条件的。如果该方法上使用了静态关键字，则当前锁锁的是这个对象的类，使用该类重新创建对象多个线程的操作该对象都会产生静态条件。</p>\n</blockquote>\n<h2 id=\"synchronized-锁重入\"><a href=\"#synchronized-锁重入\" class=\"headerlink\" title=\"synchronized 锁重入\"></a>synchronized 锁重入</h2><blockquote>\n<p>问题导入：如果一个线程调用了一个对象的同步方法，那么他还能不能在调用这个对象的另外一个同步方法呢？</p>\n</blockquote>\n<p>synchronized 锁拥有重入锁的功能，当一个线程得到对象锁之后，再次请求此对象锁时是可以获取到该对象锁的，也就可以在一个 synchronized 方法 / 块的内部调用本类的其它加锁的方法 / 块，是永远可以得到锁的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">fun1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;一号同步方法&quot;</span>);</span><br><span class=\"line\">        fun2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;二号同步方法&quot;</span>);</span><br><span class=\"line\">        fun3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fun3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;三号同步方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Service service;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">SynThreadText</span><span class=\"params\">(Service service)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.service=service;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        service.fun1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Service</span>();</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>(service);</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一号同步方法</span><br><span class=\"line\">二号同步方法</span><br><span class=\"line\">三号同步方法</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"synchronized-锁重入支持父类继承\"><a href=\"#synchronized-锁重入支持父类继承\" class=\"headerlink\" title=\"synchronized 锁重入支持父类继承\"></a>synchronized 锁重入支持父类继承</h2><p>既然 synchronized 支持对象的方法重入，那么他是否也支持子类继承父类的同步方法重入呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SuperClass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.subFun();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">subFun</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类的同步方法&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.superSynFun();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">SubClass</span> <span class=\"variable\">sub</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SubClass</span>();</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(sub);</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SuperClass</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">superSynFun</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;父类的同步方法&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">子类的同步方法</span><br><span class=\"line\">父类的同步方法</span><br></pre></td></tr></table></figure>\n\n<p>如果被重写的方法有synchronized关键字，在所重写方法如果不加 synchronized  修饰，那就是非同步方法。</p>\n<h2 id=\"锁的范围\"><a href=\"#锁的范围\" class=\"headerlink\" title=\"锁的范围\"></a>锁的范围</h2><p>类锁、对象锁、锁粗化、锁消除</p>\n<p>锁粗化：指JIT对于高频调用的方法，将该方法中的多个锁合并成一个锁。因为锁的请求、同步以及释放都会带来性能损耗。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lock)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do some thing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 被JIT优化后，会直接跳过该方法。可通过JITWatch查看运行的过程</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lock)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do other thing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>锁消除：指JIT对不需要加锁的代码却执行了加锁的操作进行锁的消除。</p>\n<p>例如，StringBuffer类的append() 方法使用了 synchronized 关键字，是线程安全的，但是仅用在线程封闭的环境中，则锁会浪费资源，JIT就会对锁进行消除。</p>\n<h2 id=\"深入理解synchronized原理\"><a href=\"#深入理解synchronized原理\" class=\"headerlink\" title=\"深入理解synchronized原理\"></a>深入理解synchronized原理</h2><p>synchronized关键字不仅实现同步，根据JMM规定还能保证可见性（读取最新主内存数据，结束后写入主内存）。</p>\n<p><img src=\"/.%5Cimages%5Csynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86.png\" alt=\"image-20210423124817593\"></p>\n<p>在HotSpot中，由Mark Word、Class Metadata Address、Array Length三部份组成。</p>\n<ul>\n<li>Mark Word：在Mark Word中有一块内存空间，不同的虚拟机有不同的做法，在其中有一个对应的状态关键字State对应有锁还是无锁，是轻量级锁还是重量级锁，是否被GC了。左边bitfields中存放的是数据，不同的状态下存放对应的数据。  </li>\n<li>Class Metadata Address：存储对对象（Class）的描述，例如类中的某个属性对应哪一块内存地址。</li>\n<li>Array Length：存储数据的格式。</li>\n</ul>\n<p>在JVM中，加锁会经历：偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁这四个状态。</p>\n<p>偏向锁：本质就是无锁，如果没有发生任何多线程争抢锁的情况，JVM认为就是单线程，无需做同步。</p>\n<p><img src=\"/.%5Cimages%5CJVM-%E4%BB%8E%E5%81%8F%E5%90%91%E9%94%81%E5%88%B0%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E8%BF%87%E7%A8%8B.png\" alt=\"image-20210429101554456\"></p>\n<p>重量级锁 - 监视器（monitor）</p>\n<p><img src=\"/.%5Cimages%5C%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9B%91%E8%A7%86%E5%99%A8(monitor)%E5%8E%9F%E7%90%86.png\" alt=\"image-20210429101903740\"></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl0atbcov00067cu535r99woh","tag_id":"cl0atbcot00047cu59q5ahkgp","_id":"cl0atbcoy00097cu5a6c10iew"},{"post_id":"cl0atbcop00017cu5bjf62z3c","tag_id":"cl0atbcot00047cu59q5ahkgp","_id":"cl0atbcoy000b7cu53au8amis"},{"post_id":"cl0atbcow00077cu570702hny","tag_id":"cl0atbcot00047cu59q5ahkgp","_id":"cl0atbcp0000e7cu51lkn0tlr"},{"post_id":"cl0atbcoy000a7cu56rehhlvz","tag_id":"cl0atbcot00047cu59q5ahkgp","_id":"cl0atbcp0000g7cu5196yhvpo"},{"post_id":"cl0atbcos00037cu52d3k8hka","tag_id":"cl0atbcot00047cu59q5ahkgp","_id":"cl0atbcp1000i7cu5aowchies"},{"post_id":"cl0atbcoz000c7cu533rz77ld","tag_id":"cl0atbcot00047cu59q5ahkgp","_id":"cl0atbcp2000k7cu51sfs9j09"},{"post_id":"cl0atbcp0000f7cu5hb651w7b","tag_id":"cl0atbcot00047cu59q5ahkgp","_id":"cl0atbcp3000m7cu57o0zaeij"},{"post_id":"cl0atbcou00057cu58k9e9ces","tag_id":"cl0atbcoz000d7cu5101qay39","_id":"cl0atbcp4000n7cu52ut23otv"},{"post_id":"cl0atbcp0000h7cu5dw0fbi7s","tag_id":"cl0atbcot00047cu59q5ahkgp","_id":"cl0atbcp4000o7cu5bsg7euuc"},{"post_id":"cl0atbcp1000j7cu58kr47skc","tag_id":"cl0atbcot00047cu59q5ahkgp","_id":"cl0atbcp4000p7cu573mwdta3"},{"post_id":"cl0atbcp2000l7cu5hlkmc7hk","tag_id":"cl0atbcot00047cu59q5ahkgp","_id":"cl0atbcp4000q7cu5fkygfrqq"}],"Tag":[{"name":"JUC并发包","_id":"cl0atbcot00047cu59q5ahkgp"},{"name":"Java","_id":"cl0atbcoz000d7cu5101qay39"}]}}