{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipay.png","path":"images/alipay.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/link.svg","path":"images/link.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.png","path":"images/wechatpay.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/mo.min.js","path":"js/mo.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/valine.min.js","path":"js/valine.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/js/dark-theme.js","path":"js/dark-theme.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/JUC-AbstractQueuedSynchronizer.md","hash":"d2eb4ae290a6e6b5a175d1373a21770e7bc22c62","modified":1646484196481},{"_id":"source/_posts/JAVA-ArrayList&LinkedList.md","hash":"37a05ce73002bdc47db3df1eb2553a30eba6a765","modified":1646483634376},{"_id":"source/_posts/JUC-CAS.md","hash":"fb0dfdb4923ad0434a9e7e6f15b76e779760a8cf","modified":1646484235267},{"_id":"source/_posts/JUC-Callable.md","hash":"ae2b7e1923c2afd10a7d0fcfb1696be6020f71fa","modified":1646490945909},{"_id":"source/_posts/JUC-SingletonPattern.md","hash":"ed2ecf55c7c793c8d660eaf41e952d0db5bbdad2","modified":1646484286133},{"_id":"source/_posts/JUC-CPU-Performance-Optimization.md","hash":"04e27311bce78a5e4c6b0a0560ddf422cbe3e4c3","modified":1646484251324},{"_id":"source/friends/index.md","hash":"29b05c81ade9e4992ac6c55967811c2d6c07089d","modified":1646538560334},{"_id":"source/_posts/JUC-ForkJoin.md","hash":"043471fde0ea9b0d644f2421702a3bb355037fab","modified":1646484262899},{"_id":"source/_posts/JVM-JMM-Memory-Model.md","hash":"4de39b7dc3b65089b60322e592eeeee88a167c7e","modified":1646540581848},{"_id":"source/tags/index.md","hash":"8bc24d7d070886904aea7094248a087707e5059b","modified":1646372854686},{"_id":"source/_posts/JUC-Thread-interrupt.md","hash":"49867c67a73a3f64aa66d1c1240bca207637e565","modified":1646540250697},{"_id":"source/_posts/JUC-Unsafe.md","hash":"af2d8a4a581bf482110c1540742703e6a7fcc392","modified":1646484063127},{"_id":"source/_posts/JUC-CAS/1193919-20180102142540362-571280295.png","hash":"6743349601b14b643ee2b5b7c89bd5676efbe7db","modified":1646461521579},{"_id":"source/_posts/JUC-CAS/1193919-20180102142542299-1617994496.png","hash":"2f0453f290b9fb56ebfdb5b786117b0eedbe5822","modified":1646461598990},{"_id":"source/_posts/JUC-CAS/1193919-20180102142545221-837543615.png","hash":"1fa51bfcae9410ed84ba47cdbcf7fc8a055a4a33","modified":1646461747809},{"_id":"source/_posts/JUC-CAS/1193919-20180102142543784-1625100143.png","hash":"d60b669dc12d78cc26c38826b9fc5159a296b520","modified":1646461649830},{"_id":"source/_posts/JUC-CAS/1193919-20180102142546909-270453852.png","hash":"08b3d6a91cdda35570d698b5acdd0334e8a03b14","modified":1646461772985},{"_id":"source/_posts/JUC-CAS/1193919-20180102142548299-328053032-16464619321157.png","hash":"4a640dd46a92b1d96fc6d5d02c46a58c535fc327","modified":1646461932150},{"_id":"source/_posts/JUC-CPU-Performance-Optimization/CPU高速缓存级别.png","hash":"c3d0fc6735c910ac2273df44aba86101387f53e4","modified":1646473752472},{"_id":"source/_posts/JUC-CAS/1193919-20180102142625753-443716413.png","hash":"2093e180fe9e4a43c7db52f65ddf789e00469e18","modified":1646461935501},{"_id":"source/_posts/JUC-CAS/1193919-20180102142548299-328053032.png","hash":"4a640dd46a92b1d96fc6d5d02c46a58c535fc327","modified":1646461843168},{"_id":"source/_posts/JVM-JMM-Memory-Model/image-20220305205222083.png","hash":"c3016b1ae710e5fbc6d5bf3b345fc5c13e1faf2e","modified":1646484742105},{"_id":"source/_posts/JAVA-ArrayList&LinkedList/QQ20210220-112151@2x.png","hash":"59cc8c42ed2dd567f1844580c5c24923d29ffd49","modified":1646374962149},{"_id":"source/_posts/JAVA-ArrayList&LinkedList/QQ20210219-143407@2x.png","hash":"502f8c64b96178db411fe1c54720d997edb0a5e8","modified":1646370341861},{"_id":"source/_posts/JAVA-ArrayList&LinkedList/QQ20210220-112546@2x.png","hash":"4b9ba696eb25189d26869c34578cda9592418bcb","modified":1646374997153},{"_id":"source/_posts/JUC-CPU-Performance-Optimization/image-20220305180930700.png","hash":"9c41b372394ba05998577d6521c1cdd7b61c6500","modified":1646474970717},{"_id":"source/_posts/JUC-AbstractQueuedSynchronizer/AQS-资源占用流程.png","hash":"7e7859f6e135e47b22194aa17e3dc83bd84f2f79","modified":1620969251794},{"_id":"source/_posts/JUC-ForkJoin/ForkJoin.png","hash":"d2e0b54687a8ec722e42fdaa0d9ec87d0855df23","modified":1646378201934},{"_id":"source/_posts/JUC-AbstractQueuedSynchronizer/AQS-接口.png","hash":"045942daf5e0e0a332e6dd04b36decaedc15c27d","modified":1646366145365},{"_id":"source/_posts/JUC-Unsafe/20191211175818692.png","hash":"ff4b7e15cc18135462f1f1641ddf8fa34b686601","modified":1646467933146},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1645863504096},{"_id":"themes/next/.gitattributes","hash":"aeeca2f1e987d83232d7870d1435a4e3ed66b648","modified":1645863504096},{"_id":"themes/next/.gitignore","hash":"087b7677078303acb2acb47432165950e4d29b43","modified":1645863504111},{"_id":"themes/next/.eslintrc.json","hash":"611e15c3fcb41dc68fa8532ee595a1262a1b5a8a","modified":1645863504096},{"_id":"themes/next/_config.yml","hash":"1b8912ad59ab04a034345fe4a9883f8d0e4cbbb5","modified":1646490568692},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1645863504111},{"_id":"themes/next/_vendors.yml","hash":"7b258f85a083815ef05012103cb1c4a9f86c19b0","modified":1645938137283},{"_id":"themes/next/package.json","hash":"135869e7a1d9fcf4fd57dfd401a7828bd81db3bf","modified":1646393919310},{"_id":"themes/next/LICENSE.md","hash":"8cfb03967dd4cbaf3b825271ffce0039aa3fc22a","modified":1645863504111},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1645863504111},{"_id":"themes/next/.githooks/pre-commit","hash":"b69b9d0b51e27d5d4c87c3242f5067c2cda26e44","modified":1645863504111},{"_id":"themes/next/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":1645863504163},{"_id":"themes/next/README.md","hash":"43fe29330352545446a532e6630866251129882a","modified":1645863504111},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"593ae64e72d43c020a697eac65b1f9c3483ff097","modified":1645863504111},{"_id":"themes/next/.githooks/install.js","hash":"305c2a269818466eed9e381b866c6cd1ad7f8afd","modified":1645863504096},{"_id":"themes/next/.github/config.yml","hash":"0956bf71b6f36632b63b14d26580458041a5abd2","modified":1645863504111},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1645863504111},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"2fdca1040427cabfe27cae6754ec5e027ec7092e","modified":1645863504111},{"_id":"themes/next/.github/labeler.yml","hash":"ff76a903609932a867082b8ccced906e9910533a","modified":1645863504111},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"a103e2d875f7434191859e5b42075cfa9a4cbcb3","modified":1645863504111},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"a1aa85a2fc66ff0c52c65bd97b0fa282e297a73f","modified":1645863504111},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1645863504111},{"_id":"themes/next/languages/README.md","hash":"b1c96465b3bc139bf5ba6200974b66581d8ff85a","modified":1645863504111},{"_id":"themes/next/languages/ar.yml","hash":"cc7e3e2855348563d746f15c4752b9c63fcdd91a","modified":1645863504111},{"_id":"themes/next/languages/bn.yml","hash":"e78a674af44f19415b9bd91e994548a95be174ae","modified":1645863504111},{"_id":"themes/next/languages/de.yml","hash":"83023c4246b93a2f89f342afe29a7b9e1185f74f","modified":1645863504111},{"_id":"themes/next/docs/AUTHORS.md","hash":"579014d47f45b27fd1618b9709f0efe9585c7449","modified":1645863504111},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1645863504111},{"_id":"themes/next/languages/en.yml","hash":"c20f5beb611dd95c0d9b5a7b0f23b4b57fb2c08d","modified":1646538650363},{"_id":"themes/next/.github/release-drafter.yml","hash":"de38f816e3023e0a5c1fd1f3c2b626f78bc35246","modified":1645863504111},{"_id":"themes/next/languages/es.yml","hash":"21676d658d309eb90342a924e106645611c937bc","modified":1645863504111},{"_id":"themes/next/languages/fa.yml","hash":"e09fad889ab3ae87874093e1acd51edc9297d869","modified":1645863504111},{"_id":"themes/next/docs/LICENSE.txt","hash":"d1cd5a8e83d3bbdb50f902d2b487813da95ddfd3","modified":1645863504111},{"_id":"themes/next/languages/id.yml","hash":"d7c337ca72efb0bd02ade8b5560c559384ad84dd","modified":1645863504127},{"_id":"themes/next/languages/it.yml","hash":"c038ff0cadbe405750d980bcacfd3900acf96905","modified":1645863504127},{"_id":"themes/next/languages/fr.yml","hash":"328c255c82e9b561e20a9f51a4d84abc63d1b90a","modified":1645863504127},{"_id":"themes/next/languages/ja.yml","hash":"57a35b21aca04ce8bca64fb5933f35626c462ea3","modified":1645863504127},{"_id":"themes/next/languages/nl.yml","hash":"e47858bd1e0d0622c15366ae6c0513d996f589e3","modified":1645863504127},{"_id":"themes/next/languages/ru.yml","hash":"837bb39651769244b19ce458053757d429869764","modified":1645863504127},{"_id":"themes/next/languages/pt.yml","hash":"ff93459250c33d3c7ba06c30164cc4208edf9b33","modified":1645863504127},{"_id":"themes/next/languages/pt-BR.yml","hash":"305025e932832328b7e2a8a584638a23c462e68f","modified":1645863504127},{"_id":"themes/next/languages/ko.yml","hash":"d6e2add7488065ec4f7d21cfcf7f0eaa877a84f4","modified":1645863504127},{"_id":"themes/next/languages/tr.yml","hash":"d3262d2221b0583a52e5d20a3cd1380f5dc49378","modified":1645863504127},{"_id":"themes/next/languages/tk.yml","hash":"bf61562ac892231bd28f23a2a5597ee98fb05aa6","modified":1645863504127},{"_id":"themes/next/languages/zh-CN.yml","hash":"f8379d15038e22ef7039d91272cb4f36842dbbe1","modified":1645863504127},{"_id":"themes/next/languages/uk.yml","hash":"f32871f67c63d26bc4e3e15df9b01f5a41236a50","modified":1645863504127},{"_id":"themes/next/languages/si.yml","hash":"c15ed758dbad890e856f4fc281208d7b78cc1a59","modified":1645863504127},{"_id":"themes/next/languages/vi.yml","hash":"e452ea8c48993262a3e8fce9d92072cafabfc734","modified":1645863504127},{"_id":"themes/next/languages/zh-HK.yml","hash":"c1ee97ceb56da76ecdc7b69fa975f28c8574441b","modified":1645863504127},{"_id":"themes/next/languages/zh-TW.yml","hash":"70c45076ad722b777956048fcc430eac37844c11","modified":1645863504127},{"_id":"themes/next/layout/_layout.njk","hash":"6003d532623cfd1b4a141b5978c5220c17e326ea","modified":1646539239598},{"_id":"themes/next/layout/archive.njk","hash":"fe68bb63dc0c76ea74bfda7c98a7bd2bfb91658d","modified":1646451619087},{"_id":"themes/next/layout/category.njk","hash":"7e2522bd0ec037aae6beb27cd07ed9a085f54d3b","modified":1646355722983},{"_id":"themes/next/layout/index.njk","hash":"fa52c3049871e879980cb6abccdea3792ca4ce70","modified":1645863504161},{"_id":"themes/next/layout/post.njk","hash":"6a76a693447a56b848236bb61505669444cd3b0a","modified":1646392294985},{"_id":"themes/next/test/index.js","hash":"983a505399796b9d9e174ba46d89abbdde38f8ee","modified":1645863504223},{"_id":"themes/next/layout/page.njk","hash":"1020393bd96b6b48f0b5d65770b89b777cfff3c2","modified":1646538560330},{"_id":"themes/next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1646538020611},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4a7885fe2c8b25be02ab57c345cd862aeeeeacaf","modified":1645863504111},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"7dec949b13131783e726facb2f4acde0945db1b8","modified":1645863504111},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"618d07b49f4774cd79613d4001984a19d954a6ad","modified":1645863504111},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"032194e7975564176f2109aa8b7c020fa6d5e6b1","modified":1645863504111},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"46d0b29dc561fe571d91fd06a7c8ef606b984c72","modified":1645863504111},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"daeedc5da2ee74ac31cf71846b766ca6499e9fc6","modified":1645863504111},{"_id":"themes/next/.github/workflows/lock.yml","hash":"58eca481fd71088a8ae1dbc04645bcfc03460b87","modified":1645863504111},{"_id":"themes/next/.github/workflows/stale.yml","hash":"32e7dfb55ecf8af66aebfed471be09ef2eb10e18","modified":1645863504111},{"_id":"themes/next/.github/workflows/release-drafter.yml","hash":"359b74890a47d784e35a5cc3c7885d5cdf302e82","modified":1645863504111},{"_id":"themes/next/.github/workflows/linter.yml","hash":"b57d876c90d1645a52bbba8a52d47ad0b0c96140","modified":1645863504111},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"d9d8e6d7a6a8c80009dd5334cc17fd3e4977a008","modified":1645863504127},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7befb4325b107dd668d9eae3d7e86a34910ce3f2","modified":1645863504111},{"_id":"themes/next/.github/workflows/tester.yml","hash":"b53053d82f428605f29274b318d73429a37fb275","modified":1645863504111},{"_id":"themes/next/docs/ru/README.md","hash":"e1d6bf38cf34972ca2ee5331a727787fe14082a3","modified":1645863504111},{"_id":"themes/next/layout/_partials/comments.njk","hash":"d6b7bb7764e3b471ed6b4e5715f6cbe2dd453f59","modified":1645863504127},{"_id":"themes/next/layout/_partials/footer.njk","hash":"18c609ef34d9440b3525fe47041bdbd849fb9504","modified":1645947880726},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"be779ec6d11bf9ba28f89191ab70728581042f5a","modified":1645936512915},{"_id":"themes/next/layout/_macro/post.njk","hash":"2bbc3a2f3bc52a0f8d81ad6f617585ccfc941ae8","modified":1646452164441},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a09ceb82b45dd8b7da76c227f3d0bb7eebe7d5d1","modified":1645863504111},{"_id":"themes/next/layout/_partials/languages.njk","hash":"537026fc120adeef9148c98ebf074207e3810538","modified":1645863504141},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1645863504144},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"54a89accfdbfa2e6df912994c496815ed802cc6e","modified":1645891986526},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"0a1470440f11362df2b1cd6b6228e273d9f999d6","modified":1645863504149},{"_id":"themes/next/layout/_scripts/index.njk","hash":"4eb65641b47ea9b23ed2ddfd69b18f21d7d8f214","modified":1645863504149},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"53ad3c31762b74e5d29787b37d5e494cc4fded9b","modified":1645863504155},{"_id":"themes/next/layout/_third-party/index.njk","hash":"33a4a3275474bd3bb2e8d1b0ea01b42dda9ea608","modified":1645863504155},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"13b2a77b4858a127f458ea092b6f713b052befac","modified":1645863504157},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"73bc15a9c3c5c239ab90efa19a1e721f41f3cb93","modified":1645863504157},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"0c9a1fe9906672724dbf274154a37bac1915ca2c","modified":1645863504168},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"d0444179fec512760ab1d4f76928d795b971c884","modified":1645863504157},{"_id":"themes/next/docs/zh-CN/README.md","hash":"354b0b0a24cbe97cccf2ec8bd97eb7d624fa0dea","modified":1645863504111},{"_id":"themes/next/scripts/events/index.js","hash":"3bc03b801ce874fa7cbdacd31a7ff25a603a8ac4","modified":1646206858193},{"_id":"themes/next/scripts/filters/locals.js","hash":"87f3bff03fa9fd96cf0787a6442464a7ff57f76b","modified":1645863504169},{"_id":"themes/next/scripts/filters/minify.js","hash":"056f9c9f8c6e34b084b4ac69901c9858a072d9ab","modified":1645863504169},{"_id":"themes/next/scripts/helpers/engine.js","hash":"11c40cd31cec00bfca7a45d596e76b425fc397c5","modified":1645863504170},{"_id":"themes/next/scripts/filters/post.js","hash":"5a132b7f9280a40b3d5fb40928c8cbbe071fe6f6","modified":1645863504170},{"_id":"themes/next/scripts/helpers/font.js","hash":"0a6fa582a0890ecaf5f03f758a730936e48aeca1","modified":1645863504171},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"98fc68cf3fcd6253bbb94068ab1d86578a4ef9ea","modified":1645863504171},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"e73f43f1bcb46965e317285d6831e129a40ea59b","modified":1645974792211},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"52acbc74c1ead8a77cd3bbcba4e033053683f7d0","modified":1645863504172},{"_id":"themes/next/scripts/tags/button.js","hash":"86c71c73a63744efbbbb367612871fede0d69529","modified":1645863504172},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"b4d12e6fe29089be0f43bafc9eea736602cd16bf","modified":1645863504173},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"8e912c715702addaf0cefe63e580e45b97ae8c3f","modified":1645863504172},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"1c609312a71d47f838226346aad5c2e1c35f15dd","modified":1645863504173},{"_id":"themes/next/scripts/tags/index.js","hash":"255dd1090e8319b557eeca43571f0e4f8aab013b","modified":1645863504174},{"_id":"themes/next/scripts/tags/label.js","hash":"c18b0e619a779ed40be7f014db92af18f45fbd5c","modified":1645863504174},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"3f358bb78c5c6fdf45de287f3ead553e3a6a93c2","modified":1645863504174},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"b3844e168b51a99d495ca05562ffac47677f5728","modified":1645863504175},{"_id":"themes/next/scripts/tags/note.js","hash":"a12fd53e421400836a3722ae69130969558d6ac0","modified":1645863504175},{"_id":"themes/next/scripts/tags/pdf.js","hash":"317ba4611020cc840854386dde098dbbe452777e","modified":1645863504175},{"_id":"themes/next/scripts/tags/video.js","hash":"f6ad3f52779f0636251238d3cbdc5b6f91cc5aba","modified":1645863504176},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e0ed5fe1bc9d2957952a1aacdf3252d6ef3f9743","modified":1645863504175},{"_id":"themes/next/source/css/_colors.styl","hash":"5ea14958044d7d6fe57c5312774a28b23932f90c","modified":1646023211579},{"_id":"themes/next/source/css/_mixins.styl","hash":"77f6b65a85b4be40329ce9cc2f15bda760e24001","modified":1646202434346},{"_id":"themes/next/source/css/main.styl","hash":"38b8a12681a3a04bed02aa1659054912ed6def11","modified":1645863504207},{"_id":"themes/next/source/images/avatar.png","hash":"950a75e7c1a7f9d510ede71f7d0bdeb1466ca514","modified":1645106268902},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1645863504207},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1645863504207},{"_id":"themes/next/source/css/noscript.styl","hash":"7dc97674c232f6ca71e48b95e3f66472cd8e9c05","modified":1645863504207},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1645863504207},{"_id":"themes/next/source/images/link.svg","hash":"6b87076b7dbd6cd6bd7112d86f193c7cdee7c255","modified":1646155730860},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1645863504207},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1645863504207},{"_id":"themes/next/test/helpers/index.js","hash":"2fb58dca3df2fe53116ee2b1232fa26ebe7b2ce5","modified":1645863504223},{"_id":"themes/next/source/js/bookmark.js","hash":"1457291a7244b7786ec35b949d97183e4fbd181d","modified":1645863504207},{"_id":"themes/next/source/js/comments.js","hash":"0b4daf0ce610760bd52e95d423f61f3e1c72442a","modified":1645863504207},{"_id":"themes/next/source/js/config.js","hash":"211a9ab35205ccfa6b7c74394bade84da0d00af7","modified":1645863504207},{"_id":"themes/next/test/helpers/font.js","hash":"6f5076bd3f2724e47b46ca69028393a9b6275cd1","modified":1645863504223},{"_id":"themes/next/test/helpers/next-url.js","hash":"08e84781f1cd54e5634b86877ad9cefae4a78e95","modified":1645863504223},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1645279153596},{"_id":"themes/next/source/js/next-boot.js","hash":"b0bdb542a809932182cfbb8772328115142a0b77","modified":1645891634324},{"_id":"themes/next/source/js/pjax.js","hash":"85293c253e0f43540572c4e4615c712325a732e2","modified":1645863504207},{"_id":"themes/next/source/js/utils.js","hash":"2d4f6c7a109b8dffd0817c7623fd0b732042fe48","modified":1646411266369},{"_id":"themes/next/source/js/comments-buttons.js","hash":"81ea6cbcdf0357094753d7523919c1eafa38e79f","modified":1645863504207},{"_id":"themes/next/source/js/motion.js","hash":"20b979ebe3671cb415e6e7171485d65cc347086e","modified":1645863504207},{"_id":"themes/next/test/tags/group-pictures.js","hash":"8f66d3c6f03fb11d85aa2ab05c9b3c9aa2b4e994","modified":1645863504223},{"_id":"themes/next/source/js/schedule.js","hash":"6dade4388aa6579576a35758075134f573985d57","modified":1645863504207},{"_id":"themes/next/test/tags/center-quote.js","hash":"2ac4b5a358681691a17e736de06fce0b640a7023","modified":1645863504223},{"_id":"themes/next/test/tags/button.js","hash":"a50ca44eaec3d91c2958e3157d624cd3e68828c7","modified":1645863504223},{"_id":"themes/next/test/tags/index.js","hash":"5cad001936a694bf32d59751cc2b68a66199f976","modified":1645863504223},{"_id":"themes/next/test/tags/label.js","hash":"6cad7d84c42511459a89cda3971e8ea5cdee0125","modified":1645863504223},{"_id":"themes/next/test/tags/mermaid.js","hash":"f718a3d0e303d842e2ca5a3b162539a49e45a520","modified":1645863504223},{"_id":"themes/next/test/tags/caniuse.js","hash":"2852be850d9103c25114253a45e6c62e32517de4","modified":1645863504223},{"_id":"themes/next/test/tags/pdf.js","hash":"2d114596a8a180b2f3cd2a9c6528a328961f12d4","modified":1645863504223},{"_id":"themes/next/test/tags/link-grid.js","hash":"41730266306c02362258384cd73659223928361f","modified":1645863504223},{"_id":"themes/next/test/tags/video.js","hash":"88db9a3a26cd35525c43c0339fcd1c5965ec9518","modified":1645863504223},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"fd83bbe03833b126c0138c9312ea306a6cf556cd","modified":1645863504127},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"3ff7e251bf99a275cd5dfda1b3e51f773c5f7b05","modified":1645863504127},{"_id":"themes/next/test/tags/note.js","hash":"161a81ce749e239d2403681372d48ecc1b51d7b9","modified":1645863504223},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"1b2ae17f3c394ce310fe2d9ed5f4d07d8cc74ae7","modified":1645888056158},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"8f11cdf5147ffbe1eee2c16aa208faea0207cfe5","modified":1645972348217},{"_id":"themes/next/test/tags/tabs.js","hash":"b19d2592347eae5d6a7a97ca7e8cec03e8f25b51","modified":1645863504223},{"_id":"themes/next/test/validate/index.js","hash":"560862194991c5963da5a411629d8e6c71d20ee2","modified":1645863504223},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"f066390762faf6684a523e2eb943420023aac2b1","modified":1645863504127},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"bb711592430b03bdf4fcf89d16278a72c68f7ded","modified":1645968297570},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"940cad08a67e6c361214045096bd3cdffdf44fcf","modified":1645863504140},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"9c136edd2248e2d50c1f6110b75e2b75c299bbd7","modified":1645863504142},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"b352346dd2cb42f7eeaec5e39d9a2a353b029775","modified":1645863504143},{"_id":"themes/next/layout/_partials/page/friends.njk","hash":"dc96c135ded015f777b0ea84fd3c6973d953739c","modified":1646302861102},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"62bd3884ff9b7156317f8ac0e4b12d3aa78753a3","modified":1646391228001},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"b4ba28aba3b6115da823b6e453afddeeeb5de227","modified":1646390905674},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"130e776575d634201d4f8ef3d78dc12624f19fde","modified":1645863504144},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"93fbb449fbd599cb4315d7eb0daeb239811b233f","modified":1645863504147},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"9766852e72c1809d8c1eea71ac6116b4cc0886d2","modified":1645863504147},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"2b016e9b9dcf5f4b9851fccd9a43b7f5dbb375fd","modified":1645893761267},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"0ebc0142abebbeef4278e32abb543c7d7fa75d88","modified":1645863504145},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"ebf83083856f8bd81ad47ffb985d44e338b4e6bb","modified":1645863504145},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"e3502059bcc443ce932946a9891fcbe8b2bb362d","modified":1645863504145},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"0d0e2c9f066cb210f8b6c428b658c36a43400e6b","modified":1646151107648},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"d5c79ccb72bd4fd67b0d6c52eae7108c3f27bacd","modified":1646214533274},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"fe9ab235884a8033f2d536184f12c2fa65f16c46","modified":1646213337964},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"17e03b61e20a5cb4195f0e0d75261ce61a1cddc4","modified":1645863504146},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"3e80332f88b101141be69f2a07f54ed8c053eabb","modified":1645863504150},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"52ad137450f7b3d6a330e16b3ed1c6174290f0eb","modified":1645863504151},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"c7cea42f6db2137c11ca1d83e43fcb7ad7ccfb89","modified":1645863504150},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"9ff9ec05c2037beea229a6bb698f9e3546973220","modified":1645863504151},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"50c42adf5ba59ff227e9bce6dc4085694e5fe3c2","modified":1645863504151},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"eef710e9be20e7fed7573d0824feaa4eb1cf2737","modified":1645863504151},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"09d2c9487d75894d45a823e3237ae9f90fd6ee01","modified":1645863504152},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"5f7967bd946060f4102263a552ddfbae9975e7ea","modified":1645863504153},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"3fbc72427c1211e5dcfd269af1a74852a7ba5c1a","modified":1645863504152},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"b0828dd1b1fd66ecd612d9e886a08e7579e9a4f7","modified":1645863504153},{"_id":"themes/next/layout/_third-party/chat/gitter.njk","hash":"375a86f0b19e130cfa7707007e3a53d9ae7c9b64","modified":1645863504152},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"c5086b4c35f730f82c99c4a8317f2f153ebde869","modified":1645863504154},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"6fd4df5c21cfe530dbb0c012bc0b202f2c362b9c","modified":1645863504154},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"38badcc7624a13961381c2465478056b9602aee5","modified":1645863504154},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"a7921be7328e1509d33b435175f5333a9aada66f","modified":1645863504155},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"b8e0d5de584cece5e05b03db5b86145aa1e422b4","modified":1645863504154},{"_id":"themes/next/layout/_third-party/comments/valine.njk","hash":"3695ec76a6f4295a46013cae8756883de17c5d52","modified":1646456261751},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"1856c4b035c5b8e64300a11af0461b519dfc4cf4","modified":1645863504156},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"a84db8bc8804335f95609a221ac1746433dcdc89","modified":1645863504156},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"67f67a77f27103177b9940446f43610229536d82","modified":1645863504158},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"a62aa1ed4e35b8d0451d83f341bf0a97538bc9a4","modified":1645863504156},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"210c32b654adae3d8076c4417d370b42af258cea","modified":1645863504158},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"dd8f963acd5a3685be46fd5319c06df0308d99b2","modified":1645863504160},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"d97790e4b442a1e3ded7d7b4f84b8ee6cdb6e8ea","modified":1645863504159},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"af5336e8bbdc4638435971da115bb7443d374ade","modified":1645863504159},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"866ffa15a3250678eb8a90aa6f609fa965db90fd","modified":1645863504159},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"0386c708975cc5faea4f782611c5d2c6b8ac2850","modified":1645863504160},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"8703d1855bb8d251c9b7c2940b7e3be525e53000","modified":1645863504160},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"17fbc99521440a5d6c32ac991ba2038a12f86b31","modified":1645863504166},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1645863504166},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"1cb58aa6b88f7461c3c3f9605273686adcc30979","modified":1645863504166},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3283bdd6e5ac7d10376df8ddd5faaec5dc1bd667","modified":1645863504167},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"0ba405719a9e232163f32df2d57c52bb43399694","modified":1646380626781},{"_id":"themes/next/scripts/events/lib/config.js","hash":"f78cd74b25cc0ef65c060fec1d7e056967e26b4b","modified":1645863504164},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"c22cbccd7d514947e084eeac6a3af1aa41ec857a","modified":1645863504167},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"96e58efba0dc76af409cc7d2db225f0fe4526ea8","modified":1645863504167},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"bb8ebb541c40362c0cbbd8e83d3b777302bb6c40","modified":1645863504168},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"dc2ebf7cdb01d72f59a52660dd4f98bc98e52bed","modified":1646455072920},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"00cec6980cafd417def885f496371856cd524a25","modified":1645863504164},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"1f1ea7b579a49f17574c31d78d663c54896133eb","modified":1645863504164},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"a50718c081685fd35ff8ea9ca13682c284399ed8","modified":1645863504168},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"7bdf8588563cd13a1eb7a2c5bcffd831855b59a0","modified":1645863504165},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"09cba2c433fe47981d07d67c038790f4fc2ec16b","modified":1645948932820},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"0fa7516da1175628216621c1ac3b8eeff7e7a210","modified":1645952357075},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"c4537fa2de33d98baff2c87a73801770414e0b69","modified":1645863504192},{"_id":"themes/next/source/js/schemes/muse.js","hash":"b05dd5cc085684f9808e1d9d9e297b72af74e306","modified":1645938721740},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"ab7d6cced9dfa0a5141f0d0ece5afd675214a143","modified":1645947293096},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ce20cdf434e9ea7a442b03d0ef3dfe5b11529b69","modified":1646154741538},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"58014a2d087c4126058a99b5b1cb7d8a2eb6224d","modified":1645863504207},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"7782dfae7a0f8cd61b936fa8ac980440a7bbd3bb","modified":1645863504189},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"8a847a7bbdbc0086dd1de12b82107a854b43f5e5","modified":1645863504207},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ebee77b2307bf4b260afb06c060171ef42b7141","modified":1645863504207},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"5b0197e061f57e00875be3636ba372a67693abe0","modified":1645863504207},{"_id":"themes/next/source/js/third-party/rating.js","hash":"a1f44247c18ac00ee3e0026560398429e4c77dd7","modified":1645863504207},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"2db4462e9cb87b8aef3f50f850fed407de16da3e","modified":1645863504190},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"cbd263b341b986f202d965d85fce51f140d2e5c4","modified":1645939719220},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"e148c10b0ca5d5c727942f135b2f28443b183c3e","modified":1646202538733},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"991c1f80995cec418dc00d3d6b13e2d911ac9894","modified":1645863504178},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"f3defd56be33dba4866a695396d96c767ce63182","modified":1645863504183},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"f768ecb2fe3e9384777c1c115cd7409e9155edd7","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"f57fbf7ca1e3dfb98d4e65ae15d34e8e6bad8505","modified":1646454379854},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"9d482e253e54edeeac23e34dba745040ccef7683","modified":1646152116877},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b9388016f8d9274703e77e306a1feaad1b7b9d6c","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"90f7d3baab061e860172b536c9edc38c7fd2ef5c","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"607117c6ccb89567821ecdc85deaaa4ea54413c7","modified":1645969357472},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"898508239b1373bbf15dd582be0c5d6e0e0373c4","modified":1646151954920},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1646151839333},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"9b2cba0c9aa5a64957294f7548c199db1f63f0f4","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"60184a58f4df34c4460f939e1bb46aa2b893cb63","modified":1646156097928},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"89bf3f6b82cb0fafbbd483431df8f450857c5a0b","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6bb9fe1ab5e07ed86c7f8dcce0aae4f25e24a251","modified":1646156097918},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5c3dd08c520a16ee49f85fa12b4935e725ef261","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"3764f8ed9b311f2d32bda979891a6bfc674954eb","modified":1646156097932},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86c5868450d6fadff4a59511738ead05e9551941","modified":1646149029068},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"fd89988442f380cba907752fe3f608e3498f8c93","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"459375cf22bcd20478089a967ffecb2d7a6d7a80","modified":1646149961731},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"9f60d501808f67d151af437221d0dfacc27c180c","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"b11a4d209af2b9aca58219535acd6dafdefa1426","modified":1646153311130},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"08f23c34c19da2358a89a0ecb3230923cf4e60f4","modified":1645946275821},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1645863504192},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1645863504192},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"72e0766752b78a723fb30e92d533a8b353104e2d","modified":1645863504207},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"28030c61288cc0e1321b18373a5c79029fd76a53","modified":1645863504192},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f9579a02599de063ccff336177ba964a2931a6e9","modified":1645863504207},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"f755e8537ccbbb0bd84c26923f320d4e206e7428","modified":1645863504207},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"d77d4934d959e7125128754b568f1d041c3fbfff","modified":1645863504207},{"_id":"themes/next/source/js/third-party/chat/gitter.js","hash":"14b024c920a8b359777d79dd8e1a849387f8f3ad","modified":1645863504207},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"77c231bcd64f1c09bd9989909e9fee703b65f47f","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"1c282d6c2151346d1f0aa95055d17abe77054ec9","modified":1645863504207},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"5c63ec71458b4fe0cd98fd4a04e11c3746764f11","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"68892d74ef5fc308c6e7e6b4f190826d79f3055d","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"b4cb06fdf531292e2361398a98d75a4ca2b8473a","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"5460de247c038d6cfbe774d7f8747f0a958d9017","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"ec44d7f1c8b51b0aa3cccba099a78f3575ac828c","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"b9b9fd2f0e098a123b34a4932da912a9485ffe6c","modified":1645863504207},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"1e8509356fb027d948d118ab220d9631f4d482fa","modified":1645863504207},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"d93556184b2c0aa1dbc4a6fb892d2f77b80d7d9f","modified":1645863504207},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"dc2b0e89aa32afc7f7a7e2d7a277dadb7f96e06d","modified":1645893724123},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1477558306000},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"ea94731438d8c518d946601f8f46a65b92381fac","modified":1645863504207},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"6abdc209f4503d4efd676e18bc30ddea813b6ff9","modified":1645863504223},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"e109c2d6828f527f0289d5fa3bb02fce63ee6d93","modified":1645863504223},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"d0829fe41d2fe86b8499e2a896556c1275ea0066","modified":1645863504223},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"2618135cbcee6bf228f6734767de1995e5eaaac6","modified":1645863504223},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"f2f5498a3798d6a66a455f8170bcebc0496ee12d","modified":1645938668236},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"c8648c8ea3105556be0068d9fb2735261d0d94bc","modified":1645863504187},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"05af22f3edc2383a3d97ec4c05e9ac43b014bead","modified":1645863504188},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"2db695204d39e4c7daa7b91585a0ea4b06b49f11","modified":1645863504188},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"67fc7a1eb59c8451eec34e572cbb2fd1424757bc","modified":1645863504188},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"d9bc2b520636b9df7f946295cd430593df4118ff","modified":1645863504189},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"86b0925e968f35bbc76b473a861e8f9797f7580e","modified":1645863504189},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"6cec28209076c1feeec89e866da653008394d133","modified":1646064545261},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2c2bfbc34b6f19d262ae7c041474985e12f4f4ad","modified":1645863504191},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"2732f3ff32256e3ad80222ae22252075d7b73744","modified":1645975015093},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"1c324d56ae83e96db2c4c6d63edd7ee51c936fc1","modified":1645863504191},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"63d8f5f169c2b1c969928fc79244c5fe89ee484e","modified":1645863504192},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"09bed6818f55729c74214528e49b396a951e688a","modified":1645892571916},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"c84cb5c314adb8a540e2826a6fbf064c5e32985c","modified":1646450737355},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"b2b93b0424c128fca2072ceb19bf6118cd56255b","modified":1646450719964},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"6681ffe283f8a7e3c86310ef4f6ca1e499c1a19f","modified":1645863504192},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2de038def2cb91da143b14696366c14a66e0e569","modified":1645863504192},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fde10ce94e9ae21a03b60d41d532835b54abdcb1","modified":1645863504179},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"80595d274f593b321c0b644a06f3165fe07b16f5","modified":1645863504179},{"_id":"themes/next/source/css/_common/components/pages/friends.styl","hash":"04c70e94400d7a7e845976144244e719da7a9865","modified":1646302197846},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"d965b30558e0ed4c7d70c878b8a1b1fbf2cbfe68","modified":1646302328127},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"703cc527c11f109d67f31588ca713ead570ea2e6","modified":1646538842329},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"df2fbd0ada00f37439b0de965c6f1c29d3c97429","modified":1645863504180},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"091b8c763e43447d087c122a86538f290f83136a","modified":1645863504179},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"4626bacb6b8cae52bb967d1038cf0199d1251ea6","modified":1645964615580},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"60b194a1092dcb03f0652469723c56abefdacf15","modified":1646451719097},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"e53a5eb1d1771e284044bdb0bc0ed2de27923669","modified":1645863504182},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"791bc9befb0d4d06e3e517eccfe0bc3551a02a60","modified":1645863504181},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"c34936a17c3d8af6c0988ac6746d7509dc0b50eb","modified":1645863504182},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6eff2af64ca83260720fc5371d08a8fcc8612039","modified":1646452477603},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"025ec8ecc52a0527b459dcc76eafdb1f040c7db5","modified":1646362396386},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"2ce7468aa2647f1f68971b19c2b3c1a812660597","modified":1646216390362},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"0a779f955a0e25df0852e0731517dadb234aa181","modified":1645863504183},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"c1e9edbfd1c3696b35d5452ae2e6d766f3fe91aa","modified":1645863504184},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"fb165c1a0d990c5cf98b87773e0dc50410229b96","modified":1645863504184},{"_id":"themes/next/source/css/_common/components/third-party/gitter.styl","hash":"7b36f776c41fbb744572c5de2c8d49b35656ec21","modified":1645863504185},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"0c4c5e39f8ac12febaa0f4ff7265151e139edad8","modified":1645863504185},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"1e5776ad4c5c8bcf7596ac74dcabc30704b3f5a0","modified":1645863504185},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"0527153aa821bdbdb84c7b47f60e3cefd95a742f","modified":1645863504186},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"49c26184580fde8a732899a4de5aae8662e289b8","modified":1645863504186},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"ee05c1d00bc38397bd320128bbe15d05d9100039","modified":1645863504192},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"d28856f365a9373c4ae6fe1e5673d63df2dfd65f","modified":1645863504186},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"6b3680e0dbea8e14c1cec24ef63b7fae5e37f7ef","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"a4003e1408844568cb5102a5a111046cb19b2d31","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"8d9218980e185210ce034e9769ab639b9630fd88","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"e22fde6f1657d311d46f64d868c4491d535c8caa","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7075dd32dd70da1e161e4bd14b46f1e8be62fa3c","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"531daf2612c6217950677a2d03924459ce57c291","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"c7754dc6c866928b538f0863a05b96ec44b5e986","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"2e9dc3b3546e19e9de18050ad04b1741841116bc","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"40a38f2129617ffd4e8d5cd78e982fdfc9941acf","modified":1645863504192},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"77122986509a6b4968bae2729417b7016137534c","modified":1645863504192},{"_id":"themes/next/source/js/jquery.js","hash":"255057d893d00bf46df9a1471672e5a68d67199d","modified":1626582637617},{"_id":"themes/next/source/js/mo.min.js","hash":"4c69f052549568088af3f84b46830a24e7dfc97d","modified":1626582732969},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1477558304000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1477558304000},{"_id":"themes/next/package-lock.json","hash":"de485a4cebb7e2906887719b73a47399e1740ff2","modified":1646305929324},{"_id":"themes/next/yarn.lock","hash":"d5de7e059870af5239d49d6cc5837fd9ca56031d","modified":1646012504787},{"_id":"themes/next/source/images/wechatpay.png","hash":"3b8195f975a57bf0f5a482d3d9f664df4eabc440","modified":1646211935308},{"_id":"themes/next/source/js/valine.min.js","hash":"0acf84fea71c43aa7fa645ebeb0e5a5b58cc5e30","modified":1646456213273},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1477558304000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1477558304000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1477558304000},{"_id":"themes/next/source/images/alipay.png","hash":"5425e500d40af6ac2fec38a40315918590512c97","modified":1646211887634},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1477558304000},{"_id":"source/_posts/JVM-JMM-Memory-Model/webp.webp","hash":"4311eccdc695f75c37298884f714ec328d85728e","modified":1646540344324},{"_id":"themes/next/source/js/dark-theme.js","hash":"fca17ecc4a8866a3bbd9f14e5e2687dc981ff2e6","modified":1646539521581},{"_id":"public/search.xml","hash":"8f8eb17ca9482c71c4d71b0a501371e0d204feba","modified":1646540596965},{"_id":"public/tags/index.html","hash":"8859cd642098aaf8ed5187b99f549569b90ce9bf","modified":1646540596965},{"_id":"public/friends/index.html","hash":"6f3853d37124684e2f6b5c3381e44a0b6d654f88","modified":1646540596965},{"_id":"public/tags/Java/index.html","hash":"af7fd6d564955c68862b682af25f4194ecfff98f","modified":1646540596965},{"_id":"public/tags/JVM/index.html","hash":"c1afb7f5c4b274edadd28aa82443c2325f70ef45","modified":1646540596965},{"_id":"public/archives/2020/index.html","hash":"6460f049697821cb4407ab17a9938583ec93d560","modified":1646540596965},{"_id":"public/archives/2020/08/index.html","hash":"9c79d771f6d58dc4faae2984461e2187ddfedc70","modified":1646540596965},{"_id":"public/archives/2021/04/index.html","hash":"10f534794cf71dd87e0ba5aec51267f2a1e49460","modified":1646540596965},{"_id":"public/archives/2021/05/index.html","hash":"77dff25bb803fc522b09abc27338392fb5dfb99f","modified":1646540596965},{"_id":"public/archives/2022/index.html","hash":"8cb227ef8dc88a8913320ed9bbb3346df1cdd517","modified":1646540596965},{"_id":"public/archives/2022/03/index.html","hash":"9d47b69338d90c856ccef33dd43afe9148a92f45","modified":1646540596965},{"_id":"public/2022/03/04/JUC-AbstractQueuedSynchronizer/index.html","hash":"10ba83a210ff7106a7c5a1412e3223453a7c3574","modified":1646540596965},{"_id":"public/2022/03/04/JUC-Callable/index.html","hash":"c73e8174279b49047a3370f3e18bd9206cbbafb9","modified":1646540596965},{"_id":"public/2021/08/22/JUC-Unsafe/index.html","hash":"4efb555d3a585f997772f929273672989a727e31","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CPU-Performance-Optimization/index.html","hash":"fb8c9966e74f9a9894062b3e6ca136018707e04e","modified":1646540596965},{"_id":"public/2021/08/22/JUC-ForkJoin/index.html","hash":"e48b798b0188cd8abece44594e6d3b7ea0c3e630","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CAS/index.html","hash":"9d50ab7ad1a5dd08e8c29b1ca8ec84344ccfe88f","modified":1646540596965},{"_id":"public/2021/08/22/JUC-SingletonPattern/index.html","hash":"204d3f90600516f63e6f48f11b06b8303aff8878","modified":1646540596965},{"_id":"public/2021/05/05/JVM-JMM-Memory-Model/index.html","hash":"631fbdde9e2bf7ad84b2971bf05cecb3d06abc2c","modified":1646540596965},{"_id":"public/2021/04/12/JUC-Thread-interrupt/index.html","hash":"db4d917d2ae5bda1f6843182332db0d3b38c9213","modified":1646540596965},{"_id":"public/2020/08/08/JAVA-ArrayList&LinkedList/index.html","hash":"d011decb605b272ab21be684e603e7c637a4e05a","modified":1646540596965},{"_id":"public/tags/Juc并发包/index.html","hash":"cc0e12f2b48d0e4f555e97dbd4f744b97e66b68a","modified":1646540596965},{"_id":"public/page/2/index.html","hash":"2d3c66f7f819949985973e18942f852a16df0770","modified":1646540596965},{"_id":"public/archives/index.html","hash":"8b365f2c886fd1ad3bdcbadaf894afdb814ee232","modified":1646540596965},{"_id":"public/index.html","hash":"c07b4c51c6d56ff61695f70667133b7bd75b1b1f","modified":1646540596965},{"_id":"public/archives/2021/index.html","hash":"612a5258de44f98bca6e0a6596b94f3b5801c4b1","modified":1646540596965},{"_id":"public/archives/2021/08/index.html","hash":"99408c0ea2115a6f05b89983129590295f02708a","modified":1646540596965},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1646540596965},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1646540596965},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1646540596965},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1646540596965},{"_id":"public/images/avatar.png","hash":"950a75e7c1a7f9d510ede71f7d0bdeb1466ca514","modified":1646540596965},{"_id":"public/images/link.svg","hash":"6b87076b7dbd6cd6bd7112d86f193c7cdee7c255","modified":1646540596965},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CPU-Performance-Optimization/CPU高速缓存级别.png","hash":"c3d0fc6735c910ac2273df44aba86101387f53e4","modified":1646540596965},{"_id":"public/css/noscript.css","hash":"54d14cd43dc297950a4a8d39ec9644dd5fc3499f","modified":1646540596965},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1646540596965},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1646540596965},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1646540596965},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1646540596965},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1646540596965},{"_id":"public/css/main.css","hash":"1243770c789ad1ad77ab6584b4d1b9fd22dc6db8","modified":1646540596965},{"_id":"public/js/jquery.js","hash":"3cca78feb86ab7549f20306ab25c7ab76c72b21f","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CAS/1193919-20180102142540362-571280295.png","hash":"6743349601b14b643ee2b5b7c89bd5676efbe7db","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CAS/1193919-20180102142542299-1617994496.png","hash":"2f0453f290b9fb56ebfdb5b786117b0eedbe5822","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CAS/1193919-20180102142543784-1625100143.png","hash":"d60b669dc12d78cc26c38826b9fc5159a296b520","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CAS/1193919-20180102142545221-837543615.png","hash":"1fa51bfcae9410ed84ba47cdbcf7fc8a055a4a33","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CAS/1193919-20180102142546909-270453852.png","hash":"08b3d6a91cdda35570d698b5acdd0334e8a03b14","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CAS/1193919-20180102142548299-328053032-16464619321157.png","hash":"4a640dd46a92b1d96fc6d5d02c46a58c535fc327","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CAS/1193919-20180102142548299-328053032.png","hash":"4a640dd46a92b1d96fc6d5d02c46a58c535fc327","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CAS/1193919-20180102142625753-443716413.png","hash":"2093e180fe9e4a43c7db52f65ddf789e00469e18","modified":1646540596965},{"_id":"public/2021/05/05/JVM-JMM-Memory-Model/image-20220305205222083.png","hash":"c3016b1ae710e5fbc6d5bf3b345fc5c13e1faf2e","modified":1646540596965},{"_id":"public/2021/05/05/JVM-JMM-Memory-Model/webp.webp","hash":"4311eccdc695f75c37298884f714ec328d85728e","modified":1646540596965},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1646540596965},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1646540596965},{"_id":"public/2020/08/08/JAVA-ArrayList&LinkedList/QQ20210219-143407@2x.png","hash":"502f8c64b96178db411fe1c54720d997edb0a5e8","modified":1646540596965},{"_id":"public/2021/08/22/JUC-CPU-Performance-Optimization/image-20220305180930700.png","hash":"9c41b372394ba05998577d6521c1cdd7b61c6500","modified":1646540596965},{"_id":"public/2020/08/08/JAVA-ArrayList&LinkedList/QQ20210220-112151@2x.png","hash":"59cc8c42ed2dd567f1844580c5c24923d29ffd49","modified":1646540596965},{"_id":"public/2020/08/08/JAVA-ArrayList&LinkedList/QQ20210220-112546@2x.png","hash":"4b9ba696eb25189d26869c34578cda9592418bcb","modified":1646540596965},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1646540596965},{"_id":"public/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1646540596965},{"_id":"public/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1646540596965},{"_id":"public/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1646540596965},{"_id":"public/js/utils.js","hash":"2d4f6c7a109b8dffd0817c7623fd0b732042fe48","modified":1646540596965},{"_id":"public/js/schemes/muse.js","hash":"cbe5d95c2b084dec03d11f8c97f1be1c8a0574d5","modified":1646540596965},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1646540596965},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1646540596965},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1646540596965},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1646540596965},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1646540596965},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1646540596965},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1646540596965},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1646540596965},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1646540596965},{"_id":"public/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":1646540596965},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1646540596965},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1646540596965},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1646540596965},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1646540596965},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1646540596965},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1646540596965},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1646540596965},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1646540596965},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1646540596965},{"_id":"public/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1646540596965},{"_id":"public/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1646540596965},{"_id":"public/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1646540596965},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1646540596965},{"_id":"public/js/dark-theme.js","hash":"fca17ecc4a8866a3bbd9f14e5e2687dc981ff2e6","modified":1646540596965},{"_id":"public/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1646540596965},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1646540596965},{"_id":"public/js/mo.min.js","hash":"fc7ec6c51e67a25019e08d6dd5e71633b27e69ad","modified":1646540596965},{"_id":"public/js/valine.min.js","hash":"0acf84fea71c43aa7fa645ebeb0e5a5b58cc5e30","modified":1646540596965},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1646540596965},{"_id":"public/images/wechatpay.png","hash":"3b8195f975a57bf0f5a482d3d9f664df4eabc440","modified":1646540596965},{"_id":"public/images/alipay.png","hash":"5425e500d40af6ac2fec38a40315918590512c97","modified":1646540596965},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1646540596965},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1646540596965},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1646540596965},{"_id":"public/2022/03/04/JUC-AbstractQueuedSynchronizer/AQS-资源占用流程.png","hash":"7e7859f6e135e47b22194aa17e3dc83bd84f2f79","modified":1646540596965},{"_id":"public/2021/08/22/JUC-ForkJoin/ForkJoin.png","hash":"d2e0b54687a8ec722e42fdaa0d9ec87d0855df23","modified":1646540596965},{"_id":"public/2022/03/04/JUC-AbstractQueuedSynchronizer/AQS-接口.png","hash":"045942daf5e0e0a332e6dd04b36decaedc15c27d","modified":1646540596965},{"_id":"public/2021/08/22/JUC-Unsafe/20191211175818692.png","hash":"ff4b7e15cc18135462f1f1641ddf8fa34b686601","modified":1646540596965},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1646540596965}],"Category":[],"Data":[],"Page":[{"date":"2022-03-01T17:32:55.000Z","type":"friend","comments":0,"_content":"","source":"friends/index.md","raw":"---\ndate: 2022-03-02 01:32:55\ntype: \"friend\"\ncomments: false\n---\n","updated":"2022-03-06T03:49:20.334Z","path":"friends/index.html","title":"","layout":"page","_id":"cl0eqk39b0000o4u59qirhwer","content":"","site":{"data":{}},"excerpt":"","more":""},{"date":"2022-02-24T16:21:14.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ndate: 2022-02-25 00:21:14\ntype: \"tags\"\ncomments: false\n---\n","updated":"2022-03-04T05:47:34.686Z","path":"tags/index.html","title":"","layout":"page","_id":"cl0eqk39h0002o4u5958a8xbb","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ArrayList & LinkedList","date":"2020-08-08T05:02:18.000Z","description":"ArrayList实现了List接口的所有方法，可以看成是“长度可调节的数组”，可以包含任何类型数据（包括null，可重复）。ArrayList大体和Vector一致，唯一区别是ArrayList非线程安全，Vector线程安全，但Vector线程安全的代价较大，推荐使用CopyOnWriteArrayList，后面文章再做记录。","_content":"\n本文记录ArrayList & LinkedList源码解析，基于JDK1.8。\n\n## ArrayList\n\nArrayList实现了List接口的所有方法，可以看成是“长度可调节的数组”，可以包含任何类型数据（包括null，可重复）。ArrayList大体和Vector一致，唯一区别是ArrayList非线程安全，Vector线程安全，但Vector线程安全的代价较大，推荐使用CopyOnWriteArrayList，后面文章再做记录。\n\n### 类结构\n\nArrayList类层级关系如下图所示：\n\n![QQ20210219-143407@2x](JAVA-ArrayList&LinkedList\\QQ20210219-143407@2x.png)\n\nArrayList额外实现了RandomAccess接口，关于RandomAccess接口的作用下面再做讨论。\n\nArrayList类主要包含如下两个成员变量：\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    transient Object[] elementData;\n    private int size;\n    ......\n}\n```\n\nelementData为Object类型数组，用于存放ArrayList数据；size表示数组元素个数（并非数组容量）。\n\nArrayList类还包含了一些常量：\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    // 数组默认初始化容量为10\n    private static final int DEFAULT_CAPACITY = 10;\n    // 表示空数组\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n    // 也是空数组，和EMPTY_ELEMENTDATA区分开\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n}\n```\n\n### 方法解析\n\n#### 知识储备\n\nArrays类的`copyOf(U[] original, int newLength, Class<? extends T[]> newType)`方法用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型为newType。\n\n1. 如果新数组的长度大于旧数组，那么多出的那部分用null填充；\n2. 如果新数组的长度小于旧数组，那么少的那部分直接截取掉。\n\n举两个例子：\n\n```java\nLong[] array1 = new Long[]{1L, 2L, 3L};\nObject[] array2 = Arrays.copyOf(array1, 5, Object[].class);\nSystem.out.println(Arrays.toString(array2)); // [1, 2, 3, null, null]\n\nObject[] array3 = Arrays.copyOf(array1, 1, Object[].class);\nSystem.out.println(Arrays.toString(array3)); // [1]\n```\n\n\n\n重载方法`copyOf(T[] original, int newLength)`用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型和旧数组一致。\n\n`copyOf`方法内部调用System类的native方法`arraycopy(Object src, int srcPos,Object dest, int destPos, int length)`：\n\n1. `src`：需要被拷贝的旧数组；\n2. `srcPos`：旧数组开始拷贝的起始位置；\n3. `dest`：拷贝目标数组；\n4. `destPos`：目标数组的起始拷贝位置；\n5. `length`：拷贝的长度。\n\n举例：\n\n```java\nLong[] array1 = new Long[]{1L, 2L, 3L};\nObject[] array2 = new Object[5];\nSystem.arraycopy(array1, 0, array2, 0, 3);\nSystem.out.println(Arrays.toString(array2)); // [1, 2, 3, null, null]\n```\n\n指定位置插入元素：\n\n```java\nLong[] array1 = new Long[]{1L, 2L, 3L, null, null, null};\nint index = 1;\nSystem.arraycopy(array1, index, array1, index + 1, 3 - index);\narray1[index] = 0L;\nSystem.out.println(Arrays.toString(array1)); // [1, 0, 2, 3, null, null]\n```\n\n#### 构造函数\n\n```java\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n```\n\n创建容量大小为initialCapacity的ArrayList，如果initialCapacity小于0，则抛出IllegalArgumentException异常；如果initialCapacity为0，则elementData为EMPTY_ELEMENTDATA。\n\n`public ArrayList()`：\n\n```java\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n```\n\n空参构造函数，elementData为DEFAULTCAPACITY_EMPTY_ELEMENTDATA。\n\n`public ArrayList(Collection<? extends E> c)`：\n\n```java\npublic ArrayList(Collection<? extends E> c) {\n    elementData = c.toArray();\n    if ((size = elementData.length) != 0) {\n        // c.toArray might (incorrectly) not return Object[] (see 6260652)\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    } else {\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n```\n\n创建一个包含指定集合c数据的ArrayList。上面为什么要多此一举使用`Arrays.copyOf(elementData, size, Object[].class)`复制一遍数组呢？这是因为在某些情况下调用集合的toArray()方法返回的类型并不是Object[].class，比如：\n\n```java\nLong[] array1 = {1L, 2L};\nList<Long> list1 = Arrays.asList(array1);\nObject[] array2 = list1.toArray();\nSystem.out.println(array2.getClass() == Object[].class); // false\n\nList<Long> list2 = new ArrayList<>();\nSystem.out.println(list2.toArray().getClass() == Object[].class); // true\n\n```\n\n#### add(E e)\n\n`add(E e)`用于尾部添加元素：\n\n```java\npublic boolean add(E e) {\n    // 用于确定数组容量\n    ensureCapacityInternal(size + 1);\n    elementData[size++] = e;\n    return true;\n}\n```\n\n假如现在我们通过如下代码创建了一个ArrayList实例：\n\n```java\nArrayList<String> list = new ArrayList<>();\nlist.add(\"hello\");\n```\n\n内部过程如下：\n\n```java\npublic boolean add(E e) {\n    // 用于确定数组容量，e=hello，size=0\n    ensureCapacityInternal(size + 1);\n    // 末尾添加元素，然后size递增1\n    elementData[size++] = e;\n    return true;\n}\n\n\nprivate void ensureCapacityInternal(int minCapacity) { // minCapacity=1,elementData={}\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        // DEFAULT_CAPACITY=10，minCapacity=1，故返回10\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\nprivate void ensureExplicitCapacity(int minCapacity) { // minCapacity=10\n    modCount++;\n\n    // minCapacity=10，elementData.length=0，所以调用grow方法扩容\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n\nprivate void grow(int minCapacity) { //minCapacity=10\n    // oldCapacity=0\n    int oldCapacity = elementData.length;\n    // newCapacity为oldCapacity的1.5倍，这里为0\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    // newCapacity=0，minCapacity=10，所以该条件成立\n    if (newCapacity - minCapacity < 0)\n        // newCapacity=10\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // 复制到新数组，数组容量为10\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    // MAX_ARRAY_SIZE常量值为Integer.MAX_VALUE - 8，通过\n    // 这段逻辑我们可以知道，ArrayList最大容量为Integer.MAX_VALUE\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n\n通过上面源码分析我们可以知道：\n\n1. 任何一个空的ArrayList在添加第一个元素时，内部数组容量将被扩容为10；\n2. 扩容时，newCapacity为oldCapacity的1.5倍；\n3. 数组容量最大为Integer.MAX_VALUE；\n4. 尾部添加元素不用移动任何元素，所以速度快。\n\n#### add(int index, E element)\n\n`add(int index, E element)`用于在指定位置添加元素：\n\n```java\npublic void add(int index, E element) {\n    // 下标检查\n    rangeCheckForAdd(index);\n    // 确定数组容量，和上面add(E e)方法介绍的一致\n    ensureCapacityInternal(size + 1);\n    // 将原来index后面的所有元素往后面移动一个位置\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    // index处放入新元素\n    elementData[index] = element;\n    // size递增\n    size++;\n}\n\nprivate void rangeCheckForAdd(int index) {\n    // 下标比size大或者下标小于0，都会抛出下标越界异常\n    if (index > size || index < 0)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n```\n\n这里涉及到元素移动，所以速度较慢。\n\n#### get(int index)\n\n`get(int index)`获取指定位置元素：\n\n```java\npublic E get(int index) {\n    // 下标合法性检查\n    rangeCheck(index);\n    // 直接返回数组指定位置元素\n    return elementData(index);\n}\n\nE elementData(int index) {\n    return (E) elementData[index];\n}\n```\n\n`get`方法直接返回数组指定下标元素，速度非常快。\n\n#### set(int index, E element)\n\n`set(int index, E element)`设置指定位置元素为指定值：\n\n```java\npublic E set(int index, E element) {\n    // 下标合法性检查\n    rangeCheck(index);\n    // 根据下标获取旧值\n    E oldValue = elementData(index);\n    // 设置新值\n    elementData[index] = element;\n    // 返回旧值\n    return oldValue;\n}\n```\n\n`set`方法不涉及元素移动和遍历，所以速度快。\n\n#### remove(int index)\n\n`remove(int index)`删除指定位置元素：\n\n```java\npublic E remove(int index) {\n    rangeCheck(index);\n\n    modCount++;\n    // 获取指定位置元素（需要被删除的元素）\n    E oldValue = elementData(index);\n\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        // 直接将index后面的元素往前移动一位，覆盖index处的元素\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n    // 返回被删除的元\n    return oldValue;\n}\n```\n\n上述方法涉及到元素移动，所以效率也不高。\n\n#### remove(Object o)\n\n`remove(Object o)`删除指定元素：\n\n```java\n// 遍历数组，找到第一个目标元素，然后删除\npublic boolean remove(Object o) {\n    if (o == null) {\n        for (int index = 0; index < size; index++)\n            if (elementData[index] == null) {\n                fastRemove(index);\n                return true;\n            }\n    } else {\n        for (int index = 0; index < size; index++)\n            if (o.equals(elementData[index])) {\n                fastRemove(index);\n                return true;\n            }\n    }\n    return false;\n}\n// 逻辑和remove一致，都是将index后面的元素往前移动一位，覆盖index处的元素\nprivate void fastRemove(int index) {\n    modCount++;\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n}\n```\n\n方法涉及到数组遍历和元素移动，效率也不高。\n\n#### trimToSize()\n\n`trimToSize()`源码：\n\n```\npublic void trimToSize() {\n    modCount++;\n    if (size < elementData.length) {\n        elementData = (size == 0)\n          ? EMPTY_ELEMENTDATA\n          : Arrays.copyOf(elementData, size);\n    }\n}\n```\n\n该方法用于将数组容量调整为实际元素个数大小，当一个ArrayList元素个数不会发生改变时，可以调用该方法减少内存占用。\n\n> 其他方法可以自己阅读ArrayList源码，此外在涉及增删改的方法里，我们都看到了modCount++操作，和之前介绍HashMap源码时一致，用于快速失败。\n\n## LinkedList\n\n### 类结构\n\nLinkedList底层采用双向链表结构存储数据，允许重复数据和null值，长度没有限制：\n\n![QQ20210220-112151@2x](JAVA-ArrayList&LinkedList\\QQ20210220-112151@2x.png)\n\n每个节点用内部类Node表示：\n\n```java\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\nNode节点包含item（存储数据），next（后继节点）和prev（前继节点）。数组内存地址必须连续，而链表就没有这个限制了，Node可以分布于各个内存地址，它们之间的关系通过prev和next维护。\n\nLinkedList类关系图：\n\n![QQ20210220-112546@2x](JAVA-ArrayList&LinkedList\\QQ20210220-112546@2x.png)\n\n可以看到LinkedList类并没有实现RandomAccess接口，额外实现了Deque接口，所以包含一些队列方法。\n\nLinkedList包含如下成员变量：\n\n```java\n// 元素个数，默认为0\ntransient int size = 0;\n\n// 表示第一个节点，第一个节点必须满足(first == null && last == null) || (first.prev == null && first.item != null)\ntransient Node<E> first;\n\n// 表示最后一个节点，最后一个节点必须满足(first == null && last == null) || (last.next == null && last.item != null)\ntransient Node<E> last;\n```\n\n### 方法解析\n\n#### 构造函数\n\n`LinkedList()`：\n\n```java\npublic LinkedList() {\n}\n```\n\n空参构造函数，默认size为0，每次添加新元素都要创建Node节点。\n\n`LinkedList(Collection<? extends E> c)`：\n\n```java\npublic LinkedList(Collection<? extends E> c) {\n    this();\n    addAll(c);\n}\n\npublic boolean addAll(Collection<? extends E> c) {\n    return addAll(size, c);\n}\n\npublic boolean addAll(int index, Collection<? extends E> c) {\n    checkPositionIndex(index);\n\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    if (numNew == 0)\n        return false;\n\n    Node<E> pred, succ;\n    if (index == size) {\n        succ = null;\n        pred = last;\n    } else {\n        succ = node(index);\n        pred = succ.prev;\n    }\n    // 循环创建节点，设置prev，next指向\n    for (Object o : a) {\n        @SuppressWarnings(\"unchecked\") E e = (E) o;\n        Node<E> newNode = new Node<>(pred, e, null);\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        pred = newNode;\n    }\n\n    if (succ == null) {\n        last = pred;\n    } else {\n        pred.next = succ;\n        succ.prev = pred;\n    }\n\n    size += numNew;\n    modCount++;\n    return true;\n}\n```\n\n该构造函数用于创建LinkedList，并往里添加指定集合元素。\n\n#### add(int index, E element)\n\n`add(int index, E element)`指定下标插入元素：\n\n```java\npublic void add(int index, E element) {\n    // 下标合法性检查\n    checkPositionIndex(index);\n\n    if (index == size)\n        // 如果插入下标等于size，说明是在尾部插入，执行尾部插入操作\n        linkLast(element);\n    else\n        // 如果不是尾插入，则在指定下标节点前插入\n        linkBefore(element, node(index));\n}\n\nprivate void checkPositionIndex(int index) {\n    if (!isPositionIndex(index))\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n\nprivate boolean isPositionIndex(int index) {\n    return index >= 0 && index <= size;\n}\n\nvoid linkLast(E e) {\n    // 获取最后一个节点\n    final Node<E> l = last;\n    // 创建一个新节点，prev为原链表最后一个节点，next为null\n    final Node<E> newNode = new Node<>(l, e, null);\n    // 更新last为新节点\n    last = newNode;\n    if (l == null)\n        // 如果原链表最后一个节点为null，说明原链表没有节点，将新节点赋给first\n        first = newNode;\n    else\n        // 否则更新原链表最后一个节点的next为新节点\n        l.next = newNode;\n    // size递增\n    size++;\n    // 模数递增，用于快速失败\n    modCount++;\n}\n\nvoid linkBefore(E e, Node<E> succ) {\n    // succ为原链表指定index位置的节点，获取其prev节点\n    final Node<E> pred = succ.prev;\n    // 创建新节点，prev为原链表指定index位置的节点的prev节点，next为原链表指定index位置的节点\n    final Node<E> newNode = new Node<>(pred, e, succ);\n    // 将原链表指定index位置的节点的prev更新为新节点\n    succ.prev = newNode;\n    if (pred == null)\n        // 如果链表指定index位置的节点的prev为null，说明原链表没有节点，将新节点赋给first\n        first = newNode;\n    else\n        // 否则更新原链表指定index位置的节点的prev的next节点为新节点\n        pred.next = newNode;\n    // size递增\n    size++;\n    // 模数递增，用于快速失败\n    modCount++;\n}\n\n// 采用二分法遍历每个Node节点，直到找到index位置的节点\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\n代码较为简单，无非就是设置节点的prev和next关系。可以看到，除了头插和尾插外，在链表别的位置插入新节点，涉及到节点遍历操作，所以我们常说的链表插入速度快，指的是插入节点改变前后节点的引用过程很快。\n\n#### get(int index)\n\n`get(int index)`获取指定下标元素：\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\n\n// 采用二分法遍历每个Node节点，直到找到index位置的节点\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\n代码较为简单，就是通过node函数查找指定index下标Node，然后获取其item属性值，节点查找需要遍历。\n\n#### set(int index, E element)\n\n`set(int index, E element)`设置指定下标节点的item为指定值：\n\n```java\npublic E set(int index, E element) {\n    // 下标合法性检查\n    checkElementIndex(index);\n    // 获取index下标节点\n    Node<E> x = node(index);\n    // 获取旧值\n    E oldVal = x.item;\n    // 设置新值\n    x.item = element;\n    // 返回旧值\n    return oldVal;\n}\n\n// 采用二分法遍历每个Node节点，直到找到index位置的节点\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\n可以看到，set方法也需要通过遍历查找目标节点。\n\n#### remove(int index)\n\n`remove(int index)`删除指定下标节点：\n\n```java\npublic E remove(int index) {\n    checkElementIndex(index);\n    return unlink(node(index));\n}\n\nE unlink(Node<E> x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n`remove(int index)`通过node方法找到需要删除的节点，然后调用unlink方法改变删除节点的prev和next节点的前继和后继节点。\n\n> 剩下的方法可以自己阅读源码。\n\n## RandomAccess接口\n\nRandomAccess接口是一个空接口，不包含任何方法，只是作为一个标识：\n\n```java\npackage java.util;\n\npublic interface RandomAccess {\n}\n```\n\n实现该接口的类说明其支持快速随机访问，比如ArrayList实现了该接口，说明ArrayList支持快速随机访问。所谓快速随机访问指的是通过元素的下标即可快速获取元素对象，无需遍历，而LinkedList则没有这个特性，元素获取必须遍历链表。\n\n在Collections类的`binarySearch(List<? extends Comparable<? super T>> list, T key)`方法中，可以看到RandomAccess的应用：\n\n```java\npublic static <T>\nint binarySearch(List<? extends Comparable<? super T>> list, T key) {\n    if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key);\n    else\n        return Collections.iteratorBinarySearch(list, key);\n}\n```\n\n当list实现了RandomAccess接口时，调用indexedBinarySearch方法，否则调用iteratorBinarySearch。所以当我们遍历集合时，如果集合实现了RandomAccess接口，优先选择普通for循环，其次foreach；遍历未实现RandomAccess的接口，优先选择iterator遍历。\n\n","source":"_posts/JAVA-ArrayList&LinkedList.md","raw":"---\ntitle: ArrayList & LinkedList\ndate: 2020-08-08 13:02:18\ntags:\n- Java\ndescription: ArrayList实现了List接口的所有方法，可以看成是“长度可调节的数组”，可以包含任何类型数据（包括null，可重复）。ArrayList大体和Vector一致，唯一区别是ArrayList非线程安全，Vector线程安全，但Vector线程安全的代价较大，推荐使用CopyOnWriteArrayList，后面文章再做记录。\n---\n\n本文记录ArrayList & LinkedList源码解析，基于JDK1.8。\n\n## ArrayList\n\nArrayList实现了List接口的所有方法，可以看成是“长度可调节的数组”，可以包含任何类型数据（包括null，可重复）。ArrayList大体和Vector一致，唯一区别是ArrayList非线程安全，Vector线程安全，但Vector线程安全的代价较大，推荐使用CopyOnWriteArrayList，后面文章再做记录。\n\n### 类结构\n\nArrayList类层级关系如下图所示：\n\n![QQ20210219-143407@2x](JAVA-ArrayList&LinkedList\\QQ20210219-143407@2x.png)\n\nArrayList额外实现了RandomAccess接口，关于RandomAccess接口的作用下面再做讨论。\n\nArrayList类主要包含如下两个成员变量：\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    transient Object[] elementData;\n    private int size;\n    ......\n}\n```\n\nelementData为Object类型数组，用于存放ArrayList数据；size表示数组元素个数（并非数组容量）。\n\nArrayList类还包含了一些常量：\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{\n    // 数组默认初始化容量为10\n    private static final int DEFAULT_CAPACITY = 10;\n    // 表示空数组\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n    // 也是空数组，和EMPTY_ELEMENTDATA区分开\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n}\n```\n\n### 方法解析\n\n#### 知识储备\n\nArrays类的`copyOf(U[] original, int newLength, Class<? extends T[]> newType)`方法用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型为newType。\n\n1. 如果新数组的长度大于旧数组，那么多出的那部分用null填充；\n2. 如果新数组的长度小于旧数组，那么少的那部分直接截取掉。\n\n举两个例子：\n\n```java\nLong[] array1 = new Long[]{1L, 2L, 3L};\nObject[] array2 = Arrays.copyOf(array1, 5, Object[].class);\nSystem.out.println(Arrays.toString(array2)); // [1, 2, 3, null, null]\n\nObject[] array3 = Arrays.copyOf(array1, 1, Object[].class);\nSystem.out.println(Arrays.toString(array3)); // [1]\n```\n\n\n\n重载方法`copyOf(T[] original, int newLength)`用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型和旧数组一致。\n\n`copyOf`方法内部调用System类的native方法`arraycopy(Object src, int srcPos,Object dest, int destPos, int length)`：\n\n1. `src`：需要被拷贝的旧数组；\n2. `srcPos`：旧数组开始拷贝的起始位置；\n3. `dest`：拷贝目标数组；\n4. `destPos`：目标数组的起始拷贝位置；\n5. `length`：拷贝的长度。\n\n举例：\n\n```java\nLong[] array1 = new Long[]{1L, 2L, 3L};\nObject[] array2 = new Object[5];\nSystem.arraycopy(array1, 0, array2, 0, 3);\nSystem.out.println(Arrays.toString(array2)); // [1, 2, 3, null, null]\n```\n\n指定位置插入元素：\n\n```java\nLong[] array1 = new Long[]{1L, 2L, 3L, null, null, null};\nint index = 1;\nSystem.arraycopy(array1, index, array1, index + 1, 3 - index);\narray1[index] = 0L;\nSystem.out.println(Arrays.toString(array1)); // [1, 0, 2, 3, null, null]\n```\n\n#### 构造函数\n\n```java\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n```\n\n创建容量大小为initialCapacity的ArrayList，如果initialCapacity小于0，则抛出IllegalArgumentException异常；如果initialCapacity为0，则elementData为EMPTY_ELEMENTDATA。\n\n`public ArrayList()`：\n\n```java\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n```\n\n空参构造函数，elementData为DEFAULTCAPACITY_EMPTY_ELEMENTDATA。\n\n`public ArrayList(Collection<? extends E> c)`：\n\n```java\npublic ArrayList(Collection<? extends E> c) {\n    elementData = c.toArray();\n    if ((size = elementData.length) != 0) {\n        // c.toArray might (incorrectly) not return Object[] (see 6260652)\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    } else {\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n```\n\n创建一个包含指定集合c数据的ArrayList。上面为什么要多此一举使用`Arrays.copyOf(elementData, size, Object[].class)`复制一遍数组呢？这是因为在某些情况下调用集合的toArray()方法返回的类型并不是Object[].class，比如：\n\n```java\nLong[] array1 = {1L, 2L};\nList<Long> list1 = Arrays.asList(array1);\nObject[] array2 = list1.toArray();\nSystem.out.println(array2.getClass() == Object[].class); // false\n\nList<Long> list2 = new ArrayList<>();\nSystem.out.println(list2.toArray().getClass() == Object[].class); // true\n\n```\n\n#### add(E e)\n\n`add(E e)`用于尾部添加元素：\n\n```java\npublic boolean add(E e) {\n    // 用于确定数组容量\n    ensureCapacityInternal(size + 1);\n    elementData[size++] = e;\n    return true;\n}\n```\n\n假如现在我们通过如下代码创建了一个ArrayList实例：\n\n```java\nArrayList<String> list = new ArrayList<>();\nlist.add(\"hello\");\n```\n\n内部过程如下：\n\n```java\npublic boolean add(E e) {\n    // 用于确定数组容量，e=hello，size=0\n    ensureCapacityInternal(size + 1);\n    // 末尾添加元素，然后size递增1\n    elementData[size++] = e;\n    return true;\n}\n\n\nprivate void ensureCapacityInternal(int minCapacity) { // minCapacity=1,elementData={}\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        // DEFAULT_CAPACITY=10，minCapacity=1，故返回10\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\nprivate void ensureExplicitCapacity(int minCapacity) { // minCapacity=10\n    modCount++;\n\n    // minCapacity=10，elementData.length=0，所以调用grow方法扩容\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n\nprivate void grow(int minCapacity) { //minCapacity=10\n    // oldCapacity=0\n    int oldCapacity = elementData.length;\n    // newCapacity为oldCapacity的1.5倍，这里为0\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    // newCapacity=0，minCapacity=10，所以该条件成立\n    if (newCapacity - minCapacity < 0)\n        // newCapacity=10\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // 复制到新数组，数组容量为10\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    // MAX_ARRAY_SIZE常量值为Integer.MAX_VALUE - 8，通过\n    // 这段逻辑我们可以知道，ArrayList最大容量为Integer.MAX_VALUE\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n```\n\n通过上面源码分析我们可以知道：\n\n1. 任何一个空的ArrayList在添加第一个元素时，内部数组容量将被扩容为10；\n2. 扩容时，newCapacity为oldCapacity的1.5倍；\n3. 数组容量最大为Integer.MAX_VALUE；\n4. 尾部添加元素不用移动任何元素，所以速度快。\n\n#### add(int index, E element)\n\n`add(int index, E element)`用于在指定位置添加元素：\n\n```java\npublic void add(int index, E element) {\n    // 下标检查\n    rangeCheckForAdd(index);\n    // 确定数组容量，和上面add(E e)方法介绍的一致\n    ensureCapacityInternal(size + 1);\n    // 将原来index后面的所有元素往后面移动一个位置\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    // index处放入新元素\n    elementData[index] = element;\n    // size递增\n    size++;\n}\n\nprivate void rangeCheckForAdd(int index) {\n    // 下标比size大或者下标小于0，都会抛出下标越界异常\n    if (index > size || index < 0)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n```\n\n这里涉及到元素移动，所以速度较慢。\n\n#### get(int index)\n\n`get(int index)`获取指定位置元素：\n\n```java\npublic E get(int index) {\n    // 下标合法性检查\n    rangeCheck(index);\n    // 直接返回数组指定位置元素\n    return elementData(index);\n}\n\nE elementData(int index) {\n    return (E) elementData[index];\n}\n```\n\n`get`方法直接返回数组指定下标元素，速度非常快。\n\n#### set(int index, E element)\n\n`set(int index, E element)`设置指定位置元素为指定值：\n\n```java\npublic E set(int index, E element) {\n    // 下标合法性检查\n    rangeCheck(index);\n    // 根据下标获取旧值\n    E oldValue = elementData(index);\n    // 设置新值\n    elementData[index] = element;\n    // 返回旧值\n    return oldValue;\n}\n```\n\n`set`方法不涉及元素移动和遍历，所以速度快。\n\n#### remove(int index)\n\n`remove(int index)`删除指定位置元素：\n\n```java\npublic E remove(int index) {\n    rangeCheck(index);\n\n    modCount++;\n    // 获取指定位置元素（需要被删除的元素）\n    E oldValue = elementData(index);\n\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        // 直接将index后面的元素往前移动一位，覆盖index处的元素\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n    // 返回被删除的元\n    return oldValue;\n}\n```\n\n上述方法涉及到元素移动，所以效率也不高。\n\n#### remove(Object o)\n\n`remove(Object o)`删除指定元素：\n\n```java\n// 遍历数组，找到第一个目标元素，然后删除\npublic boolean remove(Object o) {\n    if (o == null) {\n        for (int index = 0; index < size; index++)\n            if (elementData[index] == null) {\n                fastRemove(index);\n                return true;\n            }\n    } else {\n        for (int index = 0; index < size; index++)\n            if (o.equals(elementData[index])) {\n                fastRemove(index);\n                return true;\n            }\n    }\n    return false;\n}\n// 逻辑和remove一致，都是将index后面的元素往前移动一位，覆盖index处的元素\nprivate void fastRemove(int index) {\n    modCount++;\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n}\n```\n\n方法涉及到数组遍历和元素移动，效率也不高。\n\n#### trimToSize()\n\n`trimToSize()`源码：\n\n```\npublic void trimToSize() {\n    modCount++;\n    if (size < elementData.length) {\n        elementData = (size == 0)\n          ? EMPTY_ELEMENTDATA\n          : Arrays.copyOf(elementData, size);\n    }\n}\n```\n\n该方法用于将数组容量调整为实际元素个数大小，当一个ArrayList元素个数不会发生改变时，可以调用该方法减少内存占用。\n\n> 其他方法可以自己阅读ArrayList源码，此外在涉及增删改的方法里，我们都看到了modCount++操作，和之前介绍HashMap源码时一致，用于快速失败。\n\n## LinkedList\n\n### 类结构\n\nLinkedList底层采用双向链表结构存储数据，允许重复数据和null值，长度没有限制：\n\n![QQ20210220-112151@2x](JAVA-ArrayList&LinkedList\\QQ20210220-112151@2x.png)\n\n每个节点用内部类Node表示：\n\n```java\nprivate static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\nNode节点包含item（存储数据），next（后继节点）和prev（前继节点）。数组内存地址必须连续，而链表就没有这个限制了，Node可以分布于各个内存地址，它们之间的关系通过prev和next维护。\n\nLinkedList类关系图：\n\n![QQ20210220-112546@2x](JAVA-ArrayList&LinkedList\\QQ20210220-112546@2x.png)\n\n可以看到LinkedList类并没有实现RandomAccess接口，额外实现了Deque接口，所以包含一些队列方法。\n\nLinkedList包含如下成员变量：\n\n```java\n// 元素个数，默认为0\ntransient int size = 0;\n\n// 表示第一个节点，第一个节点必须满足(first == null && last == null) || (first.prev == null && first.item != null)\ntransient Node<E> first;\n\n// 表示最后一个节点，最后一个节点必须满足(first == null && last == null) || (last.next == null && last.item != null)\ntransient Node<E> last;\n```\n\n### 方法解析\n\n#### 构造函数\n\n`LinkedList()`：\n\n```java\npublic LinkedList() {\n}\n```\n\n空参构造函数，默认size为0，每次添加新元素都要创建Node节点。\n\n`LinkedList(Collection<? extends E> c)`：\n\n```java\npublic LinkedList(Collection<? extends E> c) {\n    this();\n    addAll(c);\n}\n\npublic boolean addAll(Collection<? extends E> c) {\n    return addAll(size, c);\n}\n\npublic boolean addAll(int index, Collection<? extends E> c) {\n    checkPositionIndex(index);\n\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    if (numNew == 0)\n        return false;\n\n    Node<E> pred, succ;\n    if (index == size) {\n        succ = null;\n        pred = last;\n    } else {\n        succ = node(index);\n        pred = succ.prev;\n    }\n    // 循环创建节点，设置prev，next指向\n    for (Object o : a) {\n        @SuppressWarnings(\"unchecked\") E e = (E) o;\n        Node<E> newNode = new Node<>(pred, e, null);\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        pred = newNode;\n    }\n\n    if (succ == null) {\n        last = pred;\n    } else {\n        pred.next = succ;\n        succ.prev = pred;\n    }\n\n    size += numNew;\n    modCount++;\n    return true;\n}\n```\n\n该构造函数用于创建LinkedList，并往里添加指定集合元素。\n\n#### add(int index, E element)\n\n`add(int index, E element)`指定下标插入元素：\n\n```java\npublic void add(int index, E element) {\n    // 下标合法性检查\n    checkPositionIndex(index);\n\n    if (index == size)\n        // 如果插入下标等于size，说明是在尾部插入，执行尾部插入操作\n        linkLast(element);\n    else\n        // 如果不是尾插入，则在指定下标节点前插入\n        linkBefore(element, node(index));\n}\n\nprivate void checkPositionIndex(int index) {\n    if (!isPositionIndex(index))\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n\nprivate boolean isPositionIndex(int index) {\n    return index >= 0 && index <= size;\n}\n\nvoid linkLast(E e) {\n    // 获取最后一个节点\n    final Node<E> l = last;\n    // 创建一个新节点，prev为原链表最后一个节点，next为null\n    final Node<E> newNode = new Node<>(l, e, null);\n    // 更新last为新节点\n    last = newNode;\n    if (l == null)\n        // 如果原链表最后一个节点为null，说明原链表没有节点，将新节点赋给first\n        first = newNode;\n    else\n        // 否则更新原链表最后一个节点的next为新节点\n        l.next = newNode;\n    // size递增\n    size++;\n    // 模数递增，用于快速失败\n    modCount++;\n}\n\nvoid linkBefore(E e, Node<E> succ) {\n    // succ为原链表指定index位置的节点，获取其prev节点\n    final Node<E> pred = succ.prev;\n    // 创建新节点，prev为原链表指定index位置的节点的prev节点，next为原链表指定index位置的节点\n    final Node<E> newNode = new Node<>(pred, e, succ);\n    // 将原链表指定index位置的节点的prev更新为新节点\n    succ.prev = newNode;\n    if (pred == null)\n        // 如果链表指定index位置的节点的prev为null，说明原链表没有节点，将新节点赋给first\n        first = newNode;\n    else\n        // 否则更新原链表指定index位置的节点的prev的next节点为新节点\n        pred.next = newNode;\n    // size递增\n    size++;\n    // 模数递增，用于快速失败\n    modCount++;\n}\n\n// 采用二分法遍历每个Node节点，直到找到index位置的节点\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\n代码较为简单，无非就是设置节点的prev和next关系。可以看到，除了头插和尾插外，在链表别的位置插入新节点，涉及到节点遍历操作，所以我们常说的链表插入速度快，指的是插入节点改变前后节点的引用过程很快。\n\n#### get(int index)\n\n`get(int index)`获取指定下标元素：\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\n\n// 采用二分法遍历每个Node节点，直到找到index位置的节点\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\n代码较为简单，就是通过node函数查找指定index下标Node，然后获取其item属性值，节点查找需要遍历。\n\n#### set(int index, E element)\n\n`set(int index, E element)`设置指定下标节点的item为指定值：\n\n```java\npublic E set(int index, E element) {\n    // 下标合法性检查\n    checkElementIndex(index);\n    // 获取index下标节点\n    Node<E> x = node(index);\n    // 获取旧值\n    E oldVal = x.item;\n    // 设置新值\n    x.item = element;\n    // 返回旧值\n    return oldVal;\n}\n\n// 采用二分法遍历每个Node节点，直到找到index位置的节点\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\n可以看到，set方法也需要通过遍历查找目标节点。\n\n#### remove(int index)\n\n`remove(int index)`删除指定下标节点：\n\n```java\npublic E remove(int index) {\n    checkElementIndex(index);\n    return unlink(node(index));\n}\n\nE unlink(Node<E> x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n`remove(int index)`通过node方法找到需要删除的节点，然后调用unlink方法改变删除节点的prev和next节点的前继和后继节点。\n\n> 剩下的方法可以自己阅读源码。\n\n## RandomAccess接口\n\nRandomAccess接口是一个空接口，不包含任何方法，只是作为一个标识：\n\n```java\npackage java.util;\n\npublic interface RandomAccess {\n}\n```\n\n实现该接口的类说明其支持快速随机访问，比如ArrayList实现了该接口，说明ArrayList支持快速随机访问。所谓快速随机访问指的是通过元素的下标即可快速获取元素对象，无需遍历，而LinkedList则没有这个特性，元素获取必须遍历链表。\n\n在Collections类的`binarySearch(List<? extends Comparable<? super T>> list, T key)`方法中，可以看到RandomAccess的应用：\n\n```java\npublic static <T>\nint binarySearch(List<? extends Comparable<? super T>> list, T key) {\n    if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key);\n    else\n        return Collections.iteratorBinarySearch(list, key);\n}\n```\n\n当list实现了RandomAccess接口时，调用indexedBinarySearch方法，否则调用iteratorBinarySearch。所以当我们遍历集合时，如果集合实现了RandomAccess接口，优先选择普通for循环，其次foreach；遍历未实现RandomAccess的接口，优先选择iterator遍历。\n\n","slug":"JAVA-ArrayList&LinkedList","published":1,"updated":"2022-03-05T12:33:54.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0eqk39e0001o4u50zpm8vio","content":"<p>本文记录ArrayList &amp; LinkedList源码解析，基于JDK1.8。</p>\n<h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h2><p>ArrayList实现了List接口的所有方法，可以看成是“长度可调节的数组”，可以包含任何类型数据（包括null，可重复）。ArrayList大体和Vector一致，唯一区别是ArrayList非线程安全，Vector线程安全，但Vector线程安全的代价较大，推荐使用CopyOnWriteArrayList，后面文章再做记录。</p>\n<h3 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h3><p>ArrayList类层级关系如下图所示：</p>\n<p><img src=\"/JAVA-ArrayList&LinkedList%5CQQ20210219-143407@2x.png\" alt=\"QQ20210219-143407@2x\"></p>\n<p>ArrayList额外实现了RandomAccess接口，关于RandomAccess接口的作用下面再做讨论。</p>\n<p>ArrayList类主要包含如下两个成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractList</span>&lt;E&gt;</span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>elementData为Object类型数组，用于存放ArrayList数据；size表示数组元素个数（并非数组容量）。</p>\n<p>ArrayList类还包含了一些常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractList</span>&lt;E&gt;</span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 数组默认初始化容量为10</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 表示空数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 也是空数组，和EMPTY_ELEMENTDATA区分开</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法解析\"><a href=\"#方法解析\" class=\"headerlink\" title=\"方法解析\"></a>方法解析</h3><h4 id=\"知识储备\"><a href=\"#知识储备\" class=\"headerlink\" title=\"知识储备\"></a>知识储备</h4><p>Arrays类的<code>copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType)</code>方法用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型为newType。</p>\n<ol>\n<li>如果新数组的长度大于旧数组，那么多出的那部分用null填充；</li>\n<li>如果新数组的长度小于旧数组，那么少的那部分直接截取掉。</li>\n</ol>\n<p>举两个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long[] array1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Long</span>[]&#123;<span class=\"number\">1L</span>, <span class=\"number\">2L</span>, <span class=\"number\">3L</span>&#125;;</span><br><span class=\"line\">Object[] array2 = Arrays.copyOf(array1, <span class=\"number\">5</span>, Object[].class);</span><br><span class=\"line\">System.out.println(Arrays.toString(array2)); <span class=\"comment\">// [1, 2, 3, null, null]</span></span><br><span class=\"line\"></span><br><span class=\"line\">Object[] array3 = Arrays.copyOf(array1, <span class=\"number\">1</span>, Object[].class);</span><br><span class=\"line\">System.out.println(Arrays.toString(array3)); <span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>重载方法<code>copyOf(T[] original, int newLength)</code>用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型和旧数组一致。</p>\n<p><code>copyOf</code>方法内部调用System类的native方法<code>arraycopy(Object src, int srcPos,Object dest, int destPos, int length)</code>：</p>\n<ol>\n<li><code>src</code>：需要被拷贝的旧数组；</li>\n<li><code>srcPos</code>：旧数组开始拷贝的起始位置；</li>\n<li><code>dest</code>：拷贝目标数组；</li>\n<li><code>destPos</code>：目标数组的起始拷贝位置；</li>\n<li><code>length</code>：拷贝的长度。</li>\n</ol>\n<p>举例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long[] array1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Long</span>[]&#123;<span class=\"number\">1L</span>, <span class=\"number\">2L</span>, <span class=\"number\">3L</span>&#125;;</span><br><span class=\"line\">Object[] array2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\">System.arraycopy(array1, <span class=\"number\">0</span>, array2, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">System.out.println(Arrays.toString(array2)); <span class=\"comment\">// [1, 2, 3, null, null]</span></span><br></pre></td></tr></table></figure>\n\n<p>指定位置插入元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long[] array1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Long</span>[]&#123;<span class=\"number\">1L</span>, <span class=\"number\">2L</span>, <span class=\"number\">3L</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">System.arraycopy(array1, index, array1, index + <span class=\"number\">1</span>, <span class=\"number\">3</span> - index);</span><br><span class=\"line\">array1[index] = <span class=\"number\">0L</span>;</span><br><span class=\"line\">System.out.println(Arrays.toString(array1)); <span class=\"comment\">// [1, 0, 2, 3, null, null]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[initialCapacity];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Illegal Capacity: &quot;</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建容量大小为initialCapacity的ArrayList，如果initialCapacity小于0，则抛出IllegalArgumentException异常；如果initialCapacity为0，则elementData为EMPTY_ELEMENTDATA。</p>\n<p><code>public ArrayList()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>空参构造函数，elementData为DEFAULTCAPACITY_EMPTY_ELEMENTDATA。</p>\n<p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个包含指定集合c数据的ArrayList。上面为什么要多此一举使用<code>Arrays.copyOf(elementData, size, Object[].class)</code>复制一遍数组呢？这是因为在某些情况下调用集合的toArray()方法返回的类型并不是Object[].class，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long[] array1 = &#123;<span class=\"number\">1L</span>, <span class=\"number\">2L</span>&#125;;</span><br><span class=\"line\">List&lt;Long&gt; list1 = Arrays.asList(array1);</span><br><span class=\"line\">Object[] array2 = list1.toArray();</span><br><span class=\"line\">System.out.println(array2.getClass() == Object[].class); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Long&gt; list2 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">System.out.println(list2.toArray().getClass() == Object[].class); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"add-E-e\"><a href=\"#add-E-e\" class=\"headerlink\" title=\"add(E e)\"></a>add(E e)</h4><p><code>add(E e)</code>用于尾部添加元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用于确定数组容量</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假如现在我们通过如下代码创建了一个ArrayList实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>内部过程如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用于确定数组容量，e=hello，size=0</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 末尾添加元素，然后size递增1</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123; <span class=\"comment\">// minCapacity=1,elementData=&#123;&#125;</span></span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// DEFAULT_CAPACITY=10，minCapacity=1，故返回10</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123; <span class=\"comment\">// minCapacity=10</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// minCapacity=10，elementData.length=0，所以调用grow方法扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123; <span class=\"comment\">//minCapacity=10</span></span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity=0</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// newCapacity为oldCapacity的1.5倍，这里为0</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// newCapacity=0，minCapacity=10，所以该条件成立</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// newCapacity=10</span></span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// 复制到新数组，数组容量为10</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hugeCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutOfMemoryError</span>();</span><br><span class=\"line\">    <span class=\"comment\">// MAX_ARRAY_SIZE常量值为Integer.MAX_VALUE - 8，通过</span></span><br><span class=\"line\">    <span class=\"comment\">// 这段逻辑我们可以知道，ArrayList最大容量为Integer.MAX_VALUE</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过上面源码分析我们可以知道：</p>\n<ol>\n<li>任何一个空的ArrayList在添加第一个元素时，内部数组容量将被扩容为10；</li>\n<li>扩容时，newCapacity为oldCapacity的1.5倍；</li>\n<li>数组容量最大为Integer.MAX_VALUE；</li>\n<li>尾部添加元素不用移动任何元素，所以速度快。</li>\n</ol>\n<h4 id=\"add-int-index-E-element\"><a href=\"#add-int-index-E-element\" class=\"headerlink\" title=\"add(int index, E element)\"></a>add(int index, E element)</h4><p><code>add(int index, E element)</code>用于在指定位置添加元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标检查</span></span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\">    <span class=\"comment\">// 确定数组容量，和上面add(E e)方法介绍的一致</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 将原来index后面的所有元素往后面移动一个位置</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\">    <span class=\"comment\">// index处放入新元素</span></span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    <span class=\"comment\">// size递增</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标比size大或者下标小于0，都会抛出下标越界异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里涉及到元素移动，所以速度较慢。</p>\n<h4 id=\"get-int-index\"><a href=\"#get-int-index\" class=\"headerlink\" title=\"get(int index)\"></a>get(int index)</h4><p><code>get(int index)</code>获取指定位置元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标合法性检查</span></span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    <span class=\"comment\">// 直接返回数组指定位置元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elementData(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">E <span class=\"title function_\">elementData</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>get</code>方法直接返回数组指定下标元素，速度非常快。</p>\n<h4 id=\"set-int-index-E-element\"><a href=\"#set-int-index-E-element\" class=\"headerlink\" title=\"set(int index, E element)\"></a>set(int index, E element)</h4><p><code>set(int index, E element)</code>设置指定位置元素为指定值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">set</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标合法性检查</span></span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    <span class=\"comment\">// 根据下标获取旧值</span></span><br><span class=\"line\">    <span class=\"type\">E</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> elementData(index);</span><br><span class=\"line\">    <span class=\"comment\">// 设置新值</span></span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>set</code>方法不涉及元素移动和遍历，所以速度快。</p>\n<h4 id=\"remove-int-index\"><a href=\"#remove-int-index\" class=\"headerlink\" title=\"remove(int index)\"></a>remove(int index)</h4><p><code>remove(int index)</code>删除指定位置元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">remove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">// 获取指定位置元素（需要被删除的元素）</span></span><br><span class=\"line\">    <span class=\"type\">E</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 直接将index后面的元素往前移动一位，覆盖index处的元素</span></span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"literal\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    <span class=\"comment\">// 返回被删除的元</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述方法涉及到元素移动，所以效率也不高。</p>\n<h4 id=\"remove-Object-o\"><a href=\"#remove-Object-o\" class=\"headerlink\" title=\"remove(Object o)\"></a>remove(Object o)</h4><p><code>remove(Object o)</code>删除指定元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历数组，找到第一个目标元素，然后删除</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">remove</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[index] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 逻辑和remove一致，都是将index后面的元素往前移动一位，覆盖index处的元素</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fastRemove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"literal\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法涉及到数组遍历和元素移动，效率也不高。</p>\n<h4 id=\"trimToSize\"><a href=\"#trimToSize\" class=\"headerlink\" title=\"trimToSize()\"></a>trimToSize()</h4><p><code>trimToSize()</code>源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void trimToSize() &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    if (size &lt; elementData.length) &#123;</span><br><span class=\"line\">        elementData = (size == 0)</span><br><span class=\"line\">          ? EMPTY_ELEMENTDATA</span><br><span class=\"line\">          : Arrays.copyOf(elementData, size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该方法用于将数组容量调整为实际元素个数大小，当一个ArrayList元素个数不会发生改变时，可以调用该方法减少内存占用。</p>\n<blockquote>\n<p>其他方法可以自己阅读ArrayList源码，此外在涉及增删改的方法里，我们都看到了modCount++操作，和之前介绍HashMap源码时一致，用于快速失败。</p>\n</blockquote>\n<h2 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h2><h3 id=\"类结构-1\"><a href=\"#类结构-1\" class=\"headerlink\" title=\"类结构\"></a>类结构</h3><p>LinkedList底层采用双向链表结构存储数据，允许重复数据和null值，长度没有限制：</p>\n<p><img src=\"/JAVA-ArrayList&LinkedList%5CQQ20210220-112151@2x.png\" alt=\"QQ20210220-112151@2x\"></p>\n<p>每个节点用内部类Node表示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Node节点包含item（存储数据），next（后继节点）和prev（前继节点）。数组内存地址必须连续，而链表就没有这个限制了，Node可以分布于各个内存地址，它们之间的关系通过prev和next维护。</p>\n<p>LinkedList类关系图：</p>\n<p><img src=\"/JAVA-ArrayList&LinkedList%5CQQ20210220-112546@2x.png\" alt=\"QQ20210220-112546@2x\"></p>\n<p>可以看到LinkedList类并没有实现RandomAccess接口，额外实现了Deque接口，所以包含一些队列方法。</p>\n<p>LinkedList包含如下成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 元素个数，默认为0</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 表示第一个节点，第一个节点必须满足(first == null &amp;&amp; last == null) || (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; first;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 表示最后一个节点，最后一个节点必须满足(first == null &amp;&amp; last == null) || (last.next == null &amp;&amp; last.item != null)</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法解析-1\"><a href=\"#方法解析-1\" class=\"headerlink\" title=\"方法解析\"></a>方法解析</h3><h4 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p><code>LinkedList()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">LinkedList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>空参构造函数，默认size为0，每次添加新元素都要创建Node节点。</p>\n<p><code>LinkedList(Collection&lt;? extends E&gt; c)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addAll(size, c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addAll</span><span class=\"params\">(<span class=\"type\">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">numNew</span> <span class=\"operator\">=</span> a.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node&lt;E&gt; pred, succ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size) &#123;</span><br><span class=\"line\">        succ = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        pred = last;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        succ = node(index);</span><br><span class=\"line\">        pred = succ.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 循环创建节点，设置prev，next指向</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object o : a) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class=\"type\">E</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> (E) o;</span><br><span class=\"line\">        Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;&gt;(pred, e, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            first = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pred.next = newNode;</span><br><span class=\"line\">        pred = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (succ == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        last = pred;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        pred.next = succ;</span><br><span class=\"line\">        succ.prev = pred;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    size += numNew;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该构造函数用于创建LinkedList，并往里添加指定集合元素。</p>\n<h4 id=\"add-int-index-E-element-1\"><a href=\"#add-int-index-E-element-1\" class=\"headerlink\" title=\"add(int index, E element)\"></a>add(int index, E element)</h4><p><code>add(int index, E element)</code>指定下标插入元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标合法性检查</span></span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size)</span><br><span class=\"line\">        <span class=\"comment\">// 如果插入下标等于size，说明是在尾部插入，执行尾部插入操作</span></span><br><span class=\"line\">        linkLast(element);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果不是尾插入，则在指定下标节点前插入</span></span><br><span class=\"line\">        linkBefore(element, node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkPositionIndex</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPositionIndex(index))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPositionIndex</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">linkLast</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取最后一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个新节点，prev为原链表最后一个节点，next为null</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;&gt;(l, e, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 更新last为新节点</span></span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 如果原链表最后一个节点为null，说明原链表没有节点，将新节点赋给first</span></span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 否则更新原链表最后一个节点的next为新节点</span></span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\">    <span class=\"comment\">// size递增</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    <span class=\"comment\">// 模数递增，用于快速失败</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">linkBefore</span><span class=\"params\">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// succ为原链表指定index位置的节点，获取其prev节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">    <span class=\"comment\">// 创建新节点，prev为原链表指定index位置的节点的prev节点，next为原链表指定index位置的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class=\"line\">    <span class=\"comment\">// 将原链表指定index位置的节点的prev更新为新节点</span></span><br><span class=\"line\">    succ.prev = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 如果链表指定index位置的节点的prev为null，说明原链表没有节点，将新节点赋给first</span></span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 否则更新原链表指定index位置的节点的prev的next节点为新节点</span></span><br><span class=\"line\">        pred.next = newNode;</span><br><span class=\"line\">    <span class=\"comment\">// size递增</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    <span class=\"comment\">// 模数递增，用于快速失败</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class=\"line\">Node&lt;E&gt; <span class=\"title function_\">node</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码较为简单，无非就是设置节点的prev和next关系。可以看到，除了头插和尾插外，在链表别的位置插入新节点，涉及到节点遍历操作，所以我们常说的链表插入速度快，指的是插入节点改变前后节点的引用过程很快。</p>\n<h4 id=\"get-int-index-1\"><a href=\"#get-int-index-1\" class=\"headerlink\" title=\"get(int index)\"></a>get(int index)</h4><p><code>get(int index)</code>获取指定下标元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class=\"line\">Node&lt;E&gt; <span class=\"title function_\">node</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码较为简单，就是通过node函数查找指定index下标Node，然后获取其item属性值，节点查找需要遍历。</p>\n<h4 id=\"set-int-index-E-element-1\"><a href=\"#set-int-index-E-element-1\" class=\"headerlink\" title=\"set(int index, E element)\"></a>set(int index, E element)</h4><p><code>set(int index, E element)</code>设置指定下标节点的item为指定值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">set</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标合法性检查</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"comment\">// 获取index下标节点</span></span><br><span class=\"line\">    Node&lt;E&gt; x = node(index);</span><br><span class=\"line\">    <span class=\"comment\">// 获取旧值</span></span><br><span class=\"line\">    <span class=\"type\">E</span> <span class=\"variable\">oldVal</span> <span class=\"operator\">=</span> x.item;</span><br><span class=\"line\">    <span class=\"comment\">// 设置新值</span></span><br><span class=\"line\">    x.item = element;</span><br><span class=\"line\">    <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class=\"line\">Node&lt;E&gt; <span class=\"title function_\">node</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，set方法也需要通过遍历查找目标节点。</p>\n<h4 id=\"remove-int-index-1\"><a href=\"#remove-int-index-1\" class=\"headerlink\" title=\"remove(int index)\"></a>remove(int index)</h4><p><code>remove(int index)</code>删除指定下标节点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">remove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unlink(node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">E <span class=\"title function_\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert x != null;</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">E</span> <span class=\"variable\">element</span> <span class=\"operator\">=</span> x.item;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        prev.next = next;</span><br><span class=\"line\">        x.prev = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        last = prev;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next.prev = prev;</span><br><span class=\"line\">        x.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    x.item = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>remove(int index)</code>通过node方法找到需要删除的节点，然后调用unlink方法改变删除节点的prev和next节点的前继和后继节点。</p>\n<blockquote>\n<p>剩下的方法可以自己阅读源码。</p>\n</blockquote>\n<h2 id=\"RandomAccess接口\"><a href=\"#RandomAccess接口\" class=\"headerlink\" title=\"RandomAccess接口\"></a>RandomAccess接口</h2><p>RandomAccess接口是一个空接口，不包含任何方法，只是作为一个标识：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RandomAccess</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现该接口的类说明其支持快速随机访问，比如ArrayList实现了该接口，说明ArrayList支持快速随机访问。所谓快速随机访问指的是通过元素的下标即可快速获取元素对象，无需遍历，而LinkedList则没有这个特性，元素获取必须遍历链表。</p>\n<p>在Collections类的<code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code>方法中，可以看到RandomAccess的应用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">binarySearch</span><span class=\"params\">(List&lt;? extends Comparable&lt;? <span class=\"built_in\">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当list实现了RandomAccess接口时，调用indexedBinarySearch方法，否则调用iteratorBinarySearch。所以当我们遍历集合时，如果集合实现了RandomAccess接口，优先选择普通for循环，其次foreach；遍历未实现RandomAccess的接口，优先选择iterator遍历。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录ArrayList &amp; LinkedList源码解析，基于JDK1.8。</p>\n<h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h2><p>ArrayList实现了List接口的所有方法，可以看成是“长度可调节的数组”，可以包含任何类型数据（包括null，可重复）。ArrayList大体和Vector一致，唯一区别是ArrayList非线程安全，Vector线程安全，但Vector线程安全的代价较大，推荐使用CopyOnWriteArrayList，后面文章再做记录。</p>\n<h3 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h3><p>ArrayList类层级关系如下图所示：</p>\n<p><img src=\"/JAVA-ArrayList&LinkedList%5CQQ20210219-143407@2x.png\" alt=\"QQ20210219-143407@2x\"></p>\n<p>ArrayList额外实现了RandomAccess接口，关于RandomAccess接口的作用下面再做讨论。</p>\n<p>ArrayList类主要包含如下两个成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractList</span>&lt;E&gt;</span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> size;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>elementData为Object类型数组，用于存放ArrayList数据；size表示数组元素个数（并非数组容量）。</p>\n<p>ArrayList类还包含了一些常量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ArrayList</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractList</span>&lt;E&gt;</span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 数组默认初始化容量为10</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 表示空数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 也是空数组，和EMPTY_ELEMENTDATA区分开</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法解析\"><a href=\"#方法解析\" class=\"headerlink\" title=\"方法解析\"></a>方法解析</h3><h4 id=\"知识储备\"><a href=\"#知识储备\" class=\"headerlink\" title=\"知识储备\"></a>知识储备</h4><p>Arrays类的<code>copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType)</code>方法用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型为newType。</p>\n<ol>\n<li>如果新数组的长度大于旧数组，那么多出的那部分用null填充；</li>\n<li>如果新数组的长度小于旧数组，那么少的那部分直接截取掉。</li>\n</ol>\n<p>举两个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long[] array1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Long</span>[]&#123;<span class=\"number\">1L</span>, <span class=\"number\">2L</span>, <span class=\"number\">3L</span>&#125;;</span><br><span class=\"line\">Object[] array2 = Arrays.copyOf(array1, <span class=\"number\">5</span>, Object[].class);</span><br><span class=\"line\">System.out.println(Arrays.toString(array2)); <span class=\"comment\">// [1, 2, 3, null, null]</span></span><br><span class=\"line\"></span><br><span class=\"line\">Object[] array3 = Arrays.copyOf(array1, <span class=\"number\">1</span>, Object[].class);</span><br><span class=\"line\">System.out.println(Arrays.toString(array3)); <span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>重载方法<code>copyOf(T[] original, int newLength)</code>用于复制指定数组original到新数组，新数组的长度为newLength，新数组元素类型和旧数组一致。</p>\n<p><code>copyOf</code>方法内部调用System类的native方法<code>arraycopy(Object src, int srcPos,Object dest, int destPos, int length)</code>：</p>\n<ol>\n<li><code>src</code>：需要被拷贝的旧数组；</li>\n<li><code>srcPos</code>：旧数组开始拷贝的起始位置；</li>\n<li><code>dest</code>：拷贝目标数组；</li>\n<li><code>destPos</code>：目标数组的起始拷贝位置；</li>\n<li><code>length</code>：拷贝的长度。</li>\n</ol>\n<p>举例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long[] array1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Long</span>[]&#123;<span class=\"number\">1L</span>, <span class=\"number\">2L</span>, <span class=\"number\">3L</span>&#125;;</span><br><span class=\"line\">Object[] array2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\">System.arraycopy(array1, <span class=\"number\">0</span>, array2, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">System.out.println(Arrays.toString(array2)); <span class=\"comment\">// [1, 2, 3, null, null]</span></span><br></pre></td></tr></table></figure>\n\n<p>指定位置插入元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long[] array1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Long</span>[]&#123;<span class=\"number\">1L</span>, <span class=\"number\">2L</span>, <span class=\"number\">3L</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">System.arraycopy(array1, index, array1, index + <span class=\"number\">1</span>, <span class=\"number\">3</span> - index);</span><br><span class=\"line\">array1[index] = <span class=\"number\">0L</span>;</span><br><span class=\"line\">System.out.println(Arrays.toString(array1)); <span class=\"comment\">// [1, 0, 2, 3, null, null]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[initialCapacity];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Illegal Capacity: &quot;</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建容量大小为initialCapacity的ArrayList，如果initialCapacity小于0，则抛出IllegalArgumentException异常；如果initialCapacity为0，则elementData为EMPTY_ELEMENTDATA。</p>\n<p><code>public ArrayList()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>空参构造函数，elementData为DEFAULTCAPACITY_EMPTY_ELEMENTDATA。</p>\n<p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个包含指定集合c数据的ArrayList。上面为什么要多此一举使用<code>Arrays.copyOf(elementData, size, Object[].class)</code>复制一遍数组呢？这是因为在某些情况下调用集合的toArray()方法返回的类型并不是Object[].class，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long[] array1 = &#123;<span class=\"number\">1L</span>, <span class=\"number\">2L</span>&#125;;</span><br><span class=\"line\">List&lt;Long&gt; list1 = Arrays.asList(array1);</span><br><span class=\"line\">Object[] array2 = list1.toArray();</span><br><span class=\"line\">System.out.println(array2.getClass() == Object[].class); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Long&gt; list2 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">System.out.println(list2.toArray().getClass() == Object[].class); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"add-E-e\"><a href=\"#add-E-e\" class=\"headerlink\" title=\"add(E e)\"></a>add(E e)</h4><p><code>add(E e)</code>用于尾部添加元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用于确定数组容量</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假如现在我们通过如下代码创建了一个ArrayList实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>内部过程如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用于确定数组容量，e=hello，size=0</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 末尾添加元素，然后size递增1</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123; <span class=\"comment\">// minCapacity=1,elementData=&#123;&#125;</span></span><br><span class=\"line\">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// DEFAULT_CAPACITY=10，minCapacity=1，故返回10</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123; <span class=\"comment\">// minCapacity=10</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// minCapacity=10，elementData.length=0，所以调用grow方法扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123; <span class=\"comment\">//minCapacity=10</span></span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity=0</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// newCapacity为oldCapacity的1.5倍，这里为0</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// newCapacity=0，minCapacity=10，所以该条件成立</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// newCapacity=10</span></span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// 复制到新数组，数组容量为10</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hugeCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutOfMemoryError</span>();</span><br><span class=\"line\">    <span class=\"comment\">// MAX_ARRAY_SIZE常量值为Integer.MAX_VALUE - 8，通过</span></span><br><span class=\"line\">    <span class=\"comment\">// 这段逻辑我们可以知道，ArrayList最大容量为Integer.MAX_VALUE</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过上面源码分析我们可以知道：</p>\n<ol>\n<li>任何一个空的ArrayList在添加第一个元素时，内部数组容量将被扩容为10；</li>\n<li>扩容时，newCapacity为oldCapacity的1.5倍；</li>\n<li>数组容量最大为Integer.MAX_VALUE；</li>\n<li>尾部添加元素不用移动任何元素，所以速度快。</li>\n</ol>\n<h4 id=\"add-int-index-E-element\"><a href=\"#add-int-index-E-element\" class=\"headerlink\" title=\"add(int index, E element)\"></a>add(int index, E element)</h4><p><code>add(int index, E element)</code>用于在指定位置添加元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标检查</span></span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\">    <span class=\"comment\">// 确定数组容量，和上面add(E e)方法介绍的一致</span></span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 将原来index后面的所有元素往后面移动一个位置</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\">    <span class=\"comment\">// index处放入新元素</span></span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    <span class=\"comment\">// size递增</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标比size大或者下标小于0，都会抛出下标越界异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里涉及到元素移动，所以速度较慢。</p>\n<h4 id=\"get-int-index\"><a href=\"#get-int-index\" class=\"headerlink\" title=\"get(int index)\"></a>get(int index)</h4><p><code>get(int index)</code>获取指定位置元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标合法性检查</span></span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    <span class=\"comment\">// 直接返回数组指定位置元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elementData(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">E <span class=\"title function_\">elementData</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[index];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>get</code>方法直接返回数组指定下标元素，速度非常快。</p>\n<h4 id=\"set-int-index-E-element\"><a href=\"#set-int-index-E-element\" class=\"headerlink\" title=\"set(int index, E element)\"></a>set(int index, E element)</h4><p><code>set(int index, E element)</code>设置指定位置元素为指定值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">set</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标合法性检查</span></span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    <span class=\"comment\">// 根据下标获取旧值</span></span><br><span class=\"line\">    <span class=\"type\">E</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> elementData(index);</span><br><span class=\"line\">    <span class=\"comment\">// 设置新值</span></span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>set</code>方法不涉及元素移动和遍历，所以速度快。</p>\n<h4 id=\"remove-int-index\"><a href=\"#remove-int-index\" class=\"headerlink\" title=\"remove(int index)\"></a>remove(int index)</h4><p><code>remove(int index)</code>删除指定位置元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">remove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">// 获取指定位置元素（需要被删除的元素）</span></span><br><span class=\"line\">    <span class=\"type\">E</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 直接将index后面的元素往前移动一位，覆盖index处的元素</span></span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"literal\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    <span class=\"comment\">// 返回被删除的元</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述方法涉及到元素移动，所以效率也不高。</p>\n<h4 id=\"remove-Object-o\"><a href=\"#remove-Object-o\" class=\"headerlink\" title=\"remove(Object o)\"></a>remove(Object o)</h4><p><code>remove(Object o)</code>删除指定元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历数组，找到第一个目标元素，然后删除</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">remove</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[index] == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 逻辑和remove一致，都是将index后面的元素往前移动一位，覆盖index处的元素</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fastRemove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">numMoved</span> <span class=\"operator\">=</span> size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                         numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"literal\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法涉及到数组遍历和元素移动，效率也不高。</p>\n<h4 id=\"trimToSize\"><a href=\"#trimToSize\" class=\"headerlink\" title=\"trimToSize()\"></a>trimToSize()</h4><p><code>trimToSize()</code>源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void trimToSize() &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    if (size &lt; elementData.length) &#123;</span><br><span class=\"line\">        elementData = (size == 0)</span><br><span class=\"line\">          ? EMPTY_ELEMENTDATA</span><br><span class=\"line\">          : Arrays.copyOf(elementData, size);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该方法用于将数组容量调整为实际元素个数大小，当一个ArrayList元素个数不会发生改变时，可以调用该方法减少内存占用。</p>\n<blockquote>\n<p>其他方法可以自己阅读ArrayList源码，此外在涉及增删改的方法里，我们都看到了modCount++操作，和之前介绍HashMap源码时一致，用于快速失败。</p>\n</blockquote>\n<h2 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h2><h3 id=\"类结构-1\"><a href=\"#类结构-1\" class=\"headerlink\" title=\"类结构\"></a>类结构</h3><p>LinkedList底层采用双向链表结构存储数据，允许重复数据和null值，长度没有限制：</p>\n<p><img src=\"/JAVA-ArrayList&LinkedList%5CQQ20210220-112151@2x.png\" alt=\"QQ20210220-112151@2x\"></p>\n<p>每个节点用内部类Node表示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Node节点包含item（存储数据），next（后继节点）和prev（前继节点）。数组内存地址必须连续，而链表就没有这个限制了，Node可以分布于各个内存地址，它们之间的关系通过prev和next维护。</p>\n<p>LinkedList类关系图：</p>\n<p><img src=\"/JAVA-ArrayList&LinkedList%5CQQ20210220-112546@2x.png\" alt=\"QQ20210220-112546@2x\"></p>\n<p>可以看到LinkedList类并没有实现RandomAccess接口，额外实现了Deque接口，所以包含一些队列方法。</p>\n<p>LinkedList包含如下成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 元素个数，默认为0</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 表示第一个节点，第一个节点必须满足(first == null &amp;&amp; last == null) || (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; first;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 表示最后一个节点，最后一个节点必须满足(first == null &amp;&amp; last == null) || (last.next == null &amp;&amp; last.item != null)</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法解析-1\"><a href=\"#方法解析-1\" class=\"headerlink\" title=\"方法解析\"></a>方法解析</h3><h4 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p><code>LinkedList()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">LinkedList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>空参构造函数，默认size为0，每次添加新元素都要创建Node节点。</p>\n<p><code>LinkedList(Collection&lt;? extends E&gt; c)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addAll(size, c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">addAll</span><span class=\"params\">(<span class=\"type\">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">numNew</span> <span class=\"operator\">=</span> a.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node&lt;E&gt; pred, succ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size) &#123;</span><br><span class=\"line\">        succ = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        pred = last;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        succ = node(index);</span><br><span class=\"line\">        pred = succ.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 循环创建节点，设置prev，next指向</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object o : a) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class=\"type\">E</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> (E) o;</span><br><span class=\"line\">        Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;&gt;(pred, e, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pred == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            first = newNode;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            pred.next = newNode;</span><br><span class=\"line\">        pred = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (succ == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        last = pred;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        pred.next = succ;</span><br><span class=\"line\">        succ.prev = pred;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    size += numNew;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该构造函数用于创建LinkedList，并往里添加指定集合元素。</p>\n<h4 id=\"add-int-index-E-element-1\"><a href=\"#add-int-index-E-element-1\" class=\"headerlink\" title=\"add(int index, E element)\"></a>add(int index, E element)</h4><p><code>add(int index, E element)</code>指定下标插入元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标合法性检查</span></span><br><span class=\"line\">    checkPositionIndex(index);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size)</span><br><span class=\"line\">        <span class=\"comment\">// 如果插入下标等于size，说明是在尾部插入，执行尾部插入操作</span></span><br><span class=\"line\">        linkLast(element);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果不是尾插入，则在指定下标节点前插入</span></span><br><span class=\"line\">        linkBefore(element, node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkPositionIndex</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPositionIndex(index))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPositionIndex</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index &gt;= <span class=\"number\">0</span> &amp;&amp; index &lt;= size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">linkLast</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取最后一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个新节点，prev为原链表最后一个节点，next为null</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;&gt;(l, e, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 更新last为新节点</span></span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 如果原链表最后一个节点为null，说明原链表没有节点，将新节点赋给first</span></span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 否则更新原链表最后一个节点的next为新节点</span></span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\">    <span class=\"comment\">// size递增</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    <span class=\"comment\">// 模数递增，用于快速失败</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">linkBefore</span><span class=\"params\">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// succ为原链表指定index位置的节点，获取其prev节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">    <span class=\"comment\">// 创建新节点，prev为原链表指定index位置的节点的prev节点，next为原链表指定index位置的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class=\"line\">    <span class=\"comment\">// 将原链表指定index位置的节点的prev更新为新节点</span></span><br><span class=\"line\">    succ.prev = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 如果链表指定index位置的节点的prev为null，说明原链表没有节点，将新节点赋给first</span></span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">// 否则更新原链表指定index位置的节点的prev的next节点为新节点</span></span><br><span class=\"line\">        pred.next = newNode;</span><br><span class=\"line\">    <span class=\"comment\">// size递增</span></span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    <span class=\"comment\">// 模数递增，用于快速失败</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class=\"line\">Node&lt;E&gt; <span class=\"title function_\">node</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码较为简单，无非就是设置节点的prev和next关系。可以看到，除了头插和尾插外，在链表别的位置插入新节点，涉及到节点遍历操作，所以我们常说的链表插入速度快，指的是插入节点改变前后节点的引用过程很快。</p>\n<h4 id=\"get-int-index-1\"><a href=\"#get-int-index-1\" class=\"headerlink\" title=\"get(int index)\"></a>get(int index)</h4><p><code>get(int index)</code>获取指定下标元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class=\"line\">Node&lt;E&gt; <span class=\"title function_\">node</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码较为简单，就是通过node函数查找指定index下标Node，然后获取其item属性值，节点查找需要遍历。</p>\n<h4 id=\"set-int-index-E-element-1\"><a href=\"#set-int-index-E-element-1\" class=\"headerlink\" title=\"set(int index, E element)\"></a>set(int index, E element)</h4><p><code>set(int index, E element)</code>设置指定下标节点的item为指定值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">set</span><span class=\"params\">(<span class=\"type\">int</span> index, E element)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下标合法性检查</span></span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"comment\">// 获取index下标节点</span></span><br><span class=\"line\">    Node&lt;E&gt; x = node(index);</span><br><span class=\"line\">    <span class=\"comment\">// 获取旧值</span></span><br><span class=\"line\">    <span class=\"type\">E</span> <span class=\"variable\">oldVal</span> <span class=\"operator\">=</span> x.item;</span><br><span class=\"line\">    <span class=\"comment\">// 设置新值</span></span><br><span class=\"line\">    x.item = element;</span><br><span class=\"line\">    <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 采用二分法遍历每个Node节点，直到找到index位置的节点</span></span><br><span class=\"line\">Node&lt;E&gt; <span class=\"title function_\">node</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = first;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">            x = x.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;E&gt; x = last;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">            x = x.prev;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，set方法也需要通过遍历查找目标节点。</p>\n<h4 id=\"remove-int-index-1\"><a href=\"#remove-int-index-1\" class=\"headerlink\" title=\"remove(int index)\"></a>remove(int index)</h4><p><code>remove(int index)</code>删除指定下标节点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">remove</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    checkElementIndex(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unlink(node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">E <span class=\"title function_\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert x != null;</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">E</span> <span class=\"variable\">element</span> <span class=\"operator\">=</span> x.item;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        prev.next = next;</span><br><span class=\"line\">        x.prev = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        last = prev;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        next.prev = prev;</span><br><span class=\"line\">        x.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    x.item = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>remove(int index)</code>通过node方法找到需要删除的节点，然后调用unlink方法改变删除节点的prev和next节点的前继和后继节点。</p>\n<blockquote>\n<p>剩下的方法可以自己阅读源码。</p>\n</blockquote>\n<h2 id=\"RandomAccess接口\"><a href=\"#RandomAccess接口\" class=\"headerlink\" title=\"RandomAccess接口\"></a>RandomAccess接口</h2><p>RandomAccess接口是一个空接口，不包含任何方法，只是作为一个标识：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RandomAccess</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现该接口的类说明其支持快速随机访问，比如ArrayList实现了该接口，说明ArrayList支持快速随机访问。所谓快速随机访问指的是通过元素的下标即可快速获取元素对象，无需遍历，而LinkedList则没有这个特性，元素获取必须遍历链表。</p>\n<p>在Collections类的<code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code>方法中，可以看到RandomAccess的应用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">binarySearch</span><span class=\"params\">(List&lt;? extends Comparable&lt;? <span class=\"built_in\">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (list <span class=\"keyword\">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当list实现了RandomAccess接口时，调用indexedBinarySearch方法，否则调用iteratorBinarySearch。所以当我们遍历集合时，如果集合实现了RandomAccess接口，优先选择普通for循环，其次foreach；遍历未实现RandomAccess的接口，优先选择iterator遍历。</p>\n"},{"title":"AQS抽象队列同步器","date":"2022-03-04T15:03:29.725Z","_content":"\nAQS全称为AbstractQueuedSynchronizer，提供了对资源占用、释放，线程等待、唤醒等接口和具体实现。可以用在各种需要控制资源争用的场景，例如ReentrantLock、CountDownLatch、Semphore中。\n\n## AQS组成部分\n\n![image-20210513220313583](JUC-AbstractQueuedSynchronizer\\AQS-接口.png)\n\nacquire、acquireShared：定义了资源争用的逻辑，如果没拿到则等待。\n\ntryAcquire、tryAcquireShared：实际执行占用资源的操作，如何判断一个由使用者具体去实现。\n\nrelease、releaseShared：定义释放资源的逻辑，释放之后通知后续节点进行争抢。\n\ntryRelease、tryReleaseShared：实际执行资源释放的操作，具体由使用者去实现。\n\n## 简单应用AQS\n\n通过这个实例加深对AQS的理解，为看懂源码打下一定的基础。\n\n```java\npublic class MyAqs {\n    // 占用当前资源的线程\n    public volatile AtomicReference<Thread> owner = new AtomicReference<>();\n    // 保存等待的线程\n    public volatile LinkedBlockingQueue<Thread> waiters = new LinkedBlockingQueue<>();\n    // 记录资源状态\n    public volatile AtomicInteger state = new AtomicInteger(0);\n    \n    public void acquire() {\n        boolean addQ = true;\n        while (!tryAcquire()) {\n            if (addQ) {\n                // 没拿到锁，加入到等待集合\n                waiters.offer(Thread.currentThread());\n                addQ = false;\n            } else {\n                // 阻塞、挂起当前的线程\n                LockSupport.park(); \n            }\n        }\n        // 当前线程拿到锁后，移除当前线程\n        waiters.remove(Thread.currentThread()); \n    }\n    \n    /**\n     * 交由使用者自己实现\n     */\n    public boolean tryAcquire() { \n        throw new UnsupportedOperationException();\n    }\n    \n    public void release() {\n        if (tryRelease()) {\n            // 通知等待者\n            Iterator<Thread> iterator = waiters.iterator();\n            if (iterator.hasNext()) {\n                Thread next = iterator.next();\n                // 当前线程释放资源后，唤醒下一个线程\n                LockSupport.unpark(next); \n            }\n        }\n    }\n    \n    public boolean tryRelease() {\n        throw new UnsupportedOperationException();\n    }\n    \n    //================== 共享资源逻辑 ==================//\n    public void acquireShared() {\n        boolean addQ = true;\n        while (tryAcquireShared() < 0) {\n            if (addQ) {\n                waiters.offer(Thread.currentThread());\n                addQ = false;\n            } else {\n                LockSupport.park(); \n            }\n        }\n        waiters.remove(Thread.currentThread());\n    }\n    \n    public int tryAcquireShared() {\n        throw new UnsupportedOperationException();\n    }\n\t\n    public void releaseShared() {\n        if (tryReleaseShared()) {\n            Iterator<Thread> iterator = waiters.iterator();\n            if (iterator.hasNext()) {\n                Thread next = iterator.next();\n                LockSupport.unpark(next);\n            }\n        }\n    }\n    \n    public boolean tryReleaseShared() {\n        throw new UnsupportedOperationException();\n    }\n    \n    // 给使用者提供状态修改方法\n    public AtomicInteger getState() {\n        return state;\n    }\n\n    public void setState(AtomicInteger state) {\n        this.state = state;\n    }\n}\n```\n\n## AQS源码阅读\n\n源码中等待队列维护的是一个链表，而不是我们上面使用的BlockingQueue。\n\n在独占模式下忽略中断的情况获取锁。如果没有拿到锁则当前线程存入队列等待后，不断尝试获取锁，具体代码在acquireQueued() 中。\n\n```java\npublic final void acquire(int arg) {\n    // 判断是否拿到锁\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\nprotected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n```\n\n如果第一次执行tryAcquire() 没有拿到锁，则当前线程将进行自旋，直到成功拿到锁。\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false; // 当前线程释放中断的标志位\n        for (;;) {// 不断尝试\n            final Node p = node.predecessor(); // 获取前一个节点\n            if (p == head && tryAcquire(arg)) { // 如果前一个节点是head，尝试抢一次锁\n                setHead(node); // 更换head\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            // 检查在当前节点之前的线程节点状态，是否需要挂起线程\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())// 如果需要挂起，则通过Park进入停车场挂起\n                interrupted = true; // 如果出现中断，则修改标记\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\nfinal Node predecessor() throws NullPointerException {\n    // 当前节点前如果没有其它节点，那就肯定是head节点\n    Node p = prev;\n    if (p == null)\n        throw new NullPointerException();\n    else\n        return p;\n}\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus; // 根据 前置节点的状态 执行不同的流程\n    if (ws == Node.SIGNAL) // 前置节点释放锁之后会通知当前线程，挂起吧\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) { // 前置节点处于CANCELLED状态，跳过它继续寻找正常的节点，并且甩掉中间那段不正常的节点\n        /*\n         * Predecessor was cancelled. Skip over predecessors and\n         * indicate retry.\n         */\n        do { // 也可以理解为，这是一次队列检查\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don't park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); // 修改前置的状态为SIGNAL，用意是释放锁之后会通知后续节点\n    }\n    return false;\n}\n```\n\n释放资源。解锁成功后，单向链表中的线程节点往后移，唤醒下一个状态正常的线程。\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head; // 从头开始找\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h); // 唤醒下一个线程\n        return true;\n    }\n    return false;\n}\n\nprotected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n\nprivate void unparkSuccessor(Node node) {\n    /*\n     * If status is negative (i.e., possibly needing signal) try\n     * to clear in anticipation of signalling.  It is OK if this\n     * fails or if status is changed by waiting thread.\n     */\n    int ws = node.waitStatus; // 正在释放锁的线程节点状态\n    if (ws < 0)\n        compareAndSetWaitStatus(node, ws, 0); // 修改当前节点状态\n\n    /*\n     * Thread to unpark is held in successor, which is normally\n     * just the next node.  But if cancelled or apparently null,\n     * traverse backwards from tail to find the actual\n     * non-cancelled successor.\n     */\n    Node s = node.next; // 找下一个节点\n    if (s == null || s.waitStatus > 0) { // 如果不存在或者被取消了，继续寻找合适的下一个节点\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null) // 如果找到了合适的节点，就唤醒它\n        LockSupport.unpark(s.thread);\n}\n```\n\n##  总结\n\n资源占用的完整流程\n\n![image-20210514131357784](JUC-AbstractQueuedSynchronizer\\AQS-资源占用流程.png)\n\n","source":"_posts/JUC-AbstractQueuedSynchronizer.md","raw":"---\ntitle: AQS抽象队列同步器\ndate: 2021‎-05‎-‎13‎ 11:54:34\ntags:\n- Juc并发包\n---\n\nAQS全称为AbstractQueuedSynchronizer，提供了对资源占用、释放，线程等待、唤醒等接口和具体实现。可以用在各种需要控制资源争用的场景，例如ReentrantLock、CountDownLatch、Semphore中。\n\n## AQS组成部分\n\n![image-20210513220313583](JUC-AbstractQueuedSynchronizer\\AQS-接口.png)\n\nacquire、acquireShared：定义了资源争用的逻辑，如果没拿到则等待。\n\ntryAcquire、tryAcquireShared：实际执行占用资源的操作，如何判断一个由使用者具体去实现。\n\nrelease、releaseShared：定义释放资源的逻辑，释放之后通知后续节点进行争抢。\n\ntryRelease、tryReleaseShared：实际执行资源释放的操作，具体由使用者去实现。\n\n## 简单应用AQS\n\n通过这个实例加深对AQS的理解，为看懂源码打下一定的基础。\n\n```java\npublic class MyAqs {\n    // 占用当前资源的线程\n    public volatile AtomicReference<Thread> owner = new AtomicReference<>();\n    // 保存等待的线程\n    public volatile LinkedBlockingQueue<Thread> waiters = new LinkedBlockingQueue<>();\n    // 记录资源状态\n    public volatile AtomicInteger state = new AtomicInteger(0);\n    \n    public void acquire() {\n        boolean addQ = true;\n        while (!tryAcquire()) {\n            if (addQ) {\n                // 没拿到锁，加入到等待集合\n                waiters.offer(Thread.currentThread());\n                addQ = false;\n            } else {\n                // 阻塞、挂起当前的线程\n                LockSupport.park(); \n            }\n        }\n        // 当前线程拿到锁后，移除当前线程\n        waiters.remove(Thread.currentThread()); \n    }\n    \n    /**\n     * 交由使用者自己实现\n     */\n    public boolean tryAcquire() { \n        throw new UnsupportedOperationException();\n    }\n    \n    public void release() {\n        if (tryRelease()) {\n            // 通知等待者\n            Iterator<Thread> iterator = waiters.iterator();\n            if (iterator.hasNext()) {\n                Thread next = iterator.next();\n                // 当前线程释放资源后，唤醒下一个线程\n                LockSupport.unpark(next); \n            }\n        }\n    }\n    \n    public boolean tryRelease() {\n        throw new UnsupportedOperationException();\n    }\n    \n    //================== 共享资源逻辑 ==================//\n    public void acquireShared() {\n        boolean addQ = true;\n        while (tryAcquireShared() < 0) {\n            if (addQ) {\n                waiters.offer(Thread.currentThread());\n                addQ = false;\n            } else {\n                LockSupport.park(); \n            }\n        }\n        waiters.remove(Thread.currentThread());\n    }\n    \n    public int tryAcquireShared() {\n        throw new UnsupportedOperationException();\n    }\n\t\n    public void releaseShared() {\n        if (tryReleaseShared()) {\n            Iterator<Thread> iterator = waiters.iterator();\n            if (iterator.hasNext()) {\n                Thread next = iterator.next();\n                LockSupport.unpark(next);\n            }\n        }\n    }\n    \n    public boolean tryReleaseShared() {\n        throw new UnsupportedOperationException();\n    }\n    \n    // 给使用者提供状态修改方法\n    public AtomicInteger getState() {\n        return state;\n    }\n\n    public void setState(AtomicInteger state) {\n        this.state = state;\n    }\n}\n```\n\n## AQS源码阅读\n\n源码中等待队列维护的是一个链表，而不是我们上面使用的BlockingQueue。\n\n在独占模式下忽略中断的情况获取锁。如果没有拿到锁则当前线程存入队列等待后，不断尝试获取锁，具体代码在acquireQueued() 中。\n\n```java\npublic final void acquire(int arg) {\n    // 判断是否拿到锁\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\nprotected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n```\n\n如果第一次执行tryAcquire() 没有拿到锁，则当前线程将进行自旋，直到成功拿到锁。\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false; // 当前线程释放中断的标志位\n        for (;;) {// 不断尝试\n            final Node p = node.predecessor(); // 获取前一个节点\n            if (p == head && tryAcquire(arg)) { // 如果前一个节点是head，尝试抢一次锁\n                setHead(node); // 更换head\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            // 检查在当前节点之前的线程节点状态，是否需要挂起线程\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())// 如果需要挂起，则通过Park进入停车场挂起\n                interrupted = true; // 如果出现中断，则修改标记\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\nfinal Node predecessor() throws NullPointerException {\n    // 当前节点前如果没有其它节点，那就肯定是head节点\n    Node p = prev;\n    if (p == null)\n        throw new NullPointerException();\n    else\n        return p;\n}\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus; // 根据 前置节点的状态 执行不同的流程\n    if (ws == Node.SIGNAL) // 前置节点释放锁之后会通知当前线程，挂起吧\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) { // 前置节点处于CANCELLED状态，跳过它继续寻找正常的节点，并且甩掉中间那段不正常的节点\n        /*\n         * Predecessor was cancelled. Skip over predecessors and\n         * indicate retry.\n         */\n        do { // 也可以理解为，这是一次队列检查\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don't park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); // 修改前置的状态为SIGNAL，用意是释放锁之后会通知后续节点\n    }\n    return false;\n}\n```\n\n释放资源。解锁成功后，单向链表中的线程节点往后移，唤醒下一个状态正常的线程。\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head; // 从头开始找\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h); // 唤醒下一个线程\n        return true;\n    }\n    return false;\n}\n\nprotected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n\nprivate void unparkSuccessor(Node node) {\n    /*\n     * If status is negative (i.e., possibly needing signal) try\n     * to clear in anticipation of signalling.  It is OK if this\n     * fails or if status is changed by waiting thread.\n     */\n    int ws = node.waitStatus; // 正在释放锁的线程节点状态\n    if (ws < 0)\n        compareAndSetWaitStatus(node, ws, 0); // 修改当前节点状态\n\n    /*\n     * Thread to unpark is held in successor, which is normally\n     * just the next node.  But if cancelled or apparently null,\n     * traverse backwards from tail to find the actual\n     * non-cancelled successor.\n     */\n    Node s = node.next; // 找下一个节点\n    if (s == null || s.waitStatus > 0) { // 如果不存在或者被取消了，继续寻找合适的下一个节点\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null) // 如果找到了合适的节点，就唤醒它\n        LockSupport.unpark(s.thread);\n}\n```\n\n##  总结\n\n资源占用的完整流程\n\n![image-20210514131357784](JUC-AbstractQueuedSynchronizer\\AQS-资源占用流程.png)\n\n","slug":"JUC-AbstractQueuedSynchronizer","published":1,"updated":"2022-03-05T12:43:16.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0eqk39h0003o4u5bilk0fx3","content":"<p>AQS全称为AbstractQueuedSynchronizer，提供了对资源占用、释放，线程等待、唤醒等接口和具体实现。可以用在各种需要控制资源争用的场景，例如ReentrantLock、CountDownLatch、Semphore中。</p>\n<h2 id=\"AQS组成部分\"><a href=\"#AQS组成部分\" class=\"headerlink\" title=\"AQS组成部分\"></a>AQS组成部分</h2><p><img src=\"/JUC-AbstractQueuedSynchronizer%5CAQS-%E6%8E%A5%E5%8F%A3.png\" alt=\"image-20210513220313583\"></p>\n<p>acquire、acquireShared：定义了资源争用的逻辑，如果没拿到则等待。</p>\n<p>tryAcquire、tryAcquireShared：实际执行占用资源的操作，如何判断一个由使用者具体去实现。</p>\n<p>release、releaseShared：定义释放资源的逻辑，释放之后通知后续节点进行争抢。</p>\n<p>tryRelease、tryReleaseShared：实际执行资源释放的操作，具体由使用者去实现。</p>\n<h2 id=\"简单应用AQS\"><a href=\"#简单应用AQS\" class=\"headerlink\" title=\"简单应用AQS\"></a>简单应用AQS</h2><p>通过这个实例加深对AQS的理解，为看懂源码打下一定的基础。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAqs</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 占用当前资源的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> AtomicReference&lt;Thread&gt; owner = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicReference</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 保存等待的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> LinkedBlockingQueue&lt;Thread&gt; waiters = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 记录资源状态</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">state</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">addQ</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!tryAcquire()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addQ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没拿到锁，加入到等待集合</span></span><br><span class=\"line\">                waiters.offer(Thread.currentThread());</span><br><span class=\"line\">                addQ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 阻塞、挂起当前的线程</span></span><br><span class=\"line\">                LockSupport.park(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当前线程拿到锁后，移除当前线程</span></span><br><span class=\"line\">        waiters.remove(Thread.currentThread()); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 交由使用者自己实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAcquire</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">release</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tryRelease()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待者</span></span><br><span class=\"line\">            Iterator&lt;Thread&gt; iterator = waiters.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                <span class=\"comment\">// 当前线程释放资源后，唤醒下一个线程</span></span><br><span class=\"line\">                LockSupport.unpark(next); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryRelease</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//================== 共享资源逻辑 ==================//</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquireShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">addQ</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tryAcquireShared() &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addQ) &#123;</span><br><span class=\"line\">                waiters.offer(Thread.currentThread());</span><br><span class=\"line\">                addQ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                LockSupport.park(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        waiters.remove(Thread.currentThread());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">tryAcquireShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">releaseShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tryReleaseShared()) &#123;</span><br><span class=\"line\">            Iterator&lt;Thread&gt; iterator = waiters.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                LockSupport.unpark(next);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryReleaseShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 给使用者提供状态修改方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> AtomicInteger <span class=\"title function_\">getState</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setState</span><span class=\"params\">(AtomicInteger state)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.state = state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"AQS源码阅读\"><a href=\"#AQS源码阅读\" class=\"headerlink\" title=\"AQS源码阅读\"></a>AQS源码阅读</h2><p>源码中等待队列维护的是一个链表，而不是我们上面使用的BlockingQueue。</p>\n<p>在独占模式下忽略中断的情况获取锁。如果没有拿到锁则当前线程存入队列等待后，不断尝试获取锁，具体代码在acquireQueued() 中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否拿到锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAcquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果第一次执行tryAcquire() 没有拿到锁，则当前线程将进行自旋，直到成功拿到锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">failed</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 当前线程释放中断的标志位</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;<span class=\"comment\">// 不断尝试</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">Node</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> node.predecessor(); <span class=\"comment\">// 获取前一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class=\"comment\">// 如果前一个节点是head，尝试抢一次锁</span></span><br><span class=\"line\">                setHead(node); <span class=\"comment\">// 更换head</span></span><br><span class=\"line\">                p.next = <span class=\"literal\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 检查在当前节点之前的线程节点状态，是否需要挂起线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())<span class=\"comment\">// 如果需要挂起，则通过Park进入停车场挂起</span></span><br><span class=\"line\">                interrupted = <span class=\"literal\">true</span>; <span class=\"comment\">// 如果出现中断，则修改标记</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node <span class=\"title function_\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前节点前如果没有其它节点，那就肯定是head节点</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ws</span> <span class=\"operator\">=</span> pred.waitStatus; <span class=\"comment\">// 根据 前置节点的状态 执行不同的流程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL) <span class=\"comment\">// 前置节点释放锁之后会通知当前线程，挂起吧</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">         * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 前置节点处于CANCELLED状态，跳过它继续寻找正常的节点，并且甩掉中间那段不正常的节点</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">         * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123; <span class=\"comment\">// 也可以理解为，这是一次队列检查</span></span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class=\"line\"><span class=\"comment\">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class=\"line\"><span class=\"comment\">         * retry to make sure it cannot acquire before parking.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class=\"comment\">// 修改前置的状态为SIGNAL，用意是释放锁之后会通知后续节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放资源。解锁成功后，单向链表中的线程节点往后移，唤醒下一个状态正常的线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">release</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> head; <span class=\"comment\">// 从头开始找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"literal\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h); <span class=\"comment\">// 唤醒下一个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryRelease</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unparkSuccessor</span><span class=\"params\">(Node node)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class=\"line\"><span class=\"comment\">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class=\"line\"><span class=\"comment\">     * fails or if status is changed by waiting thread.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ws</span> <span class=\"operator\">=</span> node.waitStatus; <span class=\"comment\">// 正在释放锁的线程节点状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>); <span class=\"comment\">// 修改当前节点状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Thread to unpark is held in successor, which is normally</span></span><br><span class=\"line\"><span class=\"comment\">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class=\"line\"><span class=\"comment\">     * traverse backwards from tail to find the actual</span></span><br><span class=\"line\"><span class=\"comment\">     * non-cancelled successor.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> node.next; <span class=\"comment\">// 找下一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果不存在或者被取消了，继续寻找合适的下一个节点</span></span><br><span class=\"line\">        s = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">Node</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> tail; t != <span class=\"literal\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                s = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"literal\">null</span>) <span class=\"comment\">// 如果找到了合适的节点，就唤醒它</span></span><br><span class=\"line\">        LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>资源占用的完整流程</p>\n<p><img src=\"/JUC-AbstractQueuedSynchronizer%5CAQS-%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%B5%81%E7%A8%8B.png\" alt=\"image-20210514131357784\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>AQS全称为AbstractQueuedSynchronizer，提供了对资源占用、释放，线程等待、唤醒等接口和具体实现。可以用在各种需要控制资源争用的场景，例如ReentrantLock、CountDownLatch、Semphore中。</p>\n<h2 id=\"AQS组成部分\"><a href=\"#AQS组成部分\" class=\"headerlink\" title=\"AQS组成部分\"></a>AQS组成部分</h2><p><img src=\"/JUC-AbstractQueuedSynchronizer%5CAQS-%E6%8E%A5%E5%8F%A3.png\" alt=\"image-20210513220313583\"></p>\n<p>acquire、acquireShared：定义了资源争用的逻辑，如果没拿到则等待。</p>\n<p>tryAcquire、tryAcquireShared：实际执行占用资源的操作，如何判断一个由使用者具体去实现。</p>\n<p>release、releaseShared：定义释放资源的逻辑，释放之后通知后续节点进行争抢。</p>\n<p>tryRelease、tryReleaseShared：实际执行资源释放的操作，具体由使用者去实现。</p>\n<h2 id=\"简单应用AQS\"><a href=\"#简单应用AQS\" class=\"headerlink\" title=\"简单应用AQS\"></a>简单应用AQS</h2><p>通过这个实例加深对AQS的理解，为看懂源码打下一定的基础。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAqs</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 占用当前资源的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> AtomicReference&lt;Thread&gt; owner = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicReference</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 保存等待的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> LinkedBlockingQueue&lt;Thread&gt; waiters = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 记录资源状态</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">state</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">addQ</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!tryAcquire()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addQ) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没拿到锁，加入到等待集合</span></span><br><span class=\"line\">                waiters.offer(Thread.currentThread());</span><br><span class=\"line\">                addQ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 阻塞、挂起当前的线程</span></span><br><span class=\"line\">                LockSupport.park(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当前线程拿到锁后，移除当前线程</span></span><br><span class=\"line\">        waiters.remove(Thread.currentThread()); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 交由使用者自己实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAcquire</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">release</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tryRelease()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通知等待者</span></span><br><span class=\"line\">            Iterator&lt;Thread&gt; iterator = waiters.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                <span class=\"comment\">// 当前线程释放资源后，唤醒下一个线程</span></span><br><span class=\"line\">                LockSupport.unpark(next); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryRelease</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//================== 共享资源逻辑 ==================//</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquireShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">addQ</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (tryAcquireShared() &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addQ) &#123;</span><br><span class=\"line\">                waiters.offer(Thread.currentThread());</span><br><span class=\"line\">                addQ = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                LockSupport.park(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        waiters.remove(Thread.currentThread());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">tryAcquireShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">releaseShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tryReleaseShared()) &#123;</span><br><span class=\"line\">            Iterator&lt;Thread&gt; iterator = waiters.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> iterator.next();</span><br><span class=\"line\">                LockSupport.unpark(next);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryReleaseShared</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 给使用者提供状态修改方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> AtomicInteger <span class=\"title function_\">getState</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setState</span><span class=\"params\">(AtomicInteger state)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.state = state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"AQS源码阅读\"><a href=\"#AQS源码阅读\" class=\"headerlink\" title=\"AQS源码阅读\"></a>AQS源码阅读</h2><p>源码中等待队列维护的是一个链表，而不是我们上面使用的BlockingQueue。</p>\n<p>在独占模式下忽略中断的情况获取锁。如果没有拿到锁则当前线程存入队列等待后，不断尝试获取锁，具体代码在acquireQueued() 中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否拿到锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAcquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果第一次执行tryAcquire() 没有拿到锁，则当前线程将进行自旋，直到成功拿到锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">failed</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 当前线程释放中断的标志位</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;<span class=\"comment\">// 不断尝试</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">Node</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> node.predecessor(); <span class=\"comment\">// 获取前一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class=\"comment\">// 如果前一个节点是head，尝试抢一次锁</span></span><br><span class=\"line\">                setHead(node); <span class=\"comment\">// 更换head</span></span><br><span class=\"line\">                p.next = <span class=\"literal\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 检查在当前节点之前的线程节点状态，是否需要挂起线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())<span class=\"comment\">// 如果需要挂起，则通过Park进入停车场挂起</span></span><br><span class=\"line\">                interrupted = <span class=\"literal\">true</span>; <span class=\"comment\">// 如果出现中断，则修改标记</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node <span class=\"title function_\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前节点前如果没有其它节点，那就肯定是head节点</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ws</span> <span class=\"operator\">=</span> pred.waitStatus; <span class=\"comment\">// 根据 前置节点的状态 执行不同的流程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL) <span class=\"comment\">// 前置节点释放锁之后会通知当前线程，挂起吧</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">         * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 前置节点处于CANCELLED状态，跳过它继续寻找正常的节点，并且甩掉中间那段不正常的节点</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">         * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123; <span class=\"comment\">// 也可以理解为，这是一次队列检查</span></span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class=\"line\"><span class=\"comment\">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class=\"line\"><span class=\"comment\">         * retry to make sure it cannot acquire before parking.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class=\"comment\">// 修改前置的状态为SIGNAL，用意是释放锁之后会通知后续节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>释放资源。解锁成功后，单向链表中的线程节点往后移，唤醒下一个状态正常的线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">release</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> head; <span class=\"comment\">// 从头开始找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"literal\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h); <span class=\"comment\">// 唤醒下一个线程</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryRelease</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unparkSuccessor</span><span class=\"params\">(Node node)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class=\"line\"><span class=\"comment\">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class=\"line\"><span class=\"comment\">     * fails or if status is changed by waiting thread.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">ws</span> <span class=\"operator\">=</span> node.waitStatus; <span class=\"comment\">// 正在释放锁的线程节点状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>); <span class=\"comment\">// 修改当前节点状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * Thread to unpark is held in successor, which is normally</span></span><br><span class=\"line\"><span class=\"comment\">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class=\"line\"><span class=\"comment\">     * traverse backwards from tail to find the actual</span></span><br><span class=\"line\"><span class=\"comment\">     * non-cancelled successor.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> node.next; <span class=\"comment\">// 找下一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果不存在或者被取消了，继续寻找合适的下一个节点</span></span><br><span class=\"line\">        s = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">Node</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> tail; t != <span class=\"literal\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                s = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"literal\">null</span>) <span class=\"comment\">// 如果找到了合适的节点，就唤醒它</span></span><br><span class=\"line\">        LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>资源占用的完整流程</p>\n<p><img src=\"/JUC-AbstractQueuedSynchronizer%5CAQS-%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%B5%81%E7%A8%8B.png\" alt=\"image-20210514131357784\"></p>\n"},{"title":"CAS","date":"2021-08-22T04:49:26.000Z","description":"CAS全称Compare and swap（比较并替换），CAS虽然能很高效的解决原子操作，但CAS存在三大弊端：ABA问题、自旋时间长时浪费CPU、只能保证一个共享变量的原子操作。","_content":"\n线程的三大特性：原子性、有序性、可见性。\n\n- 原子性：一个或多个操作的程序执行视作一个整体，不可被分割，不可被中断，不可被外界干扰，也就是说同一时刻只能有一个线程来执行这些操作。\n\n- 有序性：程序按一定规则进行顺序的执行。\n\n- 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看的到修改的值。\n\n## 什么是CAS？\n\nCAS在Java出现，在Java中称为自旋锁。CAS类似于synchronized锁的功能，但两者原理不同。\n\nCAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。这样说或许有些抽象，我们来看一个例子：\n\n1. 在内存地址V当中，存储着值为10的变量。\n\n![img](JUC-CAS\\1193919-20180102142540362-571280295.png)\n\n2. 此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。\n\n![img](JUC-CAS\\1193919-20180102142542299-1617994496.png)\n\n3. 在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。\n\n![img](JUC-CAS/1193919-20180102142543784-1625100143.png)\n\n4. 线程1开始提交更新，首先进行**A和地址V的实际值比较（Compare）**，发现A不等于V的实际值，提交失败。\n\n![img](JUC-CAS/1193919-20180102142545221-837543615.png)\n\n5. 线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为**自旋**。\n\n![img](JUC-CAS/1193919-20180102142546909-270453852.png)\n\n6. 这一次比较幸运，没有其他线程改变地址V的值。线程1进行**Compare**，发现A和地址V的实际值是相等的。\n\n![img](JUC-CAS/1193919-20180102142548299-328053032-16464619321157.png)\n\n7. 线程1进行**SWAP**，把地址V的值替换为B，也就是12。\n\n![img](JUC-CAS/1193919-20180102142625753-443716413.png)\n\n从思想上来说，Synchronized属于**悲观锁**，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于**乐观锁**，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。\n\n## JDK中的CAS应用实例\n\n在JDK的 java.util.concurrent.atomic 包下，一系列以Atomic开头的包装类。如AtomicBoolean，AtomicInteger，AtomicLong。它们分别用于Boolean，Integer，Long类型的原子性操作。\n\ncompareAndSet利用JNI来完成CPU指令的操作。\n\n```java\npublic final boolean compareAndSet(int expect, int update) {   \n    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n}\n```\n\n\n\n## CAS的优点\n\n### 提升吞吐量\n\n线程一直处于活跃状态（非阻塞），不需要CPU进行频繁调度。\n\n### 可避免死锁\n\n不用 synchronized 或 Lock 当然就可以避免死锁。\n\n## CAS的弊端\n\n### ABA问题\n\n在并发环境下会出现的ABA问题是CAS机制中的一个严重弊端。\n\n> 什么是ABA问题？\n\n假设现在有一份资源初始值为A，此时有三个线程对这份资源进行CAS操作：\n\n- 线程1，期望值为A，欲更新值为B\n- 线程2，期望值为A，欲更新值为B\n- 线程3，期望值为B，欲更新值为A\n\n线程1率先抢到CPU时间片，线程2因为某些原因阻塞了；线程1取值与A比较，发现相等后将值改为B；此时线程3出现，线程3取值与B比较，发现相等后改为A；此时线程2从阻塞中恢复开始执行，线程2的取值与A对比相等，最终改为B。\n\n在这个过程中，线程2虽然完成了操作，但线程2并不知道该值经过了`A->B->A`的这个变化过程。\n\n看到这里可能对这个ABA问题还是没有感觉，再举个现实中的栗子：\n\n小明从他的巨额账户中已有的100元中取走50元，那他取走50后还剩50，假设提款机的代码有BUG，后台开了两个线程去扣款：\n\n- 线程1：获取当前值100，期望更新为50；\n- 线程2：获取当前值100，期望更新为50；\n- 线程1：执行成功，线程2某种原因阻塞了，此时某人给小明转账50，开一个线程3去处理转账。\n- 线程3：获取当前值50，期望更新为100，此时线程3执行成功，余额变为100。\n- 线程2：从阻塞中恢复，获取到的也是100，compare之后，继续更新余额为50！！！（小明哭唧唧）\n\n此时可以看到，正常情况下，小明从100元取走50还剩50，有人转账50过来，那最终小明的存款为100元。在这个案例中被这个提款机的ABA问题引发的BUG给弄掉了50块钱。\n\nABA问题的实例代码：\n\n```java\nstatic AtomicInteger DATA = new AtomicInteger(100);\npublic static void main(String[] args) {\n    new Thread(() -> {\n        // 抢到CPU时间片，开始工作\n        boolean b = DATA.compareAndSet(100, 50);\n        System.out.println(Thread.currentThread().getName() + \"是否成功将DATA的值修改为50：\" + b);\n        try { Thread.sleep(1000); } catch (InterruptedException ignored) {}\n    }, \"线程1\").start();\n\n    new Thread(() -> {\n        // 因某些原因阻塞了\n        try { Thread.sleep(3000); } catch (InterruptedException ignored) {}\n        // 阻塞后恢复工作\n        boolean b = DATA.compareAndSet(100, 50);\n        System.out.println(Thread.currentThread().getName() + \"是否成功将DATA的值修改为50：\" + b);\n    }, \"线程2\").start();\n\n    new Thread(() -> {\n        try { Thread.sleep(2000); } catch (InterruptedException ignored) {}\n        boolean b = DATA.compareAndSet(50, 100);\n        System.out.println(Thread.currentThread().getName() + \"是否成功将DATA的值修改为100：\" + b);\n    }, \"线程3\").start();\n\n    //等待其他线程完成，为什么是2，因为一个是main线程，一个是后台的GC线程\n    while (Thread.activeCount() > 2) {\n        Thread.yield();\n    }\n    System.out.println(\"DATA最终的值为：\" + DATA.get());\n}\n```\n\n执行结果：\n\n```tex\n线程1是否成功将DATA的值修改为50：true\n线程3是否成功将DATA的值修改为100：true\n线程2是否成功将DATA的值修改为50：true\nDATA最终的值为：50\n```\n\n> ABA问题的解决方案\n\n这个问题就像是：有张三、李四两个单身狗，张三在某个时间段内找到女朋友但是又分手了，但没告诉李四，此时李四还是会在张三是单身狗的情况下带他去洗脚。解决方案就是：张三每次交女朋友都喜欢晒朋友圈，张三是李四的特别关心，每次张三发朋友圈都会提醒李四看。\n\nCAS是乐观锁，还记得MySQL中也有个乐观锁吗？MySQL中的乐观锁是每次修改完数据后，留下一个版本号，在每次被更新之后版本号会+1，即 `A->B->A` 就变成了 `1A->2B->3A` 。\n\n补充一点：\n\nInteger 的源码（IntegerCache） 里面用了缓存，会缓存[-128, 127] 区间的值，在使用 AtomicInteger 需要格外注意！很有可能值被修改成功后，下一次被get时，会因为缓存，而取到上一次的值。\n\n### CPU开销大\n\n在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。\n\n### 只能保证一个共享变量的原子操作\n\nCAS机制所保证的只是一个变量的原子性操作，而不能保证**整个代码块**的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized或Lock了。\n\n","source":"_posts/JUC-CAS.md","raw":"---\ntitle: CAS\ndate: 2021-08-22 12:49:26\ntags:\n- Juc并发包\ndescription: CAS全称Compare and swap（比较并替换），CAS虽然能很高效的解决原子操作，但CAS存在三大弊端：ABA问题、自旋时间长时浪费CPU、只能保证一个共享变量的原子操作。\n---\n\n线程的三大特性：原子性、有序性、可见性。\n\n- 原子性：一个或多个操作的程序执行视作一个整体，不可被分割，不可被中断，不可被外界干扰，也就是说同一时刻只能有一个线程来执行这些操作。\n\n- 有序性：程序按一定规则进行顺序的执行。\n\n- 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看的到修改的值。\n\n## 什么是CAS？\n\nCAS在Java出现，在Java中称为自旋锁。CAS类似于synchronized锁的功能，但两者原理不同。\n\nCAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。这样说或许有些抽象，我们来看一个例子：\n\n1. 在内存地址V当中，存储着值为10的变量。\n\n![img](JUC-CAS\\1193919-20180102142540362-571280295.png)\n\n2. 此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。\n\n![img](JUC-CAS\\1193919-20180102142542299-1617994496.png)\n\n3. 在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。\n\n![img](JUC-CAS/1193919-20180102142543784-1625100143.png)\n\n4. 线程1开始提交更新，首先进行**A和地址V的实际值比较（Compare）**，发现A不等于V的实际值，提交失败。\n\n![img](JUC-CAS/1193919-20180102142545221-837543615.png)\n\n5. 线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为**自旋**。\n\n![img](JUC-CAS/1193919-20180102142546909-270453852.png)\n\n6. 这一次比较幸运，没有其他线程改变地址V的值。线程1进行**Compare**，发现A和地址V的实际值是相等的。\n\n![img](JUC-CAS/1193919-20180102142548299-328053032-16464619321157.png)\n\n7. 线程1进行**SWAP**，把地址V的值替换为B，也就是12。\n\n![img](JUC-CAS/1193919-20180102142625753-443716413.png)\n\n从思想上来说，Synchronized属于**悲观锁**，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于**乐观锁**，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。\n\n## JDK中的CAS应用实例\n\n在JDK的 java.util.concurrent.atomic 包下，一系列以Atomic开头的包装类。如AtomicBoolean，AtomicInteger，AtomicLong。它们分别用于Boolean，Integer，Long类型的原子性操作。\n\ncompareAndSet利用JNI来完成CPU指令的操作。\n\n```java\npublic final boolean compareAndSet(int expect, int update) {   \n    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n}\n```\n\n\n\n## CAS的优点\n\n### 提升吞吐量\n\n线程一直处于活跃状态（非阻塞），不需要CPU进行频繁调度。\n\n### 可避免死锁\n\n不用 synchronized 或 Lock 当然就可以避免死锁。\n\n## CAS的弊端\n\n### ABA问题\n\n在并发环境下会出现的ABA问题是CAS机制中的一个严重弊端。\n\n> 什么是ABA问题？\n\n假设现在有一份资源初始值为A，此时有三个线程对这份资源进行CAS操作：\n\n- 线程1，期望值为A，欲更新值为B\n- 线程2，期望值为A，欲更新值为B\n- 线程3，期望值为B，欲更新值为A\n\n线程1率先抢到CPU时间片，线程2因为某些原因阻塞了；线程1取值与A比较，发现相等后将值改为B；此时线程3出现，线程3取值与B比较，发现相等后改为A；此时线程2从阻塞中恢复开始执行，线程2的取值与A对比相等，最终改为B。\n\n在这个过程中，线程2虽然完成了操作，但线程2并不知道该值经过了`A->B->A`的这个变化过程。\n\n看到这里可能对这个ABA问题还是没有感觉，再举个现实中的栗子：\n\n小明从他的巨额账户中已有的100元中取走50元，那他取走50后还剩50，假设提款机的代码有BUG，后台开了两个线程去扣款：\n\n- 线程1：获取当前值100，期望更新为50；\n- 线程2：获取当前值100，期望更新为50；\n- 线程1：执行成功，线程2某种原因阻塞了，此时某人给小明转账50，开一个线程3去处理转账。\n- 线程3：获取当前值50，期望更新为100，此时线程3执行成功，余额变为100。\n- 线程2：从阻塞中恢复，获取到的也是100，compare之后，继续更新余额为50！！！（小明哭唧唧）\n\n此时可以看到，正常情况下，小明从100元取走50还剩50，有人转账50过来，那最终小明的存款为100元。在这个案例中被这个提款机的ABA问题引发的BUG给弄掉了50块钱。\n\nABA问题的实例代码：\n\n```java\nstatic AtomicInteger DATA = new AtomicInteger(100);\npublic static void main(String[] args) {\n    new Thread(() -> {\n        // 抢到CPU时间片，开始工作\n        boolean b = DATA.compareAndSet(100, 50);\n        System.out.println(Thread.currentThread().getName() + \"是否成功将DATA的值修改为50：\" + b);\n        try { Thread.sleep(1000); } catch (InterruptedException ignored) {}\n    }, \"线程1\").start();\n\n    new Thread(() -> {\n        // 因某些原因阻塞了\n        try { Thread.sleep(3000); } catch (InterruptedException ignored) {}\n        // 阻塞后恢复工作\n        boolean b = DATA.compareAndSet(100, 50);\n        System.out.println(Thread.currentThread().getName() + \"是否成功将DATA的值修改为50：\" + b);\n    }, \"线程2\").start();\n\n    new Thread(() -> {\n        try { Thread.sleep(2000); } catch (InterruptedException ignored) {}\n        boolean b = DATA.compareAndSet(50, 100);\n        System.out.println(Thread.currentThread().getName() + \"是否成功将DATA的值修改为100：\" + b);\n    }, \"线程3\").start();\n\n    //等待其他线程完成，为什么是2，因为一个是main线程，一个是后台的GC线程\n    while (Thread.activeCount() > 2) {\n        Thread.yield();\n    }\n    System.out.println(\"DATA最终的值为：\" + DATA.get());\n}\n```\n\n执行结果：\n\n```tex\n线程1是否成功将DATA的值修改为50：true\n线程3是否成功将DATA的值修改为100：true\n线程2是否成功将DATA的值修改为50：true\nDATA最终的值为：50\n```\n\n> ABA问题的解决方案\n\n这个问题就像是：有张三、李四两个单身狗，张三在某个时间段内找到女朋友但是又分手了，但没告诉李四，此时李四还是会在张三是单身狗的情况下带他去洗脚。解决方案就是：张三每次交女朋友都喜欢晒朋友圈，张三是李四的特别关心，每次张三发朋友圈都会提醒李四看。\n\nCAS是乐观锁，还记得MySQL中也有个乐观锁吗？MySQL中的乐观锁是每次修改完数据后，留下一个版本号，在每次被更新之后版本号会+1，即 `A->B->A` 就变成了 `1A->2B->3A` 。\n\n补充一点：\n\nInteger 的源码（IntegerCache） 里面用了缓存，会缓存[-128, 127] 区间的值，在使用 AtomicInteger 需要格外注意！很有可能值被修改成功后，下一次被get时，会因为缓存，而取到上一次的值。\n\n### CPU开销大\n\n在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。\n\n### 只能保证一个共享变量的原子操作\n\nCAS机制所保证的只是一个变量的原子性操作，而不能保证**整个代码块**的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized或Lock了。\n\n","slug":"JUC-CAS","published":1,"updated":"2022-03-05T12:43:55.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0eqk39k0005o4u50rnwhnmh","content":"<p>线程的三大特性：原子性、有序性、可见性。</p>\n<ul>\n<li><p>原子性：一个或多个操作的程序执行视作一个整体，不可被分割，不可被中断，不可被外界干扰，也就是说同一时刻只能有一个线程来执行这些操作。</p>\n</li>\n<li><p>有序性：程序按一定规则进行顺序的执行。</p>\n</li>\n<li><p>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看的到修改的值。</p>\n</li>\n</ul>\n<h2 id=\"什么是CAS？\"><a href=\"#什么是CAS？\" class=\"headerlink\" title=\"什么是CAS？\"></a>什么是CAS？</h2><p>CAS在Java出现，在Java中称为自旋锁。CAS类似于synchronized锁的功能，但两者原理不同。</p>\n<p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。这样说或许有些抽象，我们来看一个例子：</p>\n<ol>\n<li>在内存地址V当中，存储着值为10的变量。</li>\n</ol>\n<p><img src=\"/JUC-CAS%5C1193919-20180102142540362-571280295.png\" alt=\"img\"></p>\n<ol start=\"2\">\n<li>此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</li>\n</ol>\n<p><img src=\"/JUC-CAS%5C1193919-20180102142542299-1617994496.png\" alt=\"img\"></p>\n<ol start=\"3\">\n<li>在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</li>\n</ol>\n<p><img src=\"/JUC-CAS/1193919-20180102142543784-1625100143.png\" alt=\"img\"></p>\n<ol start=\"4\">\n<li>线程1开始提交更新，首先进行<strong>A和地址V的实际值比较（Compare）</strong>，发现A不等于V的实际值，提交失败。</li>\n</ol>\n<p><img src=\"/JUC-CAS/1193919-20180102142545221-837543615.png\" alt=\"img\"></p>\n<ol start=\"5\">\n<li>线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为<strong>自旋</strong>。</li>\n</ol>\n<p><img src=\"/JUC-CAS/1193919-20180102142546909-270453852.png\" alt=\"img\"></p>\n<ol start=\"6\">\n<li>这一次比较幸运，没有其他线程改变地址V的值。线程1进行<strong>Compare</strong>，发现A和地址V的实际值是相等的。</li>\n</ol>\n<p><img src=\"/JUC-CAS/1193919-20180102142548299-328053032-16464619321157.png\" alt=\"img\"></p>\n<ol start=\"7\">\n<li>线程1进行<strong>SWAP</strong>，把地址V的值替换为B，也就是12。</li>\n</ol>\n<p><img src=\"/JUC-CAS/1193919-20180102142625753-443716413.png\" alt=\"img\"></p>\n<p>从思想上来说，Synchronized属于<strong>悲观锁</strong>，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于<strong>乐观锁</strong>，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>\n<h2 id=\"JDK中的CAS应用实例\"><a href=\"#JDK中的CAS应用实例\" class=\"headerlink\" title=\"JDK中的CAS应用实例\"></a>JDK中的CAS应用实例</h2><p>在JDK的 java.util.concurrent.atomic 包下，一系列以Atomic开头的包装类。如AtomicBoolean，AtomicInteger，AtomicLong。它们分别用于Boolean，Integer，Long类型的原子性操作。</p>\n<p>compareAndSet利用JNI来完成CPU指令的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSet</span><span class=\"params\">(<span class=\"type\">int</span> expect, <span class=\"type\">int</span> update)</span> &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"built_in\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"CAS的优点\"><a href=\"#CAS的优点\" class=\"headerlink\" title=\"CAS的优点\"></a>CAS的优点</h2><h3 id=\"提升吞吐量\"><a href=\"#提升吞吐量\" class=\"headerlink\" title=\"提升吞吐量\"></a>提升吞吐量</h3><p>线程一直处于活跃状态（非阻塞），不需要CPU进行频繁调度。</p>\n<h3 id=\"可避免死锁\"><a href=\"#可避免死锁\" class=\"headerlink\" title=\"可避免死锁\"></a>可避免死锁</h3><p>不用 synchronized 或 Lock 当然就可以避免死锁。</p>\n<h2 id=\"CAS的弊端\"><a href=\"#CAS的弊端\" class=\"headerlink\" title=\"CAS的弊端\"></a>CAS的弊端</h2><h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>在并发环境下会出现的ABA问题是CAS机制中的一个严重弊端。</p>\n<blockquote>\n<p>什么是ABA问题？</p>\n</blockquote>\n<p>假设现在有一份资源初始值为A，此时有三个线程对这份资源进行CAS操作：</p>\n<ul>\n<li>线程1，期望值为A，欲更新值为B</li>\n<li>线程2，期望值为A，欲更新值为B</li>\n<li>线程3，期望值为B，欲更新值为A</li>\n</ul>\n<p>线程1率先抢到CPU时间片，线程2因为某些原因阻塞了；线程1取值与A比较，发现相等后将值改为B；此时线程3出现，线程3取值与B比较，发现相等后改为A；此时线程2从阻塞中恢复开始执行，线程2的取值与A对比相等，最终改为B。</p>\n<p>在这个过程中，线程2虽然完成了操作，但线程2并不知道该值经过了<code>A-&gt;B-&gt;A</code>的这个变化过程。</p>\n<p>看到这里可能对这个ABA问题还是没有感觉，再举个现实中的栗子：</p>\n<p>小明从他的巨额账户中已有的100元中取走50元，那他取走50后还剩50，假设提款机的代码有BUG，后台开了两个线程去扣款：</p>\n<ul>\n<li>线程1：获取当前值100，期望更新为50；</li>\n<li>线程2：获取当前值100，期望更新为50；</li>\n<li>线程1：执行成功，线程2某种原因阻塞了，此时某人给小明转账50，开一个线程3去处理转账。</li>\n<li>线程3：获取当前值50，期望更新为100，此时线程3执行成功，余额变为100。</li>\n<li>线程2：从阻塞中恢复，获取到的也是100，compare之后，继续更新余额为50！！！（小明哭唧唧）</li>\n</ul>\n<p>此时可以看到，正常情况下，小明从100元取走50还剩50，有人转账50过来，那最终小明的存款为100元。在这个案例中被这个提款机的ABA问题引发的BUG给弄掉了50块钱。</p>\n<p>ABA问题的实例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">DATA</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 抢到CPU时间片，开始工作</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> DATA.compareAndSet(<span class=\"number\">100</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;是否成功将DATA的值修改为50：&quot;</span> + b);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; Thread.sleep(<span class=\"number\">1000</span>); &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;线程1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因某些原因阻塞了</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; Thread.sleep(<span class=\"number\">3000</span>); &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞后恢复工作</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> DATA.compareAndSet(<span class=\"number\">100</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;是否成功将DATA的值修改为50：&quot;</span> + b);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;线程2&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; Thread.sleep(<span class=\"number\">2000</span>); &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> DATA.compareAndSet(<span class=\"number\">50</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;是否成功将DATA的值修改为100：&quot;</span> + b);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;线程3&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//等待其他线程完成，为什么是2，因为一个是main线程，一个是后台的GC线程</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (Thread.activeCount() &gt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;DATA最终的值为：&quot;</span> + DATA.get());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程1是否成功将DATA的值修改为50：true</span><br><span class=\"line\">线程3是否成功将DATA的值修改为100：true</span><br><span class=\"line\">线程2是否成功将DATA的值修改为50：true</span><br><span class=\"line\">DATA最终的值为：50</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ABA问题的解决方案</p>\n</blockquote>\n<p>这个问题就像是：有张三、李四两个单身狗，张三在某个时间段内找到女朋友但是又分手了，但没告诉李四，此时李四还是会在张三是单身狗的情况下带他去洗脚。解决方案就是：张三每次交女朋友都喜欢晒朋友圈，张三是李四的特别关心，每次张三发朋友圈都会提醒李四看。</p>\n<p>CAS是乐观锁，还记得MySQL中也有个乐观锁吗？MySQL中的乐观锁是每次修改完数据后，留下一个版本号，在每次被更新之后版本号会+1，即 <code>A-&gt;B-&gt;A</code> 就变成了 <code>1A-&gt;2B-&gt;3A</code> 。</p>\n<p>补充一点：</p>\n<p>Integer 的源码（IntegerCache） 里面用了缓存，会缓存[-128, 127] 区间的值，在使用 AtomicInteger 需要格外注意！很有可能值被修改成功后，下一次被get时，会因为缓存，而取到上一次的值。</p>\n<h3 id=\"CPU开销大\"><a href=\"#CPU开销大\" class=\"headerlink\" title=\"CPU开销大\"></a>CPU开销大</h3><p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p>\n<h3 id=\"只能保证一个共享变量的原子操作\"><a href=\"#只能保证一个共享变量的原子操作\" class=\"headerlink\" title=\"只能保证一个共享变量的原子操作\"></a>只能保证一个共享变量的原子操作</h3><p>CAS机制所保证的只是一个变量的原子性操作，而不能保证<strong>整个代码块</strong>的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized或Lock了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>线程的三大特性：原子性、有序性、可见性。</p>\n<ul>\n<li><p>原子性：一个或多个操作的程序执行视作一个整体，不可被分割，不可被中断，不可被外界干扰，也就是说同一时刻只能有一个线程来执行这些操作。</p>\n</li>\n<li><p>有序性：程序按一定规则进行顺序的执行。</p>\n</li>\n<li><p>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看的到修改的值。</p>\n</li>\n</ul>\n<h2 id=\"什么是CAS？\"><a href=\"#什么是CAS？\" class=\"headerlink\" title=\"什么是CAS？\"></a>什么是CAS？</h2><p>CAS在Java出现，在Java中称为自旋锁。CAS类似于synchronized锁的功能，但两者原理不同。</p>\n<p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。这样说或许有些抽象，我们来看一个例子：</p>\n<ol>\n<li>在内存地址V当中，存储着值为10的变量。</li>\n</ol>\n<p><img src=\"/JUC-CAS%5C1193919-20180102142540362-571280295.png\" alt=\"img\"></p>\n<ol start=\"2\">\n<li>此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</li>\n</ol>\n<p><img src=\"/JUC-CAS%5C1193919-20180102142542299-1617994496.png\" alt=\"img\"></p>\n<ol start=\"3\">\n<li>在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</li>\n</ol>\n<p><img src=\"/JUC-CAS/1193919-20180102142543784-1625100143.png\" alt=\"img\"></p>\n<ol start=\"4\">\n<li>线程1开始提交更新，首先进行<strong>A和地址V的实际值比较（Compare）</strong>，发现A不等于V的实际值，提交失败。</li>\n</ol>\n<p><img src=\"/JUC-CAS/1193919-20180102142545221-837543615.png\" alt=\"img\"></p>\n<ol start=\"5\">\n<li>线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为<strong>自旋</strong>。</li>\n</ol>\n<p><img src=\"/JUC-CAS/1193919-20180102142546909-270453852.png\" alt=\"img\"></p>\n<ol start=\"6\">\n<li>这一次比较幸运，没有其他线程改变地址V的值。线程1进行<strong>Compare</strong>，发现A和地址V的实际值是相等的。</li>\n</ol>\n<p><img src=\"/JUC-CAS/1193919-20180102142548299-328053032-16464619321157.png\" alt=\"img\"></p>\n<ol start=\"7\">\n<li>线程1进行<strong>SWAP</strong>，把地址V的值替换为B，也就是12。</li>\n</ol>\n<p><img src=\"/JUC-CAS/1193919-20180102142625753-443716413.png\" alt=\"img\"></p>\n<p>从思想上来说，Synchronized属于<strong>悲观锁</strong>，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于<strong>乐观锁</strong>，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>\n<h2 id=\"JDK中的CAS应用实例\"><a href=\"#JDK中的CAS应用实例\" class=\"headerlink\" title=\"JDK中的CAS应用实例\"></a>JDK中的CAS应用实例</h2><p>在JDK的 java.util.concurrent.atomic 包下，一系列以Atomic开头的包装类。如AtomicBoolean，AtomicInteger，AtomicLong。它们分别用于Boolean，Integer，Long类型的原子性操作。</p>\n<p>compareAndSet利用JNI来完成CPU指令的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSet</span><span class=\"params\">(<span class=\"type\">int</span> expect, <span class=\"type\">int</span> update)</span> &#123;   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"built_in\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"CAS的优点\"><a href=\"#CAS的优点\" class=\"headerlink\" title=\"CAS的优点\"></a>CAS的优点</h2><h3 id=\"提升吞吐量\"><a href=\"#提升吞吐量\" class=\"headerlink\" title=\"提升吞吐量\"></a>提升吞吐量</h3><p>线程一直处于活跃状态（非阻塞），不需要CPU进行频繁调度。</p>\n<h3 id=\"可避免死锁\"><a href=\"#可避免死锁\" class=\"headerlink\" title=\"可避免死锁\"></a>可避免死锁</h3><p>不用 synchronized 或 Lock 当然就可以避免死锁。</p>\n<h2 id=\"CAS的弊端\"><a href=\"#CAS的弊端\" class=\"headerlink\" title=\"CAS的弊端\"></a>CAS的弊端</h2><h3 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h3><p>在并发环境下会出现的ABA问题是CAS机制中的一个严重弊端。</p>\n<blockquote>\n<p>什么是ABA问题？</p>\n</blockquote>\n<p>假设现在有一份资源初始值为A，此时有三个线程对这份资源进行CAS操作：</p>\n<ul>\n<li>线程1，期望值为A，欲更新值为B</li>\n<li>线程2，期望值为A，欲更新值为B</li>\n<li>线程3，期望值为B，欲更新值为A</li>\n</ul>\n<p>线程1率先抢到CPU时间片，线程2因为某些原因阻塞了；线程1取值与A比较，发现相等后将值改为B；此时线程3出现，线程3取值与B比较，发现相等后改为A；此时线程2从阻塞中恢复开始执行，线程2的取值与A对比相等，最终改为B。</p>\n<p>在这个过程中，线程2虽然完成了操作，但线程2并不知道该值经过了<code>A-&gt;B-&gt;A</code>的这个变化过程。</p>\n<p>看到这里可能对这个ABA问题还是没有感觉，再举个现实中的栗子：</p>\n<p>小明从他的巨额账户中已有的100元中取走50元，那他取走50后还剩50，假设提款机的代码有BUG，后台开了两个线程去扣款：</p>\n<ul>\n<li>线程1：获取当前值100，期望更新为50；</li>\n<li>线程2：获取当前值100，期望更新为50；</li>\n<li>线程1：执行成功，线程2某种原因阻塞了，此时某人给小明转账50，开一个线程3去处理转账。</li>\n<li>线程3：获取当前值50，期望更新为100，此时线程3执行成功，余额变为100。</li>\n<li>线程2：从阻塞中恢复，获取到的也是100，compare之后，继续更新余额为50！！！（小明哭唧唧）</li>\n</ul>\n<p>此时可以看到，正常情况下，小明从100元取走50还剩50，有人转账50过来，那最终小明的存款为100元。在这个案例中被这个提款机的ABA问题引发的BUG给弄掉了50块钱。</p>\n<p>ABA问题的实例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">DATA</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 抢到CPU时间片，开始工作</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> DATA.compareAndSet(<span class=\"number\">100</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;是否成功将DATA的值修改为50：&quot;</span> + b);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; Thread.sleep(<span class=\"number\">1000</span>); &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;线程1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因某些原因阻塞了</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; Thread.sleep(<span class=\"number\">3000</span>); &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞后恢复工作</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> DATA.compareAndSet(<span class=\"number\">100</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;是否成功将DATA的值修改为50：&quot;</span> + b);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;线程2&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; Thread.sleep(<span class=\"number\">2000</span>); &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> DATA.compareAndSet(<span class=\"number\">50</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;是否成功将DATA的值修改为100：&quot;</span> + b);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;线程3&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//等待其他线程完成，为什么是2，因为一个是main线程，一个是后台的GC线程</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (Thread.activeCount() &gt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;DATA最终的值为：&quot;</span> + DATA.get());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程1是否成功将DATA的值修改为50：true</span><br><span class=\"line\">线程3是否成功将DATA的值修改为100：true</span><br><span class=\"line\">线程2是否成功将DATA的值修改为50：true</span><br><span class=\"line\">DATA最终的值为：50</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ABA问题的解决方案</p>\n</blockquote>\n<p>这个问题就像是：有张三、李四两个单身狗，张三在某个时间段内找到女朋友但是又分手了，但没告诉李四，此时李四还是会在张三是单身狗的情况下带他去洗脚。解决方案就是：张三每次交女朋友都喜欢晒朋友圈，张三是李四的特别关心，每次张三发朋友圈都会提醒李四看。</p>\n<p>CAS是乐观锁，还记得MySQL中也有个乐观锁吗？MySQL中的乐观锁是每次修改完数据后，留下一个版本号，在每次被更新之后版本号会+1，即 <code>A-&gt;B-&gt;A</code> 就变成了 <code>1A-&gt;2B-&gt;3A</code> 。</p>\n<p>补充一点：</p>\n<p>Integer 的源码（IntegerCache） 里面用了缓存，会缓存[-128, 127] 区间的值，在使用 AtomicInteger 需要格外注意！很有可能值被修改成功后，下一次被get时，会因为缓存，而取到上一次的值。</p>\n<h3 id=\"CPU开销大\"><a href=\"#CPU开销大\" class=\"headerlink\" title=\"CPU开销大\"></a>CPU开销大</h3><p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p>\n<h3 id=\"只能保证一个共享变量的原子操作\"><a href=\"#只能保证一个共享变量的原子操作\" class=\"headerlink\" title=\"只能保证一个共享变量的原子操作\"></a>只能保证一个共享变量的原子操作</h3><p>CAS机制所保证的只是一个变量的原子性操作，而不能保证<strong>整个代码块</strong>的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized或Lock了。</p>\n"},{"title":"CPU优化性能的手段","date":"2021-08-22T04:51:12.000Z","_content":"\n为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。例如：CPU高速缓存。尽可能的避免处理器访问主存的时间开销，处理器大多会利用缓存来提高性能。\n\n## 多级缓存\n\n![CPU高速缓存级别](JUC-CPU-Performance-Optimization\\CPU高速缓存级别.png)\n\n### 等级划分\n\nCPU的缓存分为三个级别，离CPU越远等级越大：\n\n- L1 Cache(一级缓存)是CPU第一层高速缓存，分为**数据缓存**和**指令缓存**。一般服务器CPU的L1缓存容量通常在 32-4096KB（实在是太小了）。\n- L2 Cache(二级缓存) 由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一个高速存储器（由于在外部，有延迟导致速度还是不够快）。\n- L3 现在的都是内置的。L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时的处理器性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为，及较短消息和处理器队列长度。一般是多核共享一个L3缓存。\n\n### 缓存的同步协议\n\n多CPU读取同样的数据进行缓存，进行不同的运算之后，最终写入主内存，那么以哪个CPU为准？\n\n这些 CPU 厂商就制定了一个缓存一致性的协议，就是 MESI协议，规定每条缓存有一个状态位，同时定义了四个状态：\n\n- 修改态(Modified) ：此cache行已被修改过(脏行)，内容已不同于主存，为此cache专有\n\n- 专有态(Exclusive)：此cache行内容同于主存，但不出现于其他cache中；\n\n- 共享态(Shared)：此cache行内容同于主存，但也出现于其他cache中；\n\n- 无效态(Invalid)：此cache行内容无效(空行)；\n\n\n多处理器时，单个CPU对缓存中数据进行了改动，需通知给其他CPU。也就是说，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证数据的**最终一致**。\n\n缓存中的数据与主存的数据并不是实时同步的，各CPU核心间的缓存数据也不是实时同步的。在同一时间点，各个CPU所看到同一内存地址的数据可能是不一致的，就会存在线程安全问题。\n\n## 指令重排\n\n当CPU**写缓存时**发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的**读缓存命令优先执行**。\n\n![image-20220305180930700](JUC-CPU-Performance-Optimization/image-20220305180930700.png)\n\n**重排需要遵循 as-if-serial 语义**：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。也就是说：编译器和处理器**不会对存在数据依赖关系的操作做重排序**。\n\n`as-if-serial语义`把单线程程序保护了起来，换句话说：`as-if-serial语义`仅在单CPU单线程的情况下能保证结果正确。多核多线程中，指令逻辑无法分辨因果关系，可能会出现**乱序执行**，导致程序运行结果错误，就会存在线程安全问题。\n\n## 内存屏障\n\n不论是缓存同步还是指令重排，都是线程不安全的。\n\n处理器提供了两个内存屏障指令(Memory Barrier)用于解决缓存同步和指令重排的问题。 \n\n- 读内存屏障(Load Memory Barrier)：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。\n\n- 写内存屏障(Store Memory Barrier)：在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。\n\n","source":"_posts/JUC-CPU-Performance-Optimization.md","raw":"---\ntitle: CPU优化性能的手段\ndate: 2021-08-22 12:51:12\ntags:\n- Juc并发包\n---\n\n为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。例如：CPU高速缓存。尽可能的避免处理器访问主存的时间开销，处理器大多会利用缓存来提高性能。\n\n## 多级缓存\n\n![CPU高速缓存级别](JUC-CPU-Performance-Optimization\\CPU高速缓存级别.png)\n\n### 等级划分\n\nCPU的缓存分为三个级别，离CPU越远等级越大：\n\n- L1 Cache(一级缓存)是CPU第一层高速缓存，分为**数据缓存**和**指令缓存**。一般服务器CPU的L1缓存容量通常在 32-4096KB（实在是太小了）。\n- L2 Cache(二级缓存) 由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一个高速存储器（由于在外部，有延迟导致速度还是不够快）。\n- L3 现在的都是内置的。L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时的处理器性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为，及较短消息和处理器队列长度。一般是多核共享一个L3缓存。\n\n### 缓存的同步协议\n\n多CPU读取同样的数据进行缓存，进行不同的运算之后，最终写入主内存，那么以哪个CPU为准？\n\n这些 CPU 厂商就制定了一个缓存一致性的协议，就是 MESI协议，规定每条缓存有一个状态位，同时定义了四个状态：\n\n- 修改态(Modified) ：此cache行已被修改过(脏行)，内容已不同于主存，为此cache专有\n\n- 专有态(Exclusive)：此cache行内容同于主存，但不出现于其他cache中；\n\n- 共享态(Shared)：此cache行内容同于主存，但也出现于其他cache中；\n\n- 无效态(Invalid)：此cache行内容无效(空行)；\n\n\n多处理器时，单个CPU对缓存中数据进行了改动，需通知给其他CPU。也就是说，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证数据的**最终一致**。\n\n缓存中的数据与主存的数据并不是实时同步的，各CPU核心间的缓存数据也不是实时同步的。在同一时间点，各个CPU所看到同一内存地址的数据可能是不一致的，就会存在线程安全问题。\n\n## 指令重排\n\n当CPU**写缓存时**发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的**读缓存命令优先执行**。\n\n![image-20220305180930700](JUC-CPU-Performance-Optimization/image-20220305180930700.png)\n\n**重排需要遵循 as-if-serial 语义**：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。也就是说：编译器和处理器**不会对存在数据依赖关系的操作做重排序**。\n\n`as-if-serial语义`把单线程程序保护了起来，换句话说：`as-if-serial语义`仅在单CPU单线程的情况下能保证结果正确。多核多线程中，指令逻辑无法分辨因果关系，可能会出现**乱序执行**，导致程序运行结果错误，就会存在线程安全问题。\n\n## 内存屏障\n\n不论是缓存同步还是指令重排，都是线程不安全的。\n\n处理器提供了两个内存屏障指令(Memory Barrier)用于解决缓存同步和指令重排的问题。 \n\n- 读内存屏障(Load Memory Barrier)：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。\n\n- 写内存屏障(Store Memory Barrier)：在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。\n\n","slug":"JUC-CPU-Performance-Optimization","published":1,"updated":"2022-03-05T12:44:11.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0eqk39l0006o4u5hxrv8vmr","content":"<p>为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。例如：CPU高速缓存。尽可能的避免处理器访问主存的时间开销，处理器大多会利用缓存来提高性能。</p>\n<h2 id=\"多级缓存\"><a href=\"#多级缓存\" class=\"headerlink\" title=\"多级缓存\"></a>多级缓存</h2><p><img src=\"/JUC-CPU-Performance-Optimization%5CCPU%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%BA%A7%E5%88%AB.png\" alt=\"CPU高速缓存级别\"></p>\n<h3 id=\"等级划分\"><a href=\"#等级划分\" class=\"headerlink\" title=\"等级划分\"></a>等级划分</h3><p>CPU的缓存分为三个级别，离CPU越远等级越大：</p>\n<ul>\n<li>L1 Cache(一级缓存)是CPU第一层高速缓存，分为<strong>数据缓存</strong>和<strong>指令缓存</strong>。一般服务器CPU的L1缓存容量通常在 32-4096KB（实在是太小了）。</li>\n<li>L2 Cache(二级缓存) 由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一个高速存储器（由于在外部，有延迟导致速度还是不够快）。</li>\n<li>L3 现在的都是内置的。L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时的处理器性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为，及较短消息和处理器队列长度。一般是多核共享一个L3缓存。</li>\n</ul>\n<h3 id=\"缓存的同步协议\"><a href=\"#缓存的同步协议\" class=\"headerlink\" title=\"缓存的同步协议\"></a>缓存的同步协议</h3><p>多CPU读取同样的数据进行缓存，进行不同的运算之后，最终写入主内存，那么以哪个CPU为准？</p>\n<p>这些 CPU 厂商就制定了一个缓存一致性的协议，就是 MESI协议，规定每条缓存有一个状态位，同时定义了四个状态：</p>\n<ul>\n<li><p>修改态(Modified) ：此cache行已被修改过(脏行)，内容已不同于主存，为此cache专有</p>\n</li>\n<li><p>专有态(Exclusive)：此cache行内容同于主存，但不出现于其他cache中；</p>\n</li>\n<li><p>共享态(Shared)：此cache行内容同于主存，但也出现于其他cache中；</p>\n</li>\n<li><p>无效态(Invalid)：此cache行内容无效(空行)；</p>\n</li>\n</ul>\n<p>多处理器时，单个CPU对缓存中数据进行了改动，需通知给其他CPU。也就是说，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证数据的<strong>最终一致</strong>。</p>\n<p>缓存中的数据与主存的数据并不是实时同步的，各CPU核心间的缓存数据也不是实时同步的。在同一时间点，各个CPU所看到同一内存地址的数据可能是不一致的，就会存在线程安全问题。</p>\n<h2 id=\"指令重排\"><a href=\"#指令重排\" class=\"headerlink\" title=\"指令重排\"></a>指令重排</h2><p>当CPU<strong>写缓存时</strong>发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的<strong>读缓存命令优先执行</strong>。</p>\n<p><img src=\"/JUC-CPU-Performance-Optimization/image-20220305180930700.png\" alt=\"image-20220305180930700\"></p>\n<p><strong>重排需要遵循 as-if-serial 语义</strong>：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。也就是说：编译器和处理器<strong>不会对存在数据依赖关系的操作做重排序</strong>。</p>\n<p><code>as-if-serial语义</code>把单线程程序保护了起来，换句话说：<code>as-if-serial语义</code>仅在单CPU单线程的情况下能保证结果正确。多核多线程中，指令逻辑无法分辨因果关系，可能会出现<strong>乱序执行</strong>，导致程序运行结果错误，就会存在线程安全问题。</p>\n<h2 id=\"内存屏障\"><a href=\"#内存屏障\" class=\"headerlink\" title=\"内存屏障\"></a>内存屏障</h2><p>不论是缓存同步还是指令重排，都是线程不安全的。</p>\n<p>处理器提供了两个内存屏障指令(Memory Barrier)用于解决缓存同步和指令重排的问题。 </p>\n<ul>\n<li><p>读内存屏障(Load Memory Barrier)：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。</p>\n</li>\n<li><p>写内存屏障(Store Memory Barrier)：在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>为了提高程序运行的性能，现代CPU在很多方面对程序进行了优化。例如：CPU高速缓存。尽可能的避免处理器访问主存的时间开销，处理器大多会利用缓存来提高性能。</p>\n<h2 id=\"多级缓存\"><a href=\"#多级缓存\" class=\"headerlink\" title=\"多级缓存\"></a>多级缓存</h2><p><img src=\"/JUC-CPU-Performance-Optimization%5CCPU%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%BA%A7%E5%88%AB.png\" alt=\"CPU高速缓存级别\"></p>\n<h3 id=\"等级划分\"><a href=\"#等级划分\" class=\"headerlink\" title=\"等级划分\"></a>等级划分</h3><p>CPU的缓存分为三个级别，离CPU越远等级越大：</p>\n<ul>\n<li>L1 Cache(一级缓存)是CPU第一层高速缓存，分为<strong>数据缓存</strong>和<strong>指令缓存</strong>。一般服务器CPU的L1缓存容量通常在 32-4096KB（实在是太小了）。</li>\n<li>L2 Cache(二级缓存) 由于L1级高速缓存容量的限制，为了再次提高CPU的运算速度，在CPU外部放置一个高速存储器（由于在外部，有延迟导致速度还是不够快）。</li>\n<li>L3 现在的都是内置的。L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时的处理器性能。具有较大L3缓存的处理器提供更有效的文件系统缓存行为，及较短消息和处理器队列长度。一般是多核共享一个L3缓存。</li>\n</ul>\n<h3 id=\"缓存的同步协议\"><a href=\"#缓存的同步协议\" class=\"headerlink\" title=\"缓存的同步协议\"></a>缓存的同步协议</h3><p>多CPU读取同样的数据进行缓存，进行不同的运算之后，最终写入主内存，那么以哪个CPU为准？</p>\n<p>这些 CPU 厂商就制定了一个缓存一致性的协议，就是 MESI协议，规定每条缓存有一个状态位，同时定义了四个状态：</p>\n<ul>\n<li><p>修改态(Modified) ：此cache行已被修改过(脏行)，内容已不同于主存，为此cache专有</p>\n</li>\n<li><p>专有态(Exclusive)：此cache行内容同于主存，但不出现于其他cache中；</p>\n</li>\n<li><p>共享态(Shared)：此cache行内容同于主存，但也出现于其他cache中；</p>\n</li>\n<li><p>无效态(Invalid)：此cache行内容无效(空行)；</p>\n</li>\n</ul>\n<p>多处理器时，单个CPU对缓存中数据进行了改动，需通知给其他CPU。也就是说，CPU处理要控制自己的读写操作，还要监听其他CPU发出的通知，从而保证数据的<strong>最终一致</strong>。</p>\n<p>缓存中的数据与主存的数据并不是实时同步的，各CPU核心间的缓存数据也不是实时同步的。在同一时间点，各个CPU所看到同一内存地址的数据可能是不一致的，就会存在线程安全问题。</p>\n<h2 id=\"指令重排\"><a href=\"#指令重排\" class=\"headerlink\" title=\"指令重排\"></a>指令重排</h2><p>当CPU<strong>写缓存时</strong>发现缓存区块正被其他CPU占用，为了提高CPU处理性能，可能将后面的<strong>读缓存命令优先执行</strong>。</p>\n<p><img src=\"/JUC-CPU-Performance-Optimization/image-20220305180930700.png\" alt=\"image-20220305180930700\"></p>\n<p><strong>重排需要遵循 as-if-serial 语义</strong>：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。也就是说：编译器和处理器<strong>不会对存在数据依赖关系的操作做重排序</strong>。</p>\n<p><code>as-if-serial语义</code>把单线程程序保护了起来，换句话说：<code>as-if-serial语义</code>仅在单CPU单线程的情况下能保证结果正确。多核多线程中，指令逻辑无法分辨因果关系，可能会出现<strong>乱序执行</strong>，导致程序运行结果错误，就会存在线程安全问题。</p>\n<h2 id=\"内存屏障\"><a href=\"#内存屏障\" class=\"headerlink\" title=\"内存屏障\"></a>内存屏障</h2><p>不论是缓存同步还是指令重排，都是线程不安全的。</p>\n<p>处理器提供了两个内存屏障指令(Memory Barrier)用于解决缓存同步和指令重排的问题。 </p>\n<ul>\n<li><p>读内存屏障(Load Memory Barrier)：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。强制读取主内存内容，让CPU缓存与主内存保持一致，避免了缓存导致的一致性问题。</p>\n</li>\n<li><p>写内存屏障(Store Memory Barrier)：在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。强制写入主内存，这种显示调用，CPU就不会因为性能考虑而去对指令重排。</p>\n</li>\n</ul>\n"},{"title":"Callable接口","date":"2022-03-04T06:28:34.000Z","_content":"\nCallable是一个无入参，有返回值，可抛异常的一个接口。\n\n源码如下：\n\n```java\n@FunctionalInterface\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n\n// Runnable接口既无返回值，也无入参，不能抛异常\n@FunctionalInterface\npublic interface Runnable {\n    abstract void run();\n}\n```\n\n通常用于带返回值的线程，在线程执行完毕后回调一下这个接口，实现 Callable\\<T\\> 接口创建线程示例：\n\n```java\npublic class ThreadCallable {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        // FutureTask是个适配类，适配器模式\n        FutureTask<String> futureTask = new FutureTask<>(new MyThread0403());\n        new Thread(futureTask,\"A\").start();\n        String result = futureTask.get();\n        System.out.println(result);\n    }\n}\n\n// 实现 Callable<T> 接口\nclass MyThread0403 implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        System.out.println(Thread.currentThread().getName()+\"--->Call()\");\n        return \"1024\";\n    }\n}\n```\n\n**FutureTask**\n\nFutureTask 实现了RunnableFuture接口，对Runnable接口和Callable接口的线程做了适配。\n\n```java\npublic class FutureTask<V> implements RunnableFuture<V> {}\n\n// RunnableFuture接口继承与Runnable，FutureTask间接的实现了Runnable接口\npublic interface RunnableFuture<V> extends Runnable, Future<V> {}\n```\n\nFutureTask 是可取消式的异步计算，该类提供了一个Future的基本实现，具有启动和取消计算的方法，查询计算是否完整，并检索计算结果。 结果只能在计算完成后才能检索; 如果计算尚未完成，则get方法将阻止。 一旦计算完成，则无法重新启动或取消计算（除非使用 runAndReset() 方法调用计算 ）。 \n\n","source":"_posts/JUC-Callable.md","raw":"---\ntitle: Callable接口\ndate: 2022-03-04 14:28:34\ntags:\n  - Juc并发包\n---\n\nCallable是一个无入参，有返回值，可抛异常的一个接口。\n\n源码如下：\n\n```java\n@FunctionalInterface\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n\n// Runnable接口既无返回值，也无入参，不能抛异常\n@FunctionalInterface\npublic interface Runnable {\n    abstract void run();\n}\n```\n\n通常用于带返回值的线程，在线程执行完毕后回调一下这个接口，实现 Callable\\<T\\> 接口创建线程示例：\n\n```java\npublic class ThreadCallable {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        // FutureTask是个适配类，适配器模式\n        FutureTask<String> futureTask = new FutureTask<>(new MyThread0403());\n        new Thread(futureTask,\"A\").start();\n        String result = futureTask.get();\n        System.out.println(result);\n    }\n}\n\n// 实现 Callable<T> 接口\nclass MyThread0403 implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        System.out.println(Thread.currentThread().getName()+\"--->Call()\");\n        return \"1024\";\n    }\n}\n```\n\n**FutureTask**\n\nFutureTask 实现了RunnableFuture接口，对Runnable接口和Callable接口的线程做了适配。\n\n```java\npublic class FutureTask<V> implements RunnableFuture<V> {}\n\n// RunnableFuture接口继承与Runnable，FutureTask间接的实现了Runnable接口\npublic interface RunnableFuture<V> extends Runnable, Future<V> {}\n```\n\nFutureTask 是可取消式的异步计算，该类提供了一个Future的基本实现，具有启动和取消计算的方法，查询计算是否完整，并检索计算结果。 结果只能在计算完成后才能检索; 如果计算尚未完成，则get方法将阻止。 一旦计算完成，则无法重新启动或取消计算（除非使用 runAndReset() 方法调用计算 ）。 \n\n","slug":"JUC-Callable","published":1,"updated":"2022-03-05T14:35:45.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0eqk39l0007o4u5dbivhmlv","content":"<p>Callable是一个无入参，有返回值，可抛异常的一个接口。</p>\n<p>源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Callable</span>&lt;V&gt; &#123;</span><br><span class=\"line\">    V <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Runnable接口既无返回值，也无入参，不能抛异常</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常用于带返回值的线程，在线程执行完毕后回调一下这个接口，实现 Callable&lt;T&gt; 接口创建线程示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadCallable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// FutureTask是个适配类，适配器模式</span></span><br><span class=\"line\">        FutureTask&lt;String&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyThread0403</span>());</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask,<span class=\"string\">&quot;A&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> futureTask.get();</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现 Callable&lt;T&gt; 接口</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread0403</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Callable</span>&lt;String&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;---&gt;Call()&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;1024&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>FutureTask</strong></p>\n<p>FutureTask 实现了RunnableFuture接口，对Runnable接口和Callable接口的线程做了适配。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FutureTask</span>&lt;V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">RunnableFuture</span>&lt;V&gt; &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RunnableFuture接口继承与Runnable，FutureTask间接的实现了Runnable接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RunnableFuture</span>&lt;V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Runnable</span>, Future&lt;V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>FutureTask 是可取消式的异步计算，该类提供了一个Future的基本实现，具有启动和取消计算的方法，查询计算是否完整，并检索计算结果。 结果只能在计算完成后才能检索; 如果计算尚未完成，则get方法将阻止。 一旦计算完成，则无法重新启动或取消计算（除非使用 runAndReset() 方法调用计算 ）。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>Callable是一个无入参，有返回值，可抛异常的一个接口。</p>\n<p>源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Callable</span>&lt;V&gt; &#123;</span><br><span class=\"line\">    V <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Runnable接口既无返回值，也无入参，不能抛异常</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常用于带返回值的线程，在线程执行完毕后回调一下这个接口，实现 Callable&lt;T&gt; 接口创建线程示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadCallable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// FutureTask是个适配类，适配器模式</span></span><br><span class=\"line\">        FutureTask&lt;String&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyThread0403</span>());</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask,<span class=\"string\">&quot;A&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> futureTask.get();</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现 Callable&lt;T&gt; 接口</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread0403</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Callable</span>&lt;String&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;---&gt;Call()&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;1024&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>FutureTask</strong></p>\n<p>FutureTask 实现了RunnableFuture接口，对Runnable接口和Callable接口的线程做了适配。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FutureTask</span>&lt;V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">RunnableFuture</span>&lt;V&gt; &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RunnableFuture接口继承与Runnable，FutureTask间接的实现了Runnable接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">RunnableFuture</span>&lt;V&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Runnable</span>, Future&lt;V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>FutureTask 是可取消式的异步计算，该类提供了一个Future的基本实现，具有启动和取消计算的方法，查询计算是否完整，并检索计算结果。 结果只能在计算完成后才能检索; 如果计算尚未完成，则get方法将阻止。 一旦计算完成，则无法重新启动或取消计算（除非使用 runAndReset() 方法调用计算 ）。 </p>\n"},{"title":"ForkJoin","date":"2021-08-22T04:49:54.000Z","_content":"\nForkJoinPool 是ExecutorService 接口的实现，它专为可以递归分解成小块的工作而设计。Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务（Runnable）：把一个大任务拆成多个小任务并行处理，最后将子任务结果合并成最后的计算结果。充分利用多线程处理器的优势，提高程序性能。\n\n![forkJoin](JUC-ForkJoin\\ForkJoin.png)\n\n## 高性能低冲突\n\n- 每个Worker线程都维护一个任务队列，即ForkJoinWorkerThread中的任务队列；\n\n- ForkJoin维护的任务队列是双端队列（DeQueue），可以同时支持LIFO（先进后出）和FIFO（先进先出）；\n\n- 子任务会被加入到原先任务所在 Worker 线程的任务队列；\n\n- 当任务队列为空时，线程会随机从其他的 Worker 的队列中拿走一个任务执行（工作窃取：steal work），工作窃取带来的性能提升偏理论，API的复杂性较高，实际研发中可控性来说不如其他API。\n\n## 缺点\n\n- 如果一个 Worker 线程遇到了 join 操作，而这时候正在处理其他任务，会等到这个任务结束。否则直接返回；\n\n- 如果一个 Worker 线程窃取任务失败，它会调用 yield 或者 sleep 之类的方法休息一会儿，再尝试（如果所有线程都是空闲状态，即没有任务执行，那么该线程也会进入阻塞状态等待新任务的到来）；\n\n## 适用场景\n\n- 使用尽可能少的线程池，在大多数情况下，最好的决定是为每个应用程序或系统使用一个线程池；\n\n- 如果不需要特定调整，请使用默认的公共线程池；\n\n- 使用合理的阈值将ForkJoinTask拆分为子任务；\n\n- **避免在ForkJoinTask中出现任何阻塞（例如耗时IO，大量查询数据库、网络请求等）；**\n\n- 适合数据处理、结果汇总、统计等场景；\n\njava8实例：java.utilArrays类用于其 parallelSort() 方法；\n\n## 应用示例\n\n例如，下面将从 0 加到 10_0000_0000：\n\n```java\npublic void test1() {\n    long start = System.currentTimeMillis();\n    long sum = 0;\n    for (long i = 0; i < 10_0000_0000L; i++) {\n        sum += i;\n    }\n    System.out.println(sum + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\");// 耗时：361ms\n}\n```\n\n使用 ForkJoinPool 执行该任务：\n\n```java\npublic void test2() throws ExecutionException, InterruptedException {\n    long start = System.currentTimeMillis();\n\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinTask<Long> task = new Task04051(0L, 10_0000_0000L);\n    ForkJoinTask<Long> submit = pool.submit(task);\n    Long result = submit.get();\n\n    System.out.println(result + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\"); // 耗时：186ms\n}\n```\n\n使用  stream 并行执行任务：\n\n```java\npublic void test3() {\n    long start = System.currentTimeMillis();\n\t// 与 LongStream 类似的有DoubleStream、IntegerStream 等\n    long sum = LongStream.rangeClosed(0L, num).parallel().reduce(0, Long::sum);\n\n    System.out.println(sum + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\");// 耗时：126ms\n}\n```\n\n","source":"_posts/JUC-ForkJoin.md","raw":"---\ntitle: ForkJoin\ndate: 2021-08-22 12:49:54\ntags:\n  - Juc并发包\n---\n\nForkJoinPool 是ExecutorService 接口的实现，它专为可以递归分解成小块的工作而设计。Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务（Runnable）：把一个大任务拆成多个小任务并行处理，最后将子任务结果合并成最后的计算结果。充分利用多线程处理器的优势，提高程序性能。\n\n![forkJoin](JUC-ForkJoin\\ForkJoin.png)\n\n## 高性能低冲突\n\n- 每个Worker线程都维护一个任务队列，即ForkJoinWorkerThread中的任务队列；\n\n- ForkJoin维护的任务队列是双端队列（DeQueue），可以同时支持LIFO（先进后出）和FIFO（先进先出）；\n\n- 子任务会被加入到原先任务所在 Worker 线程的任务队列；\n\n- 当任务队列为空时，线程会随机从其他的 Worker 的队列中拿走一个任务执行（工作窃取：steal work），工作窃取带来的性能提升偏理论，API的复杂性较高，实际研发中可控性来说不如其他API。\n\n## 缺点\n\n- 如果一个 Worker 线程遇到了 join 操作，而这时候正在处理其他任务，会等到这个任务结束。否则直接返回；\n\n- 如果一个 Worker 线程窃取任务失败，它会调用 yield 或者 sleep 之类的方法休息一会儿，再尝试（如果所有线程都是空闲状态，即没有任务执行，那么该线程也会进入阻塞状态等待新任务的到来）；\n\n## 适用场景\n\n- 使用尽可能少的线程池，在大多数情况下，最好的决定是为每个应用程序或系统使用一个线程池；\n\n- 如果不需要特定调整，请使用默认的公共线程池；\n\n- 使用合理的阈值将ForkJoinTask拆分为子任务；\n\n- **避免在ForkJoinTask中出现任何阻塞（例如耗时IO，大量查询数据库、网络请求等）；**\n\n- 适合数据处理、结果汇总、统计等场景；\n\njava8实例：java.utilArrays类用于其 parallelSort() 方法；\n\n## 应用示例\n\n例如，下面将从 0 加到 10_0000_0000：\n\n```java\npublic void test1() {\n    long start = System.currentTimeMillis();\n    long sum = 0;\n    for (long i = 0; i < 10_0000_0000L; i++) {\n        sum += i;\n    }\n    System.out.println(sum + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\");// 耗时：361ms\n}\n```\n\n使用 ForkJoinPool 执行该任务：\n\n```java\npublic void test2() throws ExecutionException, InterruptedException {\n    long start = System.currentTimeMillis();\n\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinTask<Long> task = new Task04051(0L, 10_0000_0000L);\n    ForkJoinTask<Long> submit = pool.submit(task);\n    Long result = submit.get();\n\n    System.out.println(result + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\"); // 耗时：186ms\n}\n```\n\n使用  stream 并行执行任务：\n\n```java\npublic void test3() {\n    long start = System.currentTimeMillis();\n\t// 与 LongStream 类似的有DoubleStream、IntegerStream 等\n    long sum = LongStream.rangeClosed(0L, num).parallel().reduce(0, Long::sum);\n\n    System.out.println(sum + \",耗时：\" + (System.currentTimeMillis() - start) + \"ms\");// 耗时：126ms\n}\n```\n\n","slug":"JUC-ForkJoin","published":1,"updated":"2022-03-05T12:44:22.899Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0eqk39m000ao4u51ifqb9pg","content":"<p>ForkJoinPool 是ExecutorService 接口的实现，它专为可以递归分解成小块的工作而设计。Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务（Runnable）：把一个大任务拆成多个小任务并行处理，最后将子任务结果合并成最后的计算结果。充分利用多线程处理器的优势，提高程序性能。</p>\n<p><img src=\"/JUC-ForkJoin%5CForkJoin.png\" alt=\"forkJoin\"></p>\n<h2 id=\"高性能低冲突\"><a href=\"#高性能低冲突\" class=\"headerlink\" title=\"高性能低冲突\"></a>高性能低冲突</h2><ul>\n<li><p>每个Worker线程都维护一个任务队列，即ForkJoinWorkerThread中的任务队列；</p>\n</li>\n<li><p>ForkJoin维护的任务队列是双端队列（DeQueue），可以同时支持LIFO（先进后出）和FIFO（先进先出）；</p>\n</li>\n<li><p>子任务会被加入到原先任务所在 Worker 线程的任务队列；</p>\n</li>\n<li><p>当任务队列为空时，线程会随机从其他的 Worker 的队列中拿走一个任务执行（工作窃取：steal work），工作窃取带来的性能提升偏理论，API的复杂性较高，实际研发中可控性来说不如其他API。</p>\n</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li><p>如果一个 Worker 线程遇到了 join 操作，而这时候正在处理其他任务，会等到这个任务结束。否则直接返回；</p>\n</li>\n<li><p>如果一个 Worker 线程窃取任务失败，它会调用 yield 或者 sleep 之类的方法休息一会儿，再尝试（如果所有线程都是空闲状态，即没有任务执行，那么该线程也会进入阻塞状态等待新任务的到来）；</p>\n</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><ul>\n<li><p>使用尽可能少的线程池，在大多数情况下，最好的决定是为每个应用程序或系统使用一个线程池；</p>\n</li>\n<li><p>如果不需要特定调整，请使用默认的公共线程池；</p>\n</li>\n<li><p>使用合理的阈值将ForkJoinTask拆分为子任务；</p>\n</li>\n<li><p><strong>避免在ForkJoinTask中出现任何阻塞（例如耗时IO，大量查询数据库、网络请求等）；</strong></p>\n</li>\n<li><p>适合数据处理、结果汇总、统计等场景；</p>\n</li>\n</ul>\n<p>java8实例：java.utilArrays类用于其 parallelSort() 方法；</p>\n<h2 id=\"应用示例\"><a href=\"#应用示例\" class=\"headerlink\" title=\"应用示例\"></a>应用示例</h2><p>例如，下面将从 0 加到 10_0000_0000：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10_0000_0000L</span>; i++) &#123;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(sum + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>);<span class=\"comment\">// 耗时：361ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 ForkJoinPool 执行该任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ForkJoinPool</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinPool</span>();</span><br><span class=\"line\">    ForkJoinTask&lt;Long&gt; task = <span class=\"keyword\">new</span> <span class=\"title class_\">Task04051</span>(<span class=\"number\">0L</span>, <span class=\"number\">10_0000_0000L</span>);</span><br><span class=\"line\">    ForkJoinTask&lt;Long&gt; submit = pool.submit(task);</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> submit.get();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(result + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>); <span class=\"comment\">// 耗时：186ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用  stream 并行执行任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">\t<span class=\"comment\">// 与 LongStream 类似的有DoubleStream、IntegerStream 等</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> LongStream.rangeClosed(<span class=\"number\">0L</span>, num).parallel().reduce(<span class=\"number\">0</span>, Long::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(sum + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>);<span class=\"comment\">// 耗时：126ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>ForkJoinPool 是ExecutorService 接口的实现，它专为可以递归分解成小块的工作而设计。Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务（Runnable）：把一个大任务拆成多个小任务并行处理，最后将子任务结果合并成最后的计算结果。充分利用多线程处理器的优势，提高程序性能。</p>\n<p><img src=\"/JUC-ForkJoin%5CForkJoin.png\" alt=\"forkJoin\"></p>\n<h2 id=\"高性能低冲突\"><a href=\"#高性能低冲突\" class=\"headerlink\" title=\"高性能低冲突\"></a>高性能低冲突</h2><ul>\n<li><p>每个Worker线程都维护一个任务队列，即ForkJoinWorkerThread中的任务队列；</p>\n</li>\n<li><p>ForkJoin维护的任务队列是双端队列（DeQueue），可以同时支持LIFO（先进后出）和FIFO（先进先出）；</p>\n</li>\n<li><p>子任务会被加入到原先任务所在 Worker 线程的任务队列；</p>\n</li>\n<li><p>当任务队列为空时，线程会随机从其他的 Worker 的队列中拿走一个任务执行（工作窃取：steal work），工作窃取带来的性能提升偏理论，API的复杂性较高，实际研发中可控性来说不如其他API。</p>\n</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li><p>如果一个 Worker 线程遇到了 join 操作，而这时候正在处理其他任务，会等到这个任务结束。否则直接返回；</p>\n</li>\n<li><p>如果一个 Worker 线程窃取任务失败，它会调用 yield 或者 sleep 之类的方法休息一会儿，再尝试（如果所有线程都是空闲状态，即没有任务执行，那么该线程也会进入阻塞状态等待新任务的到来）；</p>\n</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><ul>\n<li><p>使用尽可能少的线程池，在大多数情况下，最好的决定是为每个应用程序或系统使用一个线程池；</p>\n</li>\n<li><p>如果不需要特定调整，请使用默认的公共线程池；</p>\n</li>\n<li><p>使用合理的阈值将ForkJoinTask拆分为子任务；</p>\n</li>\n<li><p><strong>避免在ForkJoinTask中出现任何阻塞（例如耗时IO，大量查询数据库、网络请求等）；</strong></p>\n</li>\n<li><p>适合数据处理、结果汇总、统计等场景；</p>\n</li>\n</ul>\n<p>java8实例：java.utilArrays类用于其 parallelSort() 方法；</p>\n<h2 id=\"应用示例\"><a href=\"#应用示例\" class=\"headerlink\" title=\"应用示例\"></a>应用示例</h2><p>例如，下面将从 0 加到 10_0000_0000：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10_0000_0000L</span>; i++) &#123;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(sum + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>);<span class=\"comment\">// 耗时：361ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 ForkJoinPool 执行该任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ForkJoinPool</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinPool</span>();</span><br><span class=\"line\">    ForkJoinTask&lt;Long&gt; task = <span class=\"keyword\">new</span> <span class=\"title class_\">Task04051</span>(<span class=\"number\">0L</span>, <span class=\"number\">10_0000_0000L</span>);</span><br><span class=\"line\">    ForkJoinTask&lt;Long&gt; submit = pool.submit(task);</span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> submit.get();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(result + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>); <span class=\"comment\">// 耗时：186ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用  stream 并行执行任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">\t<span class=\"comment\">// 与 LongStream 类似的有DoubleStream、IntegerStream 等</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> LongStream.rangeClosed(<span class=\"number\">0L</span>, num).parallel().reduce(<span class=\"number\">0</span>, Long::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(sum + <span class=\"string\">&quot;,耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class=\"string\">&quot;ms&quot;</span>);<span class=\"comment\">// 耗时：126ms</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"四种单例模式","date":"2021-08-22T04:12:55.000Z","_content":"\n其实在学Spring5源码的时候，就已经罗列了各种单例模式。在此，学习过 java.util.concurrent 包后，站在多线程的角度上分析比较经典的懒汉模式的双重锁校验（又称为DCL懒汉式（Double Check Lock））。\n\n## 逐步进阶，基础版本\n\n```java\nprivate static LazySingleton singleton4;\n\nprivate static LazySingleton lazy() {\n    if (singleton4 == null) {\n        singleton4 = new LazySingleton();\n    }\n    return singleton4;\n}\n```\n\n存在问题分析：多线程进行访问时，可能多个线程会同时进入if 的作用域中，那么就会创建多个 LazySingleton() 对象，导致这些线程返回的对象地址不一致。\n\n## 普通加锁版本\n\n直接方法加锁，确实能够解决问题，但是性能十分低下。\n\n```java\nprivate static LazySingleton singleton4;\n\nprivate synchronized static LazySingleton lazy() {\n    if (singleton4 == null) {\n        singleton4 = new LazySingleton();\n    }\n    return singleton4;\n}\n```\n\n## 双重校验加锁版本\n\n​\t\t多线程都可以进入方法和第一个 if 的作用域，锁类的目的是保证只能有一个线程进入当前类后进入第二个if作用域创建实例对象，随后解锁，让其它进入第一个if作用域的阻塞线程在判断一次是否为空。\n​\t\t虽然性能是提升了，但是真的线程安全吗？并发下的指令重排是会出问题的，分析： singleton4 = new LazySingleton() 不是原子性操作，有三个步骤： ①分配内存空间 ②执行构造方法并实例化对象 ③ 分配内存地址，把这个对象指向这个空间。CPU执行时不一定是按照123执行的，如果按照执行顺序是132，第3步先执行的话，还没有完成实例化，就指向这个空间了，此时的 singleton4 不为空，下一个线程进入方法的第一个if判断走false，直接返回这个对象，此时的这个 singleton4 并没有完成实例化！所以就会导致数据不一致的问题。\n\n​\tvolatile 有三大特性：1、可见性；2、禁止指令重排；3、不保证原子性。所以使用volatile 关键字修饰即可。\n\n```java\nprivate volatile static LazySingleton singleton4;\n\nprivate static LazySingleton lazy2() throws InterruptedException {\n    if (singleton4 == null) {\n        synchronized (LazySingleton.class) {\n            if (singleton4 == null) {\n                singleton4 = new LazySingleton();\n            }\n            return singleton4;\n        }\n    }\n    return singleton4;\n}\n```\n\n## 单例模式被破坏的情况\n\n破坏单例模式的意思就是：一个单例对象存在多个。\n\n反射、序列化、克隆都会破坏单例模式。\n\n解决方案：枚举单例模式、容器式单例模式（ConcurrentHashMap）、线程隔离式单例模式（ThreadLocal）\n\n尝试破坏枚举单例模式：\n\n```java\nprivate enum Lazy4 {\n    INSTANCE;\n\n    public static Lazy4 getInstance() {\n        return INSTANCE;\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n        Lazy4 instance1 = Lazy4.INSTANCE;\n        Constructor<Lazy4> declaredConstructor = Lazy4.class.getDeclaredConstructor(String.class, int.class);\n        declaredConstructor.setAccessible(true);\n        Lazy4 instance2 = declaredConstructor.newInstance(); \n        System.out.println(instance1); System.out.println(instance2);\n    }\n```\n\n","source":"_posts/JUC-SingletonPattern.md","raw":"---\ntitle: 四种单例模式\ndate: 2021-08-22 12:12:55\ntags:\n - Juc并发包\n---\n\n其实在学Spring5源码的时候，就已经罗列了各种单例模式。在此，学习过 java.util.concurrent 包后，站在多线程的角度上分析比较经典的懒汉模式的双重锁校验（又称为DCL懒汉式（Double Check Lock））。\n\n## 逐步进阶，基础版本\n\n```java\nprivate static LazySingleton singleton4;\n\nprivate static LazySingleton lazy() {\n    if (singleton4 == null) {\n        singleton4 = new LazySingleton();\n    }\n    return singleton4;\n}\n```\n\n存在问题分析：多线程进行访问时，可能多个线程会同时进入if 的作用域中，那么就会创建多个 LazySingleton() 对象，导致这些线程返回的对象地址不一致。\n\n## 普通加锁版本\n\n直接方法加锁，确实能够解决问题，但是性能十分低下。\n\n```java\nprivate static LazySingleton singleton4;\n\nprivate synchronized static LazySingleton lazy() {\n    if (singleton4 == null) {\n        singleton4 = new LazySingleton();\n    }\n    return singleton4;\n}\n```\n\n## 双重校验加锁版本\n\n​\t\t多线程都可以进入方法和第一个 if 的作用域，锁类的目的是保证只能有一个线程进入当前类后进入第二个if作用域创建实例对象，随后解锁，让其它进入第一个if作用域的阻塞线程在判断一次是否为空。\n​\t\t虽然性能是提升了，但是真的线程安全吗？并发下的指令重排是会出问题的，分析： singleton4 = new LazySingleton() 不是原子性操作，有三个步骤： ①分配内存空间 ②执行构造方法并实例化对象 ③ 分配内存地址，把这个对象指向这个空间。CPU执行时不一定是按照123执行的，如果按照执行顺序是132，第3步先执行的话，还没有完成实例化，就指向这个空间了，此时的 singleton4 不为空，下一个线程进入方法的第一个if判断走false，直接返回这个对象，此时的这个 singleton4 并没有完成实例化！所以就会导致数据不一致的问题。\n\n​\tvolatile 有三大特性：1、可见性；2、禁止指令重排；3、不保证原子性。所以使用volatile 关键字修饰即可。\n\n```java\nprivate volatile static LazySingleton singleton4;\n\nprivate static LazySingleton lazy2() throws InterruptedException {\n    if (singleton4 == null) {\n        synchronized (LazySingleton.class) {\n            if (singleton4 == null) {\n                singleton4 = new LazySingleton();\n            }\n            return singleton4;\n        }\n    }\n    return singleton4;\n}\n```\n\n## 单例模式被破坏的情况\n\n破坏单例模式的意思就是：一个单例对象存在多个。\n\n反射、序列化、克隆都会破坏单例模式。\n\n解决方案：枚举单例模式、容器式单例模式（ConcurrentHashMap）、线程隔离式单例模式（ThreadLocal）\n\n尝试破坏枚举单例模式：\n\n```java\nprivate enum Lazy4 {\n    INSTANCE;\n\n    public static Lazy4 getInstance() {\n        return INSTANCE;\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n        Lazy4 instance1 = Lazy4.INSTANCE;\n        Constructor<Lazy4> declaredConstructor = Lazy4.class.getDeclaredConstructor(String.class, int.class);\n        declaredConstructor.setAccessible(true);\n        Lazy4 instance2 = declaredConstructor.newInstance(); \n        System.out.println(instance1); System.out.println(instance2);\n    }\n```\n\n","slug":"JUC-SingletonPattern","published":1,"updated":"2022-03-05T12:44:46.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0eqk39o000bo4u5hbvmgtig","content":"<p>其实在学Spring5源码的时候，就已经罗列了各种单例模式。在此，学习过 java.util.concurrent 包后，站在多线程的角度上分析比较经典的懒汉模式的双重锁校验（又称为DCL懒汉式（Double Check Lock））。</p>\n<h2 id=\"逐步进阶，基础版本\"><a href=\"#逐步进阶，基础版本\" class=\"headerlink\" title=\"逐步进阶，基础版本\"></a>逐步进阶，基础版本</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>存在问题分析：多线程进行访问时，可能多个线程会同时进入if 的作用域中，那么就会创建多个 LazySingleton() 对象，导致这些线程返回的对象地址不一致。</p>\n<h2 id=\"普通加锁版本\"><a href=\"#普通加锁版本\" class=\"headerlink\" title=\"普通加锁版本\"></a>普通加锁版本</h2><p>直接方法加锁，确实能够解决问题，但是性能十分低下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"双重校验加锁版本\"><a href=\"#双重校验加锁版本\" class=\"headerlink\" title=\"双重校验加锁版本\"></a>双重校验加锁版本</h2><p>​        多线程都可以进入方法和第一个 if 的作用域，锁类的目的是保证只能有一个线程进入当前类后进入第二个if作用域创建实例对象，随后解锁，让其它进入第一个if作用域的阻塞线程在判断一次是否为空。<br>​        虽然性能是提升了，但是真的线程安全吗？并发下的指令重排是会出问题的，分析： singleton4 = new LazySingleton() 不是原子性操作，有三个步骤： ①分配内存空间 ②执行构造方法并实例化对象 ③ 分配内存地址，把这个对象指向这个空间。CPU执行时不一定是按照123执行的，如果按照执行顺序是132，第3步先执行的话，还没有完成实例化，就指向这个空间了，此时的 singleton4 不为空，下一个线程进入方法的第一个if判断走false，直接返回这个对象，此时的这个 singleton4 并没有完成实例化！所以就会导致数据不一致的问题。</p>\n<p>​    volatile 有三大特性：1、可见性；2、禁止指令重排；3、不保证原子性。所以使用volatile 关键字修饰即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (LazySingleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单例模式被破坏的情况\"><a href=\"#单例模式被破坏的情况\" class=\"headerlink\" title=\"单例模式被破坏的情况\"></a>单例模式被破坏的情况</h2><p>破坏单例模式的意思就是：一个单例对象存在多个。</p>\n<p>反射、序列化、克隆都会破坏单例模式。</p>\n<p>解决方案：枚举单例模式、容器式单例模式（ConcurrentHashMap）、线程隔离式单例模式（ThreadLocal）</p>\n<p>尝试破坏枚举单例模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Lazy4</span> &#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Lazy4 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Lazy4</span> <span class=\"variable\">instance1</span> <span class=\"operator\">=</span> Lazy4.INSTANCE;</span><br><span class=\"line\">        Constructor&lt;Lazy4&gt; declaredConstructor = Lazy4.class.getDeclaredConstructor(String.class, <span class=\"type\">int</span>.class);</span><br><span class=\"line\">        declaredConstructor.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"type\">Lazy4</span> <span class=\"variable\">instance2</span> <span class=\"operator\">=</span> declaredConstructor.newInstance(); </span><br><span class=\"line\">        System.out.println(instance1); System.out.println(instance2);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>其实在学Spring5源码的时候，就已经罗列了各种单例模式。在此，学习过 java.util.concurrent 包后，站在多线程的角度上分析比较经典的懒汉模式的双重锁校验（又称为DCL懒汉式（Double Check Lock））。</p>\n<h2 id=\"逐步进阶，基础版本\"><a href=\"#逐步进阶，基础版本\" class=\"headerlink\" title=\"逐步进阶，基础版本\"></a>逐步进阶，基础版本</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>存在问题分析：多线程进行访问时，可能多个线程会同时进入if 的作用域中，那么就会创建多个 LazySingleton() 对象，导致这些线程返回的对象地址不一致。</p>\n<h2 id=\"普通加锁版本\"><a href=\"#普通加锁版本\" class=\"headerlink\" title=\"普通加锁版本\"></a>普通加锁版本</h2><p>直接方法加锁，确实能够解决问题，但是性能十分低下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"双重校验加锁版本\"><a href=\"#双重校验加锁版本\" class=\"headerlink\" title=\"双重校验加锁版本\"></a>双重校验加锁版本</h2><p>​        多线程都可以进入方法和第一个 if 的作用域，锁类的目的是保证只能有一个线程进入当前类后进入第二个if作用域创建实例对象，随后解锁，让其它进入第一个if作用域的阻塞线程在判断一次是否为空。<br>​        虽然性能是提升了，但是真的线程安全吗？并发下的指令重排是会出问题的，分析： singleton4 = new LazySingleton() 不是原子性操作，有三个步骤： ①分配内存空间 ②执行构造方法并实例化对象 ③ 分配内存地址，把这个对象指向这个空间。CPU执行时不一定是按照123执行的，如果按照执行顺序是132，第3步先执行的话，还没有完成实例化，就指向这个空间了，此时的 singleton4 不为空，下一个线程进入方法的第一个if判断走false，直接返回这个对象，此时的这个 singleton4 并没有完成实例化！所以就会导致数据不一致的问题。</p>\n<p>​    volatile 有三大特性：1、可见性；2、禁止指令重排；3、不保证原子性。所以使用volatile 关键字修饰即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> LazySingleton singleton4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title function_\">lazy2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (LazySingleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (singleton4 == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                singleton4 = <span class=\"keyword\">new</span> <span class=\"title class_\">LazySingleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单例模式被破坏的情况\"><a href=\"#单例模式被破坏的情况\" class=\"headerlink\" title=\"单例模式被破坏的情况\"></a>单例模式被破坏的情况</h2><p>破坏单例模式的意思就是：一个单例对象存在多个。</p>\n<p>反射、序列化、克隆都会破坏单例模式。</p>\n<p>解决方案：枚举单例模式、容器式单例模式（ConcurrentHashMap）、线程隔离式单例模式（ThreadLocal）</p>\n<p>尝试破坏枚举单例模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Lazy4</span> &#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Lazy4 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Lazy4</span> <span class=\"variable\">instance1</span> <span class=\"operator\">=</span> Lazy4.INSTANCE;</span><br><span class=\"line\">        Constructor&lt;Lazy4&gt; declaredConstructor = Lazy4.class.getDeclaredConstructor(String.class, <span class=\"type\">int</span>.class);</span><br><span class=\"line\">        declaredConstructor.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"type\">Lazy4</span> <span class=\"variable\">instance2</span> <span class=\"operator\">=</span> declaredConstructor.newInstance(); </span><br><span class=\"line\">        System.out.println(instance1); System.out.println(instance2);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"优雅的中断线程","date":"2021-04-12T08:20:43.000Z","_content":"\n不推荐使用 stop、suspend、resume 这三个过期作废的方法，因为有可能会发生不可预料的结果而且出现错误后还比较难定位。\n\n不推荐使用 Thread.stop() 的原因。这个方法是从外面让线程**强制停止**，如果停止的线程持有一个临界锁， 把一个对象置于一个不一致的状态（包含临界、持久化、游离），说白了就是造成数据不一致的结果。大多数情况下，停止一个线程使用  Thread.interrupt() 方法，但是这个方法不会终止一个正在运行状态的线程，还需要加入一些判断才能完成停止线程。\n\n在Java中有3种方式停止正在运行的线程：\n\n​\t\t1、使用退出标志，正常退出；\n\n​\t\t2、使用 stop()， 强行终止；\n\n​\t\t3、使用 interrupt() 方法，中断线程；\n\n## interrupt() 初体验\n\n​\t一上来就按照下面这种方式运行：\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n        myThread.interrupt();\n        System.out.println(\"mrdjun\");\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        for (int i = 0; i < 1000000; i++) {\n            System.out.println(\"i=\" + (i + 1));\n        }\n    }\n}\n```\n\n发现结果输出了 **1000000** 行，而且 mrdjun 还输出在了中间，说明 interrupt 并没有让线程停下来。\n\n## 判断线程是否为停止状态\n\n​\t下面Java提供了两个判断线程是否为停止状态的方法。\n\n​\tpublic static boolean interrupted() ：使用 Thread.interrupted() 测试当前线程是否已经中断，执行后清楚状态标志值为 false 的功能。\n\n​\tpublic boolean this.isInterrupted()： 测试 this 关键字所在类的对象是否已经中断，不清楚标志。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n        myThread.interrupt(); // 作用于 myThread 对象\n        // isInterrupted 测试当前线程是否已经中断\n        System.out.println(\"线程是否停止？\"+myThread.isInterrupted());\n        System.out.println(\"线程是否停止？\"+myThread.isInterrupted());\n    }\n}\n```\n\n​\t\t补充一点：也可以使用 Thread.interrupted() 来判断当前线程是否已经中断，因为在 Thread.java 这个类中调用静态static方法的时候，大多数是针对 currentThread() 线程进行操作的。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n      \tThread.currentThread().interrupt(); // 作用于 Thread\n        // isInterrupted 测试当前线程是否已经中断\n        System.out.println(\"线程是否停止？\"+ Thread.interrupted()); // 输出 true\n        System.out.println(\"线程是否停止？\"+ Thread.interrupted()); // 输出 false\n        System.out.println(\"END!\");\n    }\n}\n```\n\n出乎意料的是结果输出不一致，查看官方帮助文档中的 interrupted() 解释：\n\n> 测试当前线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。\n\nisInterrupted() 的方法声明如下：\n\n``` java\npublic boolean isInterrupted();\n```\n\n很显然，这个方法不是一个static方法，作用于这个方法的对象，如下。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n\t    myThread.interrupt();\n        System.out.println(\"线程是否停止？\" + myThread.isInterrupted()); // 输出 true\n        System.out.println(\"线程是否停止？\" + myThread.isInterrupted()); // 输出 true\n        System.out.println(\"END!\");\n    }\n}\n```\n\n综上所述，两者区别如下：\n\n（1）Thread.interrupted() 测试线程是否已经中断，执行后具有清除状态标志值为false的功能；\n\n（2）new Thread().isInterrupted() 测试线程Thread对象是否已经是中断状态，不清除状态标志；\n\n## 能停止的线程——异常法\n\n​\t在main方法中两秒后调用 Thread 对象的 myThread.interrupt() 方法，在线程中的for循环中加入 if 判断后面的代码是否可以运行。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(500);\n        myThread.interrupt();\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        try {\n            for (int i = 0; i < 5000000; i++) {\n                if (interrupted()) {\n                    System.out.println(\"线程已经停止\");\n                    // 退出当前循环，如果为 return; 或 throw new InterruptedException() 则直接退出当前线程\n                    throw new InterruptedException();\n                }\n                System.out.println(\"i=\" + (i + 1));\n            }\n            System.out.println(\"for循环外面的语句\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n抛出异常方式详情：\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) {\n        try {\n            MyThread myThread = new MyThread();\n            myThread.start();\n            Thread.sleep(1000);\n            myThread.interrupt();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        try {\n            for (int i = 0; i < 5000000; i++) {\n                if (interrupted()) {\n                    System.out.println(\"线程已经停止\");\n                    throw new InterruptedException();\n                }\n                System.out.println(\"i=\" + (i + 1));\n            }\n            System.out.println(\"for循环外面的语句\");\n        } catch (Exception e) {\n            System.out.println(\"抛出异常\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n通过下面的运行结果可以看出，线程终于被正确的停止了。\n\n```java\ni=312961\ni=312962\n线程已经停止\n抛出异常\njava.lang.InterruptedException\n\tat com.fun.async.test.class03.MyThread.run(ThreadInterrupt.java:34)\n```\n\n## 在 sleep 状态下停止线程\n\n``` java\npublic class SleepThreadInterrupt {\n    public static void main(String[] args) {\n        try {\n            MyThread thread = new MyThread();\n            thread.start();\n            Thread.sleep(200); // 先sleep 在调用 interrupt\n            thread.interrupt();\n            System.out.println(\"complete!\");\n        } catch (InterruptedException e) {\n            System.out.println(\"main catch\");\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread extends Thread{\n        @Override\n        public void run() {\n            super.run();\n            try {\n                System.out.println(\"run start ...\");\n                Thread.sleep(200000);\n                System.out.println(\"run end!\");\n            } catch (InterruptedException e) {\n                System.out.println(\"在sleep中停止，进入catch！\"+this.isInterrupted());\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n从下面的输出结果来看，如果线程在 sleep 状态下停止，则该线程会进入 catch 语句，并且清除停止状态值，变成false。\n\n``` java\nrun start ...\ncomplete!\n在sleep中停止，进入catch！false\njava.lang.InterruptedException: sleep interrupted\n\tat java.lang.Thread.sleep(Native Method)\n\tat com.fun.async.test.class03.SleepThreadInterrupt$MyThread.run(SleepThreadInterrupt.java:26)\n\n```\n","source":"_posts/JUC-Thread-interrupt.md","raw":"---\ntitle: 优雅的中断线程\ndate: 2021-04-12 16:20:43\ntags:\n- Juc并发包\n---\n\n不推荐使用 stop、suspend、resume 这三个过期作废的方法，因为有可能会发生不可预料的结果而且出现错误后还比较难定位。\n\n不推荐使用 Thread.stop() 的原因。这个方法是从外面让线程**强制停止**，如果停止的线程持有一个临界锁， 把一个对象置于一个不一致的状态（包含临界、持久化、游离），说白了就是造成数据不一致的结果。大多数情况下，停止一个线程使用  Thread.interrupt() 方法，但是这个方法不会终止一个正在运行状态的线程，还需要加入一些判断才能完成停止线程。\n\n在Java中有3种方式停止正在运行的线程：\n\n​\t\t1、使用退出标志，正常退出；\n\n​\t\t2、使用 stop()， 强行终止；\n\n​\t\t3、使用 interrupt() 方法，中断线程；\n\n## interrupt() 初体验\n\n​\t一上来就按照下面这种方式运行：\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n        myThread.interrupt();\n        System.out.println(\"mrdjun\");\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        for (int i = 0; i < 1000000; i++) {\n            System.out.println(\"i=\" + (i + 1));\n        }\n    }\n}\n```\n\n发现结果输出了 **1000000** 行，而且 mrdjun 还输出在了中间，说明 interrupt 并没有让线程停下来。\n\n## 判断线程是否为停止状态\n\n​\t下面Java提供了两个判断线程是否为停止状态的方法。\n\n​\tpublic static boolean interrupted() ：使用 Thread.interrupted() 测试当前线程是否已经中断，执行后清楚状态标志值为 false 的功能。\n\n​\tpublic boolean this.isInterrupted()： 测试 this 关键字所在类的对象是否已经中断，不清楚标志。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n        myThread.interrupt(); // 作用于 myThread 对象\n        // isInterrupted 测试当前线程是否已经中断\n        System.out.println(\"线程是否停止？\"+myThread.isInterrupted());\n        System.out.println(\"线程是否停止？\"+myThread.isInterrupted());\n    }\n}\n```\n\n​\t\t补充一点：也可以使用 Thread.interrupted() 来判断当前线程是否已经中断，因为在 Thread.java 这个类中调用静态static方法的时候，大多数是针对 currentThread() 线程进行操作的。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n      \tThread.currentThread().interrupt(); // 作用于 Thread\n        // isInterrupted 测试当前线程是否已经中断\n        System.out.println(\"线程是否停止？\"+ Thread.interrupted()); // 输出 true\n        System.out.println(\"线程是否停止？\"+ Thread.interrupted()); // 输出 false\n        System.out.println(\"END!\");\n    }\n}\n```\n\n出乎意料的是结果输出不一致，查看官方帮助文档中的 interrupted() 解释：\n\n> 测试当前线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。\n\nisInterrupted() 的方法声明如下：\n\n``` java\npublic boolean isInterrupted();\n```\n\n很显然，这个方法不是一个static方法，作用于这个方法的对象，如下。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(1000);\n\t    myThread.interrupt();\n        System.out.println(\"线程是否停止？\" + myThread.isInterrupted()); // 输出 true\n        System.out.println(\"线程是否停止？\" + myThread.isInterrupted()); // 输出 true\n        System.out.println(\"END!\");\n    }\n}\n```\n\n综上所述，两者区别如下：\n\n（1）Thread.interrupted() 测试线程是否已经中断，执行后具有清除状态标志值为false的功能；\n\n（2）new Thread().isInterrupted() 测试线程Thread对象是否已经是中断状态，不清除状态标志；\n\n## 能停止的线程——异常法\n\n​\t在main方法中两秒后调用 Thread 对象的 myThread.interrupt() 方法，在线程中的for循环中加入 if 判断后面的代码是否可以运行。\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread();\n        myThread.start();\n        Thread.sleep(500);\n        myThread.interrupt();\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        try {\n            for (int i = 0; i < 5000000; i++) {\n                if (interrupted()) {\n                    System.out.println(\"线程已经停止\");\n                    // 退出当前循环，如果为 return; 或 throw new InterruptedException() 则直接退出当前线程\n                    throw new InterruptedException();\n                }\n                System.out.println(\"i=\" + (i + 1));\n            }\n            System.out.println(\"for循环外面的语句\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n抛出异常方式详情：\n\n``` java\npublic class ThreadInterrupt {\n    public static void main(String[] args) {\n        try {\n            MyThread myThread = new MyThread();\n            myThread.start();\n            Thread.sleep(1000);\n            myThread.interrupt();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        super.run();\n        try {\n            for (int i = 0; i < 5000000; i++) {\n                if (interrupted()) {\n                    System.out.println(\"线程已经停止\");\n                    throw new InterruptedException();\n                }\n                System.out.println(\"i=\" + (i + 1));\n            }\n            System.out.println(\"for循环外面的语句\");\n        } catch (Exception e) {\n            System.out.println(\"抛出异常\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n通过下面的运行结果可以看出，线程终于被正确的停止了。\n\n```java\ni=312961\ni=312962\n线程已经停止\n抛出异常\njava.lang.InterruptedException\n\tat com.fun.async.test.class03.MyThread.run(ThreadInterrupt.java:34)\n```\n\n## 在 sleep 状态下停止线程\n\n``` java\npublic class SleepThreadInterrupt {\n    public static void main(String[] args) {\n        try {\n            MyThread thread = new MyThread();\n            thread.start();\n            Thread.sleep(200); // 先sleep 在调用 interrupt\n            thread.interrupt();\n            System.out.println(\"complete!\");\n        } catch (InterruptedException e) {\n            System.out.println(\"main catch\");\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread extends Thread{\n        @Override\n        public void run() {\n            super.run();\n            try {\n                System.out.println(\"run start ...\");\n                Thread.sleep(200000);\n                System.out.println(\"run end!\");\n            } catch (InterruptedException e) {\n                System.out.println(\"在sleep中停止，进入catch！\"+this.isInterrupted());\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n从下面的输出结果来看，如果线程在 sleep 状态下停止，则该线程会进入 catch 语句，并且清除停止状态值，变成false。\n\n``` java\nrun start ...\ncomplete!\n在sleep中停止，进入catch！false\njava.lang.InterruptedException: sleep interrupted\n\tat java.lang.Thread.sleep(Native Method)\n\tat com.fun.async.test.class03.SleepThreadInterrupt$MyThread.run(SleepThreadInterrupt.java:26)\n\n```\n","slug":"JUC-Thread-interrupt","published":1,"updated":"2022-03-06T04:17:30.697Z","_id":"cl0eqk39p000eo4u5hzwac9e3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>不推荐使用 stop、suspend、resume 这三个过期作废的方法，因为有可能会发生不可预料的结果而且出现错误后还比较难定位。</p>\n<p>不推荐使用 Thread.stop() 的原因。这个方法是从外面让线程<strong>强制停止</strong>，如果停止的线程持有一个临界锁， 把一个对象置于一个不一致的状态（包含临界、持久化、游离），说白了就是造成数据不一致的结果。大多数情况下，停止一个线程使用  Thread.interrupt() 方法，但是这个方法不会终止一个正在运行状态的线程，还需要加入一些判断才能完成停止线程。</p>\n<p>在Java中有3种方式停止正在运行的线程：</p>\n<p>​        1、使用退出标志，正常退出；</p>\n<p>​        2、使用 stop()， 强行终止；</p>\n<p>​        3、使用 interrupt() 方法，中断线程；</p>\n<h2 id=\"interrupt-初体验\"><a href=\"#interrupt-初体验\" class=\"headerlink\" title=\"interrupt() 初体验\"></a>interrupt() 初体验</h2><p>​    一上来就按照下面这种方式运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        myThread.interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;mrdjun&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现结果输出了 <strong>1000000</strong> 行，而且 mrdjun 还输出在了中间，说明 interrupt 并没有让线程停下来。</p>\n<h2 id=\"判断线程是否为停止状态\"><a href=\"#判断线程是否为停止状态\" class=\"headerlink\" title=\"判断线程是否为停止状态\"></a>判断线程是否为停止状态</h2><p>​    下面Java提供了两个判断线程是否为停止状态的方法。</p>\n<p>​    public static boolean interrupted() ：使用 Thread.interrupted() 测试当前线程是否已经中断，执行后清楚状态标志值为 false 的功能。</p>\n<p>​    public boolean this.isInterrupted()： 测试 this 关键字所在类的对象是否已经中断，不清楚标志。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        myThread.interrupt(); <span class=\"comment\">// 作用于 myThread 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// isInterrupted 测试当前线程是否已经中断</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+myThread.isInterrupted());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+myThread.isInterrupted());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        补充一点：也可以使用 Thread.interrupted() 来判断当前线程是否已经中断，因为在 Thread.java 这个类中调用静态static方法的时候，大多数是针对 currentThread() 线程进行操作的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">      \tThread.currentThread().interrupt(); <span class=\"comment\">// 作用于 Thread</span></span><br><span class=\"line\">        <span class=\"comment\">// isInterrupted 测试当前线程是否已经中断</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+ Thread.interrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+ Thread.interrupted()); <span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;END!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>出乎意料的是结果输出不一致，查看官方帮助文档中的 interrupted() 解释：</p>\n<blockquote>\n<p>测试当前线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。</p>\n</blockquote>\n<p>isInterrupted() 的方法声明如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isInterrupted</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>很显然，这个方法不是一个static方法，作用于这个方法的对象，如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t    myThread.interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span> + myThread.isInterrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span> + myThread.isInterrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;END!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>综上所述，两者区别如下：</p>\n<p>（1）Thread.interrupted() 测试线程是否已经中断，执行后具有清除状态标志值为false的功能；</p>\n<p>（2）new Thread().isInterrupted() 测试线程Thread对象是否已经是中断状态，不清除状态标志；</p>\n<h2 id=\"能停止的线程——异常法\"><a href=\"#能停止的线程——异常法\" class=\"headerlink\" title=\"能停止的线程——异常法\"></a>能停止的线程——异常法</h2><p>​    在main方法中两秒后调用 Thread 对象的 myThread.interrupt() 方法，在线程中的for循环中加入 if 判断后面的代码是否可以运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        myThread.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000000</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (interrupted()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;线程已经停止&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 退出当前循环，如果为 return; 或 throw new InterruptedException() 则直接退出当前线程</span></span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterruptedException</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;for循环外面的语句&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抛出异常方式详情：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">            myThread.start();</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            myThread.interrupt();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000000</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (interrupted()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;线程已经停止&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterruptedException</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;for循环外面的语句&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;抛出异常&quot;</span>);</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过下面的运行结果可以看出，线程终于被正确的停止了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i=<span class=\"number\">312961</span></span><br><span class=\"line\">i=<span class=\"number\">312962</span></span><br><span class=\"line\">线程已经停止</span><br><span class=\"line\">抛出异常</span><br><span class=\"line\">java.lang.InterruptedException</span><br><span class=\"line\">\tat com.fun.async.test.class03.MyThread.run(ThreadInterrupt.java:<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在-sleep-状态下停止线程\"><a href=\"#在-sleep-状态下停止线程\" class=\"headerlink\" title=\"在 sleep 状态下停止线程\"></a>在 sleep 状态下停止线程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SleepThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">MyThread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">200</span>); <span class=\"comment\">// 先sleep 在调用 interrupt</span></span><br><span class=\"line\">            thread.interrupt();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;complete!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;main catch&quot;</span>);</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;run start ...&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">200000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;run end!&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;在sleep中停止，进入catch！&quot;</span>+<span class=\"built_in\">this</span>.isInterrupted());</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从下面的输出结果来看，如果线程在 sleep 状态下停止，则该线程会进入 catch 语句，并且清除停止状态值，变成false。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">run start ...</span><br><span class=\"line\">complete!</span><br><span class=\"line\">在sleep中停止，进入<span class=\"keyword\">catch</span>！<span class=\"literal\">false</span></span><br><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">\tat java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">\tat com.fun.async.test.class03.SleepThreadInterrupt$MyThread.run(SleepThreadInterrupt.java:<span class=\"number\">26</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>不推荐使用 stop、suspend、resume 这三个过期作废的方法，因为有可能会发生不可预料的结果而且出现错误后还比较难定位。</p>\n<p>不推荐使用 Thread.stop() 的原因。这个方法是从外面让线程<strong>强制停止</strong>，如果停止的线程持有一个临界锁， 把一个对象置于一个不一致的状态（包含临界、持久化、游离），说白了就是造成数据不一致的结果。大多数情况下，停止一个线程使用  Thread.interrupt() 方法，但是这个方法不会终止一个正在运行状态的线程，还需要加入一些判断才能完成停止线程。</p>\n<p>在Java中有3种方式停止正在运行的线程：</p>\n<p>​        1、使用退出标志，正常退出；</p>\n<p>​        2、使用 stop()， 强行终止；</p>\n<p>​        3、使用 interrupt() 方法，中断线程；</p>\n<h2 id=\"interrupt-初体验\"><a href=\"#interrupt-初体验\" class=\"headerlink\" title=\"interrupt() 初体验\"></a>interrupt() 初体验</h2><p>​    一上来就按照下面这种方式运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        myThread.interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;mrdjun&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现结果输出了 <strong>1000000</strong> 行，而且 mrdjun 还输出在了中间，说明 interrupt 并没有让线程停下来。</p>\n<h2 id=\"判断线程是否为停止状态\"><a href=\"#判断线程是否为停止状态\" class=\"headerlink\" title=\"判断线程是否为停止状态\"></a>判断线程是否为停止状态</h2><p>​    下面Java提供了两个判断线程是否为停止状态的方法。</p>\n<p>​    public static boolean interrupted() ：使用 Thread.interrupted() 测试当前线程是否已经中断，执行后清楚状态标志值为 false 的功能。</p>\n<p>​    public boolean this.isInterrupted()： 测试 this 关键字所在类的对象是否已经中断，不清楚标志。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        myThread.interrupt(); <span class=\"comment\">// 作用于 myThread 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// isInterrupted 测试当前线程是否已经中断</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+myThread.isInterrupted());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+myThread.isInterrupted());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        补充一点：也可以使用 Thread.interrupted() 来判断当前线程是否已经中断，因为在 Thread.java 这个类中调用静态static方法的时候，大多数是针对 currentThread() 线程进行操作的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">      \tThread.currentThread().interrupt(); <span class=\"comment\">// 作用于 Thread</span></span><br><span class=\"line\">        <span class=\"comment\">// isInterrupted 测试当前线程是否已经中断</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+ Thread.interrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span>+ Thread.interrupted()); <span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;END!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>出乎意料的是结果输出不一致，查看官方帮助文档中的 interrupted() 解释：</p>\n<blockquote>\n<p>测试当前线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。</p>\n</blockquote>\n<p>isInterrupted() 的方法声明如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isInterrupted</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>很显然，这个方法不是一个static方法，作用于这个方法的对象，如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t    myThread.interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span> + myThread.isInterrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程是否停止？&quot;</span> + myThread.isInterrupted()); <span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;END!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>综上所述，两者区别如下：</p>\n<p>（1）Thread.interrupted() 测试线程是否已经中断，执行后具有清除状态标志值为false的功能；</p>\n<p>（2）new Thread().isInterrupted() 测试线程Thread对象是否已经是中断状态，不清除状态标志；</p>\n<h2 id=\"能停止的线程——异常法\"><a href=\"#能停止的线程——异常法\" class=\"headerlink\" title=\"能停止的线程——异常法\"></a>能停止的线程——异常法</h2><p>​    在main方法中两秒后调用 Thread 对象的 myThread.interrupt() 方法，在线程中的for循环中加入 if 判断后面的代码是否可以运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        myThread.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000000</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (interrupted()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;线程已经停止&quot;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 退出当前循环，如果为 return; 或 throw new InterruptedException() 则直接退出当前线程</span></span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterruptedException</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;for循环外面的语句&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抛出异常方式详情：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">            myThread.start();</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            myThread.interrupt();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000000</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (interrupted()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;线程已经停止&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InterruptedException</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;i=&quot;</span> + (i + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;for循环外面的语句&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;抛出异常&quot;</span>);</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过下面的运行结果可以看出，线程终于被正确的停止了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i=<span class=\"number\">312961</span></span><br><span class=\"line\">i=<span class=\"number\">312962</span></span><br><span class=\"line\">线程已经停止</span><br><span class=\"line\">抛出异常</span><br><span class=\"line\">java.lang.InterruptedException</span><br><span class=\"line\">\tat com.fun.async.test.class03.MyThread.run(ThreadInterrupt.java:<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在-sleep-状态下停止线程\"><a href=\"#在-sleep-状态下停止线程\" class=\"headerlink\" title=\"在 sleep 状态下停止线程\"></a>在 sleep 状态下停止线程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SleepThreadInterrupt</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">MyThread</span> <span class=\"variable\">thread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>();</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">200</span>); <span class=\"comment\">// 先sleep 在调用 interrupt</span></span><br><span class=\"line\">            thread.interrupt();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;complete!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;main catch&quot;</span>);</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;run start ...&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">200000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;run end!&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;在sleep中停止，进入catch！&quot;</span>+<span class=\"built_in\">this</span>.isInterrupted());</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从下面的输出结果来看，如果线程在 sleep 状态下停止，则该线程会进入 catch 语句，并且清除停止状态值，变成false。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">run start ...</span><br><span class=\"line\">complete!</span><br><span class=\"line\">在sleep中停止，进入<span class=\"keyword\">catch</span>！<span class=\"literal\">false</span></span><br><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">\tat java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">\tat com.fun.async.test.class03.SleepThreadInterrupt$MyThread.run(SleepThreadInterrupt.java:<span class=\"number\">26</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"Unsafe","date":"2021-08-22T08:49:26.000Z","_content":"\n主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等。Java 无法直接操作内存，Unsafe类相当于Java的后门，可以通过C++来操作内存。\n\nJDK并不建议直接使用Unsafe类，“Unsafe” 类名的由来：在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”。而且JDK底层有很多针对不同平台运行的代码，使用Unsafe类可能会造成一些跨平台的问题。\n\n> Unsafe类提供了哪些功能？\n\nDirectByteBuffer：在该类中使用Unsafe对内存进行管理，是Java用于实现堆外内存(直接内存)的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。\n\nLockSupport：线程调度。\n\nAtomicIntegerArray：数组操作，通过计算内存地址的偏移量来确定每个元素所在的位置。\n\nStampedLock：内存屏障。\n\njava.nio.Bits：系统管理， 计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑,该类在私包中，无法正常初始化。\n\n![20191211175818692](JUC-Unsafe/20191211175818692.png)\n\n在 `java.util.concurrent.atomic` 包下绝大多数类的源码中都使用到了Unsafe这个类。例如`AtomicInteger`：\n\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    // setup to use Unsafe.compareAndSwapInt for updates\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n    ...\n}\n```\n\n在Unsafe类中有以下三个方法：\n\n```java\n/**\n * @param var1 操作的对象\n * @param var2 操作对象的属性偏移量，用于获取该属性在内存中的具体地址\n * @param var4 期望值，读取传入对象o在内存中偏移量为offset位置的值与期望值expected作比较\n *             相等就把x值赋值给offset位置的值。方法返回true\n * @param var5 目标值\n * @return 与目标的期望值不相等返回false\n */\npublic final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);\n\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n\npublic final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);\n```\n\n使用Unsafe类的方法对线程不安全的add()方法进行修改：\n\n```java\nprivate int value = 0;\n/**\n * 获取并使用 Unsafe 对象：\n * Java 无法直接操作内存，但可以通过C++来操作内存，\n * Unsafe类相当于Java的后门，可以通过这个类来操作内存、修改对象、数组内存\n */\nprivate static Unsafe unsafe;\n/**\n * 获取到value属性偏移量，用于定义value属性在内存中的具体地址\n */\nprivate static long valueOffset;\n\nstatic {\n    try {\n        // 通过反射获取Unsafe对象\n        Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n        field.setAccessible(true);\n        // 获取Unsafe实例\n        unsafe = (Unsafe) field.get(null);\n        valueOffset = unsafe.objectFieldOffset(CASDemo.class.getDeclaredField(\"value\"));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n/**\n * 该方法经过以下问题不断改进\n */\npublic void add() {\n    // 1、三个步骤\n    // value++;\n    // 2、可能会失败，不能每次都成功\n    // unsafe.compareAndSwapInt(this, valueOffset, value, value + 1);\n    // 3、CAS+死循环重试，确保每一次都能操作成功\n    int current, target;\n    do {\n        // 当前值可能被其它线程改了，每一次循环都重新获取一次值\n        current = unsafe.getIntVolatile(this, valueOffset);\n        target = current + 1;\n        // current 是期望值，如果比较的期望值相同则修改为值为target，并返回true\n    } while (!unsafe.compareAndSwapInt(this, valueOffset, current, target));\n}\n\npublic void test2() throws InterruptedException {\n    for (int i = 0; i < 2; i++) {\n        new Thread(() -> {\n            for (int j = 0; j < 1000; j++) {\n                add();\n            }\n        }).start();\n    }\n\n    TimeUnit.SECONDS.sleep(2);\n    System.out.println(value);\n}\n```\n\n","source":"_posts/JUC-Unsafe.md","raw":"---\ntitle: Unsafe\ndate: 2021-08-22 16:49:26\ntags:\n- Juc并发包\n---\n\n主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等。Java 无法直接操作内存，Unsafe类相当于Java的后门，可以通过C++来操作内存。\n\nJDK并不建议直接使用Unsafe类，“Unsafe” 类名的由来：在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”。而且JDK底层有很多针对不同平台运行的代码，使用Unsafe类可能会造成一些跨平台的问题。\n\n> Unsafe类提供了哪些功能？\n\nDirectByteBuffer：在该类中使用Unsafe对内存进行管理，是Java用于实现堆外内存(直接内存)的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。\n\nLockSupport：线程调度。\n\nAtomicIntegerArray：数组操作，通过计算内存地址的偏移量来确定每个元素所在的位置。\n\nStampedLock：内存屏障。\n\njava.nio.Bits：系统管理， 计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑,该类在私包中，无法正常初始化。\n\n![20191211175818692](JUC-Unsafe/20191211175818692.png)\n\n在 `java.util.concurrent.atomic` 包下绝大多数类的源码中都使用到了Unsafe这个类。例如`AtomicInteger`：\n\n```java\npublic class AtomicInteger extends Number implements java.io.Serializable {\n    // setup to use Unsafe.compareAndSwapInt for updates\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n    ...\n}\n```\n\n在Unsafe类中有以下三个方法：\n\n```java\n/**\n * @param var1 操作的对象\n * @param var2 操作对象的属性偏移量，用于获取该属性在内存中的具体地址\n * @param var4 期望值，读取传入对象o在内存中偏移量为offset位置的值与期望值expected作比较\n *             相等就把x值赋值给offset位置的值。方法返回true\n * @param var5 目标值\n * @return 与目标的期望值不相等返回false\n */\npublic final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);\n\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n\npublic final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);\n```\n\n使用Unsafe类的方法对线程不安全的add()方法进行修改：\n\n```java\nprivate int value = 0;\n/**\n * 获取并使用 Unsafe 对象：\n * Java 无法直接操作内存，但可以通过C++来操作内存，\n * Unsafe类相当于Java的后门，可以通过这个类来操作内存、修改对象、数组内存\n */\nprivate static Unsafe unsafe;\n/**\n * 获取到value属性偏移量，用于定义value属性在内存中的具体地址\n */\nprivate static long valueOffset;\n\nstatic {\n    try {\n        // 通过反射获取Unsafe对象\n        Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n        field.setAccessible(true);\n        // 获取Unsafe实例\n        unsafe = (Unsafe) field.get(null);\n        valueOffset = unsafe.objectFieldOffset(CASDemo.class.getDeclaredField(\"value\"));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n/**\n * 该方法经过以下问题不断改进\n */\npublic void add() {\n    // 1、三个步骤\n    // value++;\n    // 2、可能会失败，不能每次都成功\n    // unsafe.compareAndSwapInt(this, valueOffset, value, value + 1);\n    // 3、CAS+死循环重试，确保每一次都能操作成功\n    int current, target;\n    do {\n        // 当前值可能被其它线程改了，每一次循环都重新获取一次值\n        current = unsafe.getIntVolatile(this, valueOffset);\n        target = current + 1;\n        // current 是期望值，如果比较的期望值相同则修改为值为target，并返回true\n    } while (!unsafe.compareAndSwapInt(this, valueOffset, current, target));\n}\n\npublic void test2() throws InterruptedException {\n    for (int i = 0; i < 2; i++) {\n        new Thread(() -> {\n            for (int j = 0; j < 1000; j++) {\n                add();\n            }\n        }).start();\n    }\n\n    TimeUnit.SECONDS.sleep(2);\n    System.out.println(value);\n}\n```\n\n","slug":"JUC-Unsafe","published":1,"updated":"2022-03-05T12:41:03.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0eqk39q000go4u56didfe4p","content":"<p>主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等。Java 无法直接操作内存，Unsafe类相当于Java的后门，可以通过C++来操作内存。</p>\n<p>JDK并不建议直接使用Unsafe类，“Unsafe” 类名的由来：在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”。而且JDK底层有很多针对不同平台运行的代码，使用Unsafe类可能会造成一些跨平台的问题。</p>\n<blockquote>\n<p>Unsafe类提供了哪些功能？</p>\n</blockquote>\n<p>DirectByteBuffer：在该类中使用Unsafe对内存进行管理，是Java用于实现堆外内存(直接内存)的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。</p>\n<p>LockSupport：线程调度。</p>\n<p>AtomicIntegerArray：数组操作，通过计算内存地址的偏移量来确定每个元素所在的位置。</p>\n<p>StampedLock：内存屏障。</p>\n<p>java.nio.Bits：系统管理， 计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑,该类在私包中，无法正常初始化。</p>\n<p><img src=\"/JUC-Unsafe/20191211175818692.png\" alt=\"20191211175818692\"></p>\n<p>在 <code>java.util.concurrent.atomic</code> 包下绝大多数类的源码中都使用到了Unsafe这个类。例如<code>AtomicInteger</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable &#123;</span><br><span class=\"line\">    <span class=\"comment\">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Unsafe</span> <span class=\"variable\">unsafe</span> <span class=\"operator\">=</span> Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">                (AtomicInteger.class.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Unsafe类中有以下三个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> var1 操作的对象</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> var2 操作对象的属性偏移量，用于获取该属性在内存中的具体地址</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> var4 期望值，读取传入对象o在内存中偏移量为offset位置的值与期望值expected作比较</span></span><br><span class=\"line\"><span class=\"comment\"> *             相等就把x值赋值给offset位置的值。方法返回true</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> var5 目标值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 与目标的期望值不相等返回false</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapObject</span><span class=\"params\">(Object var1, <span class=\"type\">long</span> var2, Object var4, Object var5)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"type\">long</span> var2, <span class=\"type\">int</span> var4, <span class=\"type\">int</span> var5)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapLong</span><span class=\"params\">(Object var1, <span class=\"type\">long</span> var2, <span class=\"type\">long</span> var4, <span class=\"type\">long</span> var6)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用Unsafe类的方法对线程不安全的add()方法进行修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取并使用 Unsafe 对象：</span></span><br><span class=\"line\"><span class=\"comment\"> * Java 无法直接操作内存，但可以通过C++来操作内存，</span></span><br><span class=\"line\"><span class=\"comment\"> * Unsafe类相当于Java的后门，可以通过这个类来操作内存、修改对象、数组内存</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Unsafe unsafe;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取到value属性偏移量，用于定义value属性在内存中的具体地址</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过反射获取Unsafe对象</span></span><br><span class=\"line\">        <span class=\"type\">Field</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> Unsafe.class.getDeclaredField(<span class=\"string\">&quot;theUnsafe&quot;</span>);</span><br><span class=\"line\">        field.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取Unsafe实例</span></span><br><span class=\"line\">        unsafe = (Unsafe) field.get(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        valueOffset = unsafe.objectFieldOffset(CASDemo.class.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 该方法经过以下问题不断改进</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1、三个步骤</span></span><br><span class=\"line\">    <span class=\"comment\">// value++;</span></span><br><span class=\"line\">    <span class=\"comment\">// 2、可能会失败，不能每次都成功</span></span><br><span class=\"line\">    <span class=\"comment\">// unsafe.compareAndSwapInt(this, valueOffset, value, value + 1);</span></span><br><span class=\"line\">    <span class=\"comment\">// 3、CAS+死循环重试，确保每一次都能操作成功</span></span><br><span class=\"line\">    <span class=\"type\">int</span> current, target;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前值可能被其它线程改了，每一次循环都重新获取一次值</span></span><br><span class=\"line\">        current = unsafe.getIntVolatile(<span class=\"built_in\">this</span>, valueOffset);</span><br><span class=\"line\">        target = current + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// current 是期望值，如果比较的期望值相同则修改为值为target，并返回true</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!unsafe.compareAndSwapInt(<span class=\"built_in\">this</span>, valueOffset, current, target));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++) &#123;</span><br><span class=\"line\">                add();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等。Java 无法直接操作内存，Unsafe类相当于Java的后门，可以通过C++来操作内存。</p>\n<p>JDK并不建议直接使用Unsafe类，“Unsafe” 类名的由来：在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”。而且JDK底层有很多针对不同平台运行的代码，使用Unsafe类可能会造成一些跨平台的问题。</p>\n<blockquote>\n<p>Unsafe类提供了哪些功能？</p>\n</blockquote>\n<p>DirectByteBuffer：在该类中使用Unsafe对内存进行管理，是Java用于实现堆外内存(直接内存)的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。</p>\n<p>LockSupport：线程调度。</p>\n<p>AtomicIntegerArray：数组操作，通过计算内存地址的偏移量来确定每个元素所在的位置。</p>\n<p>StampedLock：内存屏障。</p>\n<p>java.nio.Bits：系统管理， 计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑,该类在私包中，无法正常初始化。</p>\n<p><img src=\"/JUC-Unsafe/20191211175818692.png\" alt=\"20191211175818692\"></p>\n<p>在 <code>java.util.concurrent.atomic</code> 包下绝大多数类的源码中都使用到了Unsafe这个类。例如<code>AtomicInteger</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicInteger</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Number</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable &#123;</span><br><span class=\"line\">    <span class=\"comment\">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Unsafe</span> <span class=\"variable\">unsafe</span> <span class=\"operator\">=</span> Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">                (AtomicInteger.class.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(ex); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Unsafe类中有以下三个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> var1 操作的对象</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> var2 操作对象的属性偏移量，用于获取该属性在内存中的具体地址</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> var4 期望值，读取传入对象o在内存中偏移量为offset位置的值与期望值expected作比较</span></span><br><span class=\"line\"><span class=\"comment\"> *             相等就把x值赋值给offset位置的值。方法返回true</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> var5 目标值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 与目标的期望值不相等返回false</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapObject</span><span class=\"params\">(Object var1, <span class=\"type\">long</span> var2, Object var4, Object var5)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapInt</span><span class=\"params\">(Object var1, <span class=\"type\">long</span> var2, <span class=\"type\">int</span> var4, <span class=\"type\">int</span> var5)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapLong</span><span class=\"params\">(Object var1, <span class=\"type\">long</span> var2, <span class=\"type\">long</span> var4, <span class=\"type\">long</span> var6)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用Unsafe类的方法对线程不安全的add()方法进行修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取并使用 Unsafe 对象：</span></span><br><span class=\"line\"><span class=\"comment\"> * Java 无法直接操作内存，但可以通过C++来操作内存，</span></span><br><span class=\"line\"><span class=\"comment\"> * Unsafe类相当于Java的后门，可以通过这个类来操作内存、修改对象、数组内存</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Unsafe unsafe;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取到value属性偏移量，用于定义value属性在内存中的具体地址</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过反射获取Unsafe对象</span></span><br><span class=\"line\">        <span class=\"type\">Field</span> <span class=\"variable\">field</span> <span class=\"operator\">=</span> Unsafe.class.getDeclaredField(<span class=\"string\">&quot;theUnsafe&quot;</span>);</span><br><span class=\"line\">        field.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取Unsafe实例</span></span><br><span class=\"line\">        unsafe = (Unsafe) field.get(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        valueOffset = unsafe.objectFieldOffset(CASDemo.class.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 该方法经过以下问题不断改进</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1、三个步骤</span></span><br><span class=\"line\">    <span class=\"comment\">// value++;</span></span><br><span class=\"line\">    <span class=\"comment\">// 2、可能会失败，不能每次都成功</span></span><br><span class=\"line\">    <span class=\"comment\">// unsafe.compareAndSwapInt(this, valueOffset, value, value + 1);</span></span><br><span class=\"line\">    <span class=\"comment\">// 3、CAS+死循环重试，确保每一次都能操作成功</span></span><br><span class=\"line\">    <span class=\"type\">int</span> current, target;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前值可能被其它线程改了，每一次循环都重新获取一次值</span></span><br><span class=\"line\">        current = unsafe.getIntVolatile(<span class=\"built_in\">this</span>, valueOffset);</span><br><span class=\"line\">        target = current + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// current 是期望值，如果比较的期望值相同则修改为值为target，并返回true</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!unsafe.compareAndSwapInt(<span class=\"built_in\">this</span>, valueOffset, current, target));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++) &#123;</span><br><span class=\"line\">                add();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"JMM内存模型","date":"2021-05-05T10:40:12.000Z","_content":"\nJMM全称Java Memory Model，Java内存模型是JSR133里指出了JMM是用来定义一个**一致的、跨平台**的内存模型，是缓存一致性协议，用于屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台下都能达到一致的并发效果。\n\n## 区分开内存结构\n\n内存结构和内存模型完全是两个东西，内存结构是下图中的这些\n\n![img](JVM-JMM-Memory-Model/webp.webp)\n\n## 什么是内存模型\n\n在多CPU的系统中，每个CPU都有多级缓存，一般分[为L1、L2、L3缓存](./JUC-CPU-Performance-Optimization.html)，因为这些缓存的存在，提升了吞吐量，减轻了数据总线上数据传输的压力，同时也带来了很多新的挑战，比如两个CPU同时去操作同一个内存地址，会发生什么？在什么条件下，它们可以看到相同的结果？这些都是需要解决的。\n\n\n\n在JVM中堆（heap）和方法区是线程共享区域，虚拟机栈、本地方法栈和程序计数器是线程独占部分。虚拟机栈中有多个线程，每个线程对应一个栈帧，每个栈帧中存放有局部变量表、操作数栈、方法返回地址等。线程与线程之间是不能够直接建立沟通的，需要借助于共享区域才来建立沟通。\n\n内存模型的含义：Java编程语言内存模型通过检查执行跟踪中的每个读操作，并根据某些规则检查该读操作观察到的写操作是否有效来工作。只要程序的所有执行产生的结果都可以由内存模型预测。具体的实现者任意实现，包括操作的重新排序和删除不必要的同步。\n\nJMM 内存模型是一种虚拟机的规范，描述程序的可能行为。\n\n- 线程解锁前，必须把共享变量立刻刷回主存。\n\n- 线程加锁前，必须读取主存中的最新值到工作内存中。\n\n- 加锁和解锁是同一把锁。\n\n![image-20220305205222083](JVM-JMM-Memory-Model/image-20220305205222083.png)\n\n线程A从主存中读到值flag=true，加载到自己的工作内存中（堆区），由执行引擎处理后将值再赋值给工作内存，写入存储过程（存储过程就是把store操作从工作内存中得到的变量放入主存中的操作）。\n\nlock 作用于主内存的变量，把一个变量标识为线程独占状态，unlock 也是作用于主内存的变量，将被锁定的变量释放出来，释放后才能被其它线程锁定。\n\n","source":"_posts/JVM-JMM-Memory-Model.md","raw":"---\ntitle: JMM内存模型\ndate: 2021-05-05 18:40:12\ntags:\n- JVM\n---\n\nJMM全称Java Memory Model，Java内存模型是JSR133里指出了JMM是用来定义一个**一致的、跨平台**的内存模型，是缓存一致性协议，用于屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台下都能达到一致的并发效果。\n\n## 区分开内存结构\n\n内存结构和内存模型完全是两个东西，内存结构是下图中的这些\n\n![img](JVM-JMM-Memory-Model/webp.webp)\n\n## 什么是内存模型\n\n在多CPU的系统中，每个CPU都有多级缓存，一般分[为L1、L2、L3缓存](./JUC-CPU-Performance-Optimization.html)，因为这些缓存的存在，提升了吞吐量，减轻了数据总线上数据传输的压力，同时也带来了很多新的挑战，比如两个CPU同时去操作同一个内存地址，会发生什么？在什么条件下，它们可以看到相同的结果？这些都是需要解决的。\n\n\n\n在JVM中堆（heap）和方法区是线程共享区域，虚拟机栈、本地方法栈和程序计数器是线程独占部分。虚拟机栈中有多个线程，每个线程对应一个栈帧，每个栈帧中存放有局部变量表、操作数栈、方法返回地址等。线程与线程之间是不能够直接建立沟通的，需要借助于共享区域才来建立沟通。\n\n内存模型的含义：Java编程语言内存模型通过检查执行跟踪中的每个读操作，并根据某些规则检查该读操作观察到的写操作是否有效来工作。只要程序的所有执行产生的结果都可以由内存模型预测。具体的实现者任意实现，包括操作的重新排序和删除不必要的同步。\n\nJMM 内存模型是一种虚拟机的规范，描述程序的可能行为。\n\n- 线程解锁前，必须把共享变量立刻刷回主存。\n\n- 线程加锁前，必须读取主存中的最新值到工作内存中。\n\n- 加锁和解锁是同一把锁。\n\n![image-20220305205222083](JVM-JMM-Memory-Model/image-20220305205222083.png)\n\n线程A从主存中读到值flag=true，加载到自己的工作内存中（堆区），由执行引擎处理后将值再赋值给工作内存，写入存储过程（存储过程就是把store操作从工作内存中得到的变量放入主存中的操作）。\n\nlock 作用于主内存的变量，把一个变量标识为线程独占状态，unlock 也是作用于主内存的变量，将被锁定的变量释放出来，释放后才能被其它线程锁定。\n\n","slug":"JVM-JMM-Memory-Model","published":1,"updated":"2022-03-06T04:23:01.848Z","_id":"cl0eqk39r000jo4u58g241o49","comments":1,"layout":"post","photos":[],"link":"","content":"<p>JMM全称Java Memory Model，Java内存模型是JSR133里指出了JMM是用来定义一个<strong>一致的、跨平台</strong>的内存模型，是缓存一致性协议，用于屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台下都能达到一致的并发效果。</p>\n<h2 id=\"区分开内存结构\"><a href=\"#区分开内存结构\" class=\"headerlink\" title=\"区分开内存结构\"></a>区分开内存结构</h2><p>内存结构和内存模型完全是两个东西，内存结构是下图中的这些</p>\n<p><img src=\"/JVM-JMM-Memory-Model/webp.webp\" alt=\"img\"></p>\n<h2 id=\"什么是内存模型\"><a href=\"#什么是内存模型\" class=\"headerlink\" title=\"什么是内存模型\"></a>什么是内存模型</h2><p>在多CPU的系统中，每个CPU都有多级缓存，一般分<a href=\"./JUC-CPU-Performance-Optimization.html\">为L1、L2、L3缓存</a>，因为这些缓存的存在，提升了吞吐量，减轻了数据总线上数据传输的压力，同时也带来了很多新的挑战，比如两个CPU同时去操作同一个内存地址，会发生什么？在什么条件下，它们可以看到相同的结果？这些都是需要解决的。</p>\n<p>在JVM中堆（heap）和方法区是线程共享区域，虚拟机栈、本地方法栈和程序计数器是线程独占部分。虚拟机栈中有多个线程，每个线程对应一个栈帧，每个栈帧中存放有局部变量表、操作数栈、方法返回地址等。线程与线程之间是不能够直接建立沟通的，需要借助于共享区域才来建立沟通。</p>\n<p>内存模型的含义：Java编程语言内存模型通过检查执行跟踪中的每个读操作，并根据某些规则检查该读操作观察到的写操作是否有效来工作。只要程序的所有执行产生的结果都可以由内存模型预测。具体的实现者任意实现，包括操作的重新排序和删除不必要的同步。</p>\n<p>JMM 内存模型是一种虚拟机的规范，描述程序的可能行为。</p>\n<ul>\n<li><p>线程解锁前，必须把共享变量立刻刷回主存。</p>\n</li>\n<li><p>线程加锁前，必须读取主存中的最新值到工作内存中。</p>\n</li>\n<li><p>加锁和解锁是同一把锁。</p>\n</li>\n</ul>\n<p><img src=\"/JVM-JMM-Memory-Model/image-20220305205222083.png\" alt=\"image-20220305205222083\"></p>\n<p>线程A从主存中读到值flag=true，加载到自己的工作内存中（堆区），由执行引擎处理后将值再赋值给工作内存，写入存储过程（存储过程就是把store操作从工作内存中得到的变量放入主存中的操作）。</p>\n<p>lock 作用于主内存的变量，把一个变量标识为线程独占状态，unlock 也是作用于主内存的变量，将被锁定的变量释放出来，释放后才能被其它线程锁定。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>JMM全称Java Memory Model，Java内存模型是JSR133里指出了JMM是用来定义一个<strong>一致的、跨平台</strong>的内存模型，是缓存一致性协议，用于屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台下都能达到一致的并发效果。</p>\n<h2 id=\"区分开内存结构\"><a href=\"#区分开内存结构\" class=\"headerlink\" title=\"区分开内存结构\"></a>区分开内存结构</h2><p>内存结构和内存模型完全是两个东西，内存结构是下图中的这些</p>\n<p><img src=\"/JVM-JMM-Memory-Model/webp.webp\" alt=\"img\"></p>\n<h2 id=\"什么是内存模型\"><a href=\"#什么是内存模型\" class=\"headerlink\" title=\"什么是内存模型\"></a>什么是内存模型</h2><p>在多CPU的系统中，每个CPU都有多级缓存，一般分<a href=\"./JUC-CPU-Performance-Optimization.html\">为L1、L2、L3缓存</a>，因为这些缓存的存在，提升了吞吐量，减轻了数据总线上数据传输的压力，同时也带来了很多新的挑战，比如两个CPU同时去操作同一个内存地址，会发生什么？在什么条件下，它们可以看到相同的结果？这些都是需要解决的。</p>\n<p>在JVM中堆（heap）和方法区是线程共享区域，虚拟机栈、本地方法栈和程序计数器是线程独占部分。虚拟机栈中有多个线程，每个线程对应一个栈帧，每个栈帧中存放有局部变量表、操作数栈、方法返回地址等。线程与线程之间是不能够直接建立沟通的，需要借助于共享区域才来建立沟通。</p>\n<p>内存模型的含义：Java编程语言内存模型通过检查执行跟踪中的每个读操作，并根据某些规则检查该读操作观察到的写操作是否有效来工作。只要程序的所有执行产生的结果都可以由内存模型预测。具体的实现者任意实现，包括操作的重新排序和删除不必要的同步。</p>\n<p>JMM 内存模型是一种虚拟机的规范，描述程序的可能行为。</p>\n<ul>\n<li><p>线程解锁前，必须把共享变量立刻刷回主存。</p>\n</li>\n<li><p>线程加锁前，必须读取主存中的最新值到工作内存中。</p>\n</li>\n<li><p>加锁和解锁是同一把锁。</p>\n</li>\n</ul>\n<p><img src=\"/JVM-JMM-Memory-Model/image-20220305205222083.png\" alt=\"image-20220305205222083\"></p>\n<p>线程A从主存中读到值flag=true，加载到自己的工作内存中（堆区），由执行引擎处理后将值再赋值给工作内存，写入存储过程（存储过程就是把store操作从工作内存中得到的变量放入主存中的操作）。</p>\n<p>lock 作用于主内存的变量，把一个变量标识为线程独占状态，unlock 也是作用于主内存的变量，将被锁定的变量释放出来，释放后才能被其它线程锁定。</p>\n"}],"PostAsset":[{"_id":"source/_posts/JUC-AbstractQueuedSynchronizer/AQS-接口.png","slug":"AQS-接口.png","post":"cl0eqk39h0003o4u5bilk0fx3","modified":0,"renderable":0},{"_id":"source/_posts/JUC-AbstractQueuedSynchronizer/AQS-资源占用流程.png","slug":"AQS-资源占用流程.png","post":"cl0eqk39h0003o4u5bilk0fx3","modified":0,"renderable":0},{"_id":"source/_posts/JAVA-ArrayList&LinkedList/QQ20210219-143407@2x.png","slug":"QQ20210219-143407@2x.png","post":"cl0eqk39e0001o4u50zpm8vio","modified":0,"renderable":0},{"_id":"source/_posts/JAVA-ArrayList&LinkedList/QQ20210220-112151@2x.png","slug":"QQ20210220-112151@2x.png","post":"cl0eqk39e0001o4u50zpm8vio","modified":0,"renderable":0},{"_id":"source/_posts/JAVA-ArrayList&LinkedList/QQ20210220-112546@2x.png","slug":"QQ20210220-112546@2x.png","post":"cl0eqk39e0001o4u50zpm8vio","modified":0,"renderable":0},{"_id":"source/_posts/JUC-CPU-Performance-Optimization/CPU高速缓存级别.png","slug":"CPU高速缓存级别.png","post":"cl0eqk39l0006o4u5hxrv8vmr","modified":0,"renderable":0},{"_id":"source/_posts/JUC-CPU-Performance-Optimization/image-20220305180930700.png","slug":"image-20220305180930700.png","post":"cl0eqk39l0006o4u5hxrv8vmr","modified":0,"renderable":0},{"_id":"source/_posts/JUC-CAS/1193919-20180102142540362-571280295.png","slug":"1193919-20180102142540362-571280295.png","post":"cl0eqk39k0005o4u50rnwhnmh","modified":0,"renderable":0},{"_id":"source/_posts/JUC-CAS/1193919-20180102142542299-1617994496.png","slug":"1193919-20180102142542299-1617994496.png","post":"cl0eqk39k0005o4u50rnwhnmh","modified":0,"renderable":0},{"_id":"source/_posts/JUC-CAS/1193919-20180102142543784-1625100143.png","slug":"1193919-20180102142543784-1625100143.png","post":"cl0eqk39k0005o4u50rnwhnmh","modified":0,"renderable":0},{"_id":"source/_posts/JUC-CAS/1193919-20180102142545221-837543615.png","slug":"1193919-20180102142545221-837543615.png","post":"cl0eqk39k0005o4u50rnwhnmh","modified":0,"renderable":0},{"_id":"source/_posts/JUC-CAS/1193919-20180102142546909-270453852.png","slug":"1193919-20180102142546909-270453852.png","post":"cl0eqk39k0005o4u50rnwhnmh","modified":0,"renderable":0},{"_id":"source/_posts/JUC-CAS/1193919-20180102142548299-328053032-16464619321157.png","slug":"1193919-20180102142548299-328053032-16464619321157.png","post":"cl0eqk39k0005o4u50rnwhnmh","modified":0,"renderable":0},{"_id":"source/_posts/JUC-CAS/1193919-20180102142548299-328053032.png","slug":"1193919-20180102142548299-328053032.png","post":"cl0eqk39k0005o4u50rnwhnmh","modified":0,"renderable":0},{"_id":"source/_posts/JUC-CAS/1193919-20180102142625753-443716413.png","slug":"1193919-20180102142625753-443716413.png","post":"cl0eqk39k0005o4u50rnwhnmh","modified":0,"renderable":0},{"_id":"source/_posts/JUC-ForkJoin/ForkJoin.png","slug":"ForkJoin.png","post":"cl0eqk39m000ao4u51ifqb9pg","modified":0,"renderable":0},{"_id":"source/_posts/JUC-Unsafe/20191211175818692.png","slug":"20191211175818692.png","post":"cl0eqk39q000go4u56didfe4p","modified":0,"renderable":0},{"_id":"source/_posts/JVM-JMM-Memory-Model/image-20220305205222083.png","slug":"image-20220305205222083.png","post":"cl0eqk39r000jo4u58g241o49","modified":0,"renderable":0},{"_id":"source/_posts/JVM-JMM-Memory-Model/webp.webp","slug":"webp.webp","post":"cl0eqk39r000jo4u58g241o49","modified":1,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cl0eqk39e0001o4u50zpm8vio","tag_id":"cl0eqk39j0004o4u546rc1249","_id":"cl0eqk39m0009o4u56cte0wk5"},{"post_id":"cl0eqk39m000ao4u51ifqb9pg","tag_id":"cl0eqk39m0008o4u56qa9gdcc","_id":"cl0eqk39p000do4u59odbajr8"},{"post_id":"cl0eqk39h0003o4u5bilk0fx3","tag_id":"cl0eqk39m0008o4u56qa9gdcc","_id":"cl0eqk39q000fo4u51qlp350g"},{"post_id":"cl0eqk39o000bo4u5hbvmgtig","tag_id":"cl0eqk39m0008o4u56qa9gdcc","_id":"cl0eqk39r000io4u5cbdyfhdg"},{"post_id":"cl0eqk39p000eo4u5hzwac9e3","tag_id":"cl0eqk39m0008o4u56qa9gdcc","_id":"cl0eqk39s000ko4u51xrw7ot3"},{"post_id":"cl0eqk39k0005o4u50rnwhnmh","tag_id":"cl0eqk39m0008o4u56qa9gdcc","_id":"cl0eqk39s000mo4u5glw2f0e0"},{"post_id":"cl0eqk39q000go4u56didfe4p","tag_id":"cl0eqk39m0008o4u56qa9gdcc","_id":"cl0eqk39s000no4u59lv23qx6"},{"post_id":"cl0eqk39l0006o4u5hxrv8vmr","tag_id":"cl0eqk39m0008o4u56qa9gdcc","_id":"cl0eqk39t000po4u5cxwnfk24"},{"post_id":"cl0eqk39l0007o4u5dbivhmlv","tag_id":"cl0eqk39m0008o4u56qa9gdcc","_id":"cl0eqk39t000qo4u5fsit5cyw"},{"post_id":"cl0eqk39r000jo4u58g241o49","tag_id":"cl0eqk39t000oo4u5878z6nu4","_id":"cl0eqk39t000ro4u58ve59zsu"}],"Tag":[{"name":"Java","_id":"cl0eqk39j0004o4u546rc1249"},{"name":"Juc并发包","_id":"cl0eqk39m0008o4u56qa9gdcc"},{"name":"JVM","_id":"cl0eqk39t000oo4u5878z6nu4"}]}}